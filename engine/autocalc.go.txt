package engine

// Bookkeeping for auto-saving quantities at given intervals.

var (
	calcOP        = make(map[Quantity]*autocalc) // when to save quantities
	autonumCalc   = make(map[string]int)         // auto number for out file
	autonumCalcAs = make(map[string]int)         // auto number for out file
)

func init() {
	DeclFunc("SetAutoNumCalcTo", SetAutoNumCalcTo, "")
	DeclFunc("SetAutoNumCalcToAs", SetAutoNumCalcToAs, "")
	DeclFunc("autocalc", AutoCalc, "Auto save space-dependent quantity every period (s).")
	DeclFunc("autocalcAs", AutoCalcAs, "Auto save space-dependent quantity every period (s).")
}

func SetAutoNumCalcTo(v int) {
	for key, _ := range autonum {
		autonum[key] = v
	}
}

func SetAutoNumCalcToAs(v int) {
	for key, _ := range autonumAs {
		autonumAs[key] = v
	}
}

// Periodically called by run loop to save everything that's needed at this time.
func Docalc() {
	for q, a := range calcOP {
		if a.needSave() {
			if a.qname == "" {
				a.save(q)
				a.count++
			} else {
				a.saveAs(q, a.qname)
				a.count++
			}
		}
	}
}

// Register quant to be auto-saved every period.
// period == 0 stops autosaving.
func AutoCalc(q Quantity, period float64) {
	autonumCalc[NameOf(q)] = 0
	autoCalc(q, period, Calc, CalcAs)
}
func AutoCalcAs(q Quantity, period float64, name string) {
	autonumCalcAs[name] = 0
	autoCalcAs(q, period, Calc, CalcAs, name)
}

// register save(q) to be called every period
func autoCalc(q Quantity, period float64, calc func(Quantity), calcAs func(Quantity, string)) {
	if period == 0 {
		delete(calcOP, q)
	} else {
		calcOP[q] = &autocalc{period, Time, -1, calc, calcAs, NameOf(q)} // init count to -1 allows save at t=0
	}
}

// register save(q) to be called every period
func autoCalcAs(q Quantity, period float64, calc func(Quantity), calcAs func(Quantity, string), name string) {
	if period == 0 {
		delete(calcOP, q)
	} else {
		calcOP[q] = &autocalc{period, Time, -1, calc, calcAs, name} // init count to -1 allows save at t=0
	}
}

// keeps info needed to decide when a quantity needs to be periodically saved
type autocalc struct {
	period float64        // How often to save
	start  float64        // Starting point
	count  int            // Number of times it has been autocalcd
	save   func(Quantity) // called to do the actual save
	saveAs func(Quantity, string)
	qname  string
}

// returns true when the time is right to save.
func (a *autocalc) needSave() bool {
	t := Time - a.start
	return a.period != 0 && t-float64(a.count)*a.period >= a.period
}
