import {
  twMerge
} from "./chunk-AR74TD66.js";
import {
  add_locations,
  check_target,
  component,
  hmr,
  if_block,
  legacy_api,
  prop,
  rest_props,
  set_attribute,
  set_attributes,
  spread_props,
  validate_prop_bindings
} from "./chunk-GESQUJ6F.js";
import "./chunk-OEZML75K.js";
import {
  append,
  comment,
  ns_template,
  set_text
} from "./chunk-GQAQPUPZ.js";
import {
  FILENAME,
  HMR,
  child,
  derived,
  first_child,
  get,
  getContext,
  mark_module_end,
  mark_module_start,
  next,
  pop,
  push,
  reset,
  set,
  sibling,
  template_effect
} from "./chunk-74EDFMAK.js";
import "./chunk-EXIRPMAV.js";
import "./chunk-5AQFBOJN.js";

// node_modules/flowbite-svelte-icons/dist/AddColumnAfterOutline.svelte
mark_module_start();
AddColumnAfterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AddColumnAfterOutline.svelte";
var root_1 = add_locations(ns_template(`<title> </title>`), AddColumnAfterOutline[FILENAME], [[41, 4]]);
var root_2 = add_locations(ns_template(`<desc> </desc>`), AddColumnAfterOutline[FILENAME], [[44, 4]]);
var root = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 5v14m8-7h-2m0 0h-2m2 0v2m0-2v-2M3 11h6m-6 4h6m11 4H4c-.55228 0-1-.4477-1-1V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v12c0 .5523-.4477 1-1 1Z"></path></svg>`), AddColumnAfterOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AddColumnAfterOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AddColumnAfterOutline);
  validate_prop_bindings($$props, [], [], AddColumnAfterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "add column after outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AddColumnAfterOutline = hmr(AddColumnAfterOutline, () => AddColumnAfterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AddColumnAfterOutline[HMR].source;
    set(AddColumnAfterOutline[HMR].source, module.default[HMR].original);
  });
}
var AddColumnAfterOutline_default = AddColumnAfterOutline;
mark_module_end(AddColumnAfterOutline);

// node_modules/flowbite-svelte-icons/dist/AddColumnBeforeOutline.svelte
mark_module_start();
AddColumnBeforeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AddColumnBeforeOutline.svelte";
var root_12 = add_locations(ns_template(`<title> </title>`), AddColumnBeforeOutline[FILENAME], [[41, 4]]);
var root_22 = add_locations(ns_template(`<desc> </desc>`), AddColumnBeforeOutline[FILENAME], [[44, 4]]);
var root2 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 5v14m-8-7h2m0 0h2m-2 0v2m0-2v-2m12 1h-6m6 4h-6M4 19h16c.5523 0 1-.4477 1-1V6c0-.55228-.4477-1-1-1H4c-.55228 0-1 .44772-1 1v12c0 .5523.44772 1 1 1Z"></path></svg>`), AddColumnBeforeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AddColumnBeforeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AddColumnBeforeOutline);
  validate_prop_bindings($$props, [], [], AddColumnBeforeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "add column before outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root2();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_12();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_22();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AddColumnBeforeOutline = hmr(AddColumnBeforeOutline, () => AddColumnBeforeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AddColumnBeforeOutline[HMR].source;
    set(AddColumnBeforeOutline[HMR].source, module.default[HMR].original);
  });
}
var AddColumnBeforeOutline_default = AddColumnBeforeOutline;
mark_module_end(AddColumnBeforeOutline);

// node_modules/flowbite-svelte-icons/dist/AddressBookOutline.svelte
mark_module_start();
AddressBookOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AddressBookOutline.svelte";
var root_13 = add_locations(ns_template(`<title> </title>`), AddressBookOutline[FILENAME], [[41, 4]]);
var root_23 = add_locations(ns_template(`<desc> </desc>`), AddressBookOutline[FILENAME], [[44, 4]]);
var root3 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 6H5m2 3H5m2 3H5m2 3H5m2 3H5m11-1a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2M7 3h11a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1Zm8 7a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg>`), AddressBookOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AddressBookOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AddressBookOutline);
  validate_prop_bindings($$props, [], [], AddressBookOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "address book outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root3();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_13();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_23();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AddressBookOutline = hmr(AddressBookOutline, () => AddressBookOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AddressBookOutline[HMR].source;
    set(AddressBookOutline[HMR].source, module.default[HMR].original);
  });
}
var AddressBookOutline_default = AddressBookOutline;
mark_module_end(AddressBookOutline);

// node_modules/flowbite-svelte-icons/dist/AddressBookSolid.svelte
mark_module_start();
AddressBookSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AddressBookSolid.svelte";
var root_14 = add_locations(ns_template(`<title> </title>`), AddressBookSolid[FILENAME], [[39, 4]]);
var root_24 = add_locations(ns_template(`<desc> </desc>`), AddressBookSolid[FILENAME], [[42, 4]]);
var root4 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M7 2a2 2 0 0 0-2 2v1a1 1 0 0 0 0 2v1a1 1 0 0 0 0 2v1a1 1 0 1 0 0 2v1a1 1 0 1 0 0 2v1a1 1 0 1 0 0 2v1a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2H7Zm3 8a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm-1 7a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3 1 1 0 0 1-1 1h-6a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), AddressBookSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function AddressBookSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AddressBookSolid);
  validate_prop_bindings($$props, [], [], AddressBookSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "address book solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root4();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_14();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_24();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AddressBookSolid = hmr(AddressBookSolid, () => AddressBookSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AddressBookSolid[HMR].source;
    set(AddressBookSolid[HMR].source, module.default[HMR].original);
  });
}
var AddressBookSolid_default = AddressBookSolid;
mark_module_end(AddressBookSolid);

// node_modules/flowbite-svelte-icons/dist/AdjustmentsHorizontalOutline.svelte
mark_module_start();
AdjustmentsHorizontalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AdjustmentsHorizontalOutline.svelte";
var root_15 = add_locations(ns_template(`<title> </title>`), AdjustmentsHorizontalOutline[FILENAME], [[41, 4]]);
var root_25 = add_locations(ns_template(`<desc> </desc>`), AdjustmentsHorizontalOutline[FILENAME], [[44, 4]]);
var root5 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M20 6H10m0 0a2 2 0 1 0-4 0m4 0a2 2 0 1 1-4 0m0 0H4m16 6h-2m0 0a2 2 0 1 0-4 0m4 0a2 2 0 1 1-4 0m0 0H4m16 6H10m0 0a2 2 0 1 0-4 0m4 0a2 2 0 1 1-4 0m0 0H4"></path></svg>`), AdjustmentsHorizontalOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AdjustmentsHorizontalOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AdjustmentsHorizontalOutline);
  validate_prop_bindings($$props, [], [], AdjustmentsHorizontalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "adjustments horizontal outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root5();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_15();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_25();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AdjustmentsHorizontalOutline = hmr(AdjustmentsHorizontalOutline, () => AdjustmentsHorizontalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AdjustmentsHorizontalOutline[HMR].source;
    set(AdjustmentsHorizontalOutline[HMR].source, module.default[HMR].original);
  });
}
var AdjustmentsHorizontalOutline_default = AdjustmentsHorizontalOutline;
mark_module_end(AdjustmentsHorizontalOutline);

// node_modules/flowbite-svelte-icons/dist/AdjustmentsHorizontalSolid.svelte
mark_module_start();
AdjustmentsHorizontalSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AdjustmentsHorizontalSolid.svelte";
var root_16 = add_locations(ns_template(`<title> </title>`), AdjustmentsHorizontalSolid[FILENAME], [[39, 4]]);
var root_26 = add_locations(ns_template(`<desc> </desc>`), AdjustmentsHorizontalSolid[FILENAME], [[42, 4]]);
var root6 = add_locations(ns_template(`<svg><!><!><path d="M10.83 5a3.001 3.001 0 0 0-5.66 0H4a1 1 0 1 0 0 2h1.17a3.001 3.001 0 0 0 5.66 0H20a1 1 0 1 0 0-2h-9.17ZM4 11h9.17a3.001 3.001 0 0 1 5.66 0H20a1 1 0 1 1 0 2h-1.17a3.001 3.001 0 0 1-5.66 0H4a1 1 0 1 1 0-2Zm1.17 6H4a1 1 0 1 0 0 2h1.17a3.001 3.001 0 0 0 5.66 0H20a1 1 0 1 0 0-2h-9.17a3.001 3.001 0 0 0-5.66 0Z"></path></svg>`), AdjustmentsHorizontalSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function AdjustmentsHorizontalSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AdjustmentsHorizontalSolid);
  validate_prop_bindings($$props, [], [], AdjustmentsHorizontalSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "adjustments horizontal solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root6();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_16();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_26();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AdjustmentsHorizontalSolid = hmr(AdjustmentsHorizontalSolid, () => AdjustmentsHorizontalSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AdjustmentsHorizontalSolid[HMR].source;
    set(AdjustmentsHorizontalSolid[HMR].source, module.default[HMR].original);
  });
}
var AdjustmentsHorizontalSolid_default = AdjustmentsHorizontalSolid;
mark_module_end(AdjustmentsHorizontalSolid);

// node_modules/flowbite-svelte-icons/dist/AdjustmentsVerticalOutline.svelte
mark_module_start();
AdjustmentsVerticalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AdjustmentsVerticalOutline.svelte";
var root_17 = add_locations(ns_template(`<title> </title>`), AdjustmentsVerticalOutline[FILENAME], [[41, 4]]);
var root_27 = add_locations(ns_template(`<desc> </desc>`), AdjustmentsVerticalOutline[FILENAME], [[44, 4]]);
var root7 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M6 4v10m0 0a2 2 0 1 0 0 4m0-4a2 2 0 1 1 0 4m0 0v2m6-16v2m0 0a2 2 0 1 0 0 4m0-4a2 2 0 1 1 0 4m0 0v10m6-16v10m0 0a2 2 0 1 0 0 4m0-4a2 2 0 1 1 0 4m0 0v2"></path></svg>`), AdjustmentsVerticalOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AdjustmentsVerticalOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AdjustmentsVerticalOutline);
  validate_prop_bindings($$props, [], [], AdjustmentsVerticalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "adjustments vertical outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root7();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_17();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_27();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AdjustmentsVerticalOutline = hmr(AdjustmentsVerticalOutline, () => AdjustmentsVerticalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AdjustmentsVerticalOutline[HMR].source;
    set(AdjustmentsVerticalOutline[HMR].source, module.default[HMR].original);
  });
}
var AdjustmentsVerticalOutline_default = AdjustmentsVerticalOutline;
mark_module_end(AdjustmentsVerticalOutline);

// node_modules/flowbite-svelte-icons/dist/AdjustmentsVerticalSolid.svelte
mark_module_start();
AdjustmentsVerticalSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AdjustmentsVerticalSolid.svelte";
var root_18 = add_locations(ns_template(`<title> </title>`), AdjustmentsVerticalSolid[FILENAME], [[39, 4]]);
var root_28 = add_locations(ns_template(`<desc> </desc>`), AdjustmentsVerticalSolid[FILENAME], [[42, 4]]);
var root8 = add_locations(ns_template(`<svg><!><!><path d="M5 13.17a3.001 3.001 0 0 0 0 5.66V20a1 1 0 1 0 2 0v-1.17a3.001 3.001 0 0 0 0-5.66V4a1 1 0 0 0-2 0v9.17ZM11 20v-9.17a3.001 3.001 0 0 1 0-5.66V4a1 1 0 1 1 2 0v1.17a3.001 3.001 0 0 1 0 5.66V20a1 1 0 1 1-2 0Zm6-1.17V20a1 1 0 1 0 2 0v-1.17a3.001 3.001 0 0 0 0-5.66V4a1 1 0 1 0-2 0v9.17a3.001 3.001 0 0 0 0 5.66Z"></path></svg>`), AdjustmentsVerticalSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function AdjustmentsVerticalSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AdjustmentsVerticalSolid);
  validate_prop_bindings($$props, [], [], AdjustmentsVerticalSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "adjustments vertical solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root8();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_18();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_28();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AdjustmentsVerticalSolid = hmr(AdjustmentsVerticalSolid, () => AdjustmentsVerticalSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AdjustmentsVerticalSolid[HMR].source;
    set(AdjustmentsVerticalSolid[HMR].source, module.default[HMR].original);
  });
}
var AdjustmentsVerticalSolid_default = AdjustmentsVerticalSolid;
mark_module_end(AdjustmentsVerticalSolid);

// node_modules/flowbite-svelte-icons/dist/AlignCenterOutline.svelte
mark_module_start();
AlignCenterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AlignCenterOutline.svelte";
var root_19 = add_locations(ns_template(`<title> </title>`), AlignCenterOutline[FILENAME], [[41, 4]]);
var root_29 = add_locations(ns_template(`<desc> </desc>`), AlignCenterOutline[FILENAME], [[44, 4]]);
var root9 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 6h8M6 10h12M8 14h8M6 18h12"></path></svg>`), AlignCenterOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AlignCenterOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AlignCenterOutline);
  validate_prop_bindings($$props, [], [], AlignCenterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "align center outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root9();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_19();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_29();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AlignCenterOutline = hmr(AlignCenterOutline, () => AlignCenterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AlignCenterOutline[HMR].source;
    set(AlignCenterOutline[HMR].source, module.default[HMR].original);
  });
}
var AlignCenterOutline_default = AlignCenterOutline;
mark_module_end(AlignCenterOutline);

// node_modules/flowbite-svelte-icons/dist/AlignJustifyOutline.svelte
mark_module_start();
AlignJustifyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AlignJustifyOutline.svelte";
var root_110 = add_locations(ns_template(`<title> </title>`), AlignJustifyOutline[FILENAME], [[41, 4]]);
var root_210 = add_locations(ns_template(`<desc> </desc>`), AlignJustifyOutline[FILENAME], [[44, 4]]);
var root10 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 6H6m12 4H6m12 4H6m12 4H6"></path></svg>`), AlignJustifyOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AlignJustifyOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AlignJustifyOutline);
  validate_prop_bindings($$props, [], [], AlignJustifyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "align justify outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root10();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_110();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_210();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AlignJustifyOutline = hmr(AlignJustifyOutline, () => AlignJustifyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AlignJustifyOutline[HMR].source;
    set(AlignJustifyOutline[HMR].source, module.default[HMR].original);
  });
}
var AlignJustifyOutline_default = AlignJustifyOutline;
mark_module_end(AlignJustifyOutline);

// node_modules/flowbite-svelte-icons/dist/AlignLeftOutline.svelte
mark_module_start();
AlignLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AlignLeftOutline.svelte";
var root_111 = add_locations(ns_template(`<title> </title>`), AlignLeftOutline[FILENAME], [[41, 4]]);
var root_211 = add_locations(ns_template(`<desc> </desc>`), AlignLeftOutline[FILENAME], [[44, 4]]);
var root11 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 6h8m-8 4h12M6 14h8m-8 4h12"></path></svg>`), AlignLeftOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AlignLeftOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AlignLeftOutline);
  validate_prop_bindings($$props, [], [], AlignLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "align left outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root11();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_111();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_211();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AlignLeftOutline = hmr(AlignLeftOutline, () => AlignLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AlignLeftOutline[HMR].source;
    set(AlignLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var AlignLeftOutline_default = AlignLeftOutline;
mark_module_end(AlignLeftOutline);

// node_modules/flowbite-svelte-icons/dist/AlignRightOutline.svelte
mark_module_start();
AlignRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AlignRightOutline.svelte";
var root_112 = add_locations(ns_template(`<title> </title>`), AlignRightOutline[FILENAME], [[41, 4]]);
var root_212 = add_locations(ns_template(`<desc> </desc>`), AlignRightOutline[FILENAME], [[44, 4]]);
var root12 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 6h-8m8 4H6m12 4h-8m8 4H6"></path></svg>`), AlignRightOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AlignRightOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AlignRightOutline);
  validate_prop_bindings($$props, [], [], AlignRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "align right outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root12();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_112();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_212();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AlignRightOutline = hmr(AlignRightOutline, () => AlignRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AlignRightOutline[HMR].source;
    set(AlignRightOutline[HMR].source, module.default[HMR].original);
  });
}
var AlignRightOutline_default = AlignRightOutline;
mark_module_end(AlignRightOutline);

// node_modules/flowbite-svelte-icons/dist/AngleDownOutline.svelte
mark_module_start();
AngleDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AngleDownOutline.svelte";
var root_113 = add_locations(ns_template(`<title> </title>`), AngleDownOutline[FILENAME], [[41, 4]]);
var root_213 = add_locations(ns_template(`<desc> </desc>`), AngleDownOutline[FILENAME], [[44, 4]]);
var root13 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m19 9-7 7-7-7"></path></svg>`), AngleDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AngleDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AngleDownOutline);
  validate_prop_bindings($$props, [], [], AngleDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "angle down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root13();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_113();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_213();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AngleDownOutline = hmr(AngleDownOutline, () => AngleDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AngleDownOutline[HMR].source;
    set(AngleDownOutline[HMR].source, module.default[HMR].original);
  });
}
var AngleDownOutline_default = AngleDownOutline;
mark_module_end(AngleDownOutline);

// node_modules/flowbite-svelte-icons/dist/AngleLeftOutline.svelte
mark_module_start();
AngleLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AngleLeftOutline.svelte";
var root_114 = add_locations(ns_template(`<title> </title>`), AngleLeftOutline[FILENAME], [[41, 4]]);
var root_214 = add_locations(ns_template(`<desc> </desc>`), AngleLeftOutline[FILENAME], [[44, 4]]);
var root14 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m15 19-7-7 7-7"></path></svg>`), AngleLeftOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AngleLeftOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AngleLeftOutline);
  validate_prop_bindings($$props, [], [], AngleLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "angle left outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root14();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_114();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_214();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AngleLeftOutline = hmr(AngleLeftOutline, () => AngleLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AngleLeftOutline[HMR].source;
    set(AngleLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var AngleLeftOutline_default = AngleLeftOutline;
mark_module_end(AngleLeftOutline);

// node_modules/flowbite-svelte-icons/dist/AngleRightOutline.svelte
mark_module_start();
AngleRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AngleRightOutline.svelte";
var root_115 = add_locations(ns_template(`<title> </title>`), AngleRightOutline[FILENAME], [[41, 4]]);
var root_215 = add_locations(ns_template(`<desc> </desc>`), AngleRightOutline[FILENAME], [[44, 4]]);
var root15 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m9 5 7 7-7 7"></path></svg>`), AngleRightOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AngleRightOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AngleRightOutline);
  validate_prop_bindings($$props, [], [], AngleRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "angle right outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root15();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_115();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_215();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AngleRightOutline = hmr(AngleRightOutline, () => AngleRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AngleRightOutline[HMR].source;
    set(AngleRightOutline[HMR].source, module.default[HMR].original);
  });
}
var AngleRightOutline_default = AngleRightOutline;
mark_module_end(AngleRightOutline);

// node_modules/flowbite-svelte-icons/dist/AngleUpOutline.svelte
mark_module_start();
AngleUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AngleUpOutline.svelte";
var root_116 = add_locations(ns_template(`<title> </title>`), AngleUpOutline[FILENAME], [[41, 4]]);
var root_216 = add_locations(ns_template(`<desc> </desc>`), AngleUpOutline[FILENAME], [[44, 4]]);
var root16 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m5 15 7-7 7 7"></path></svg>`), AngleUpOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AngleUpOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AngleUpOutline);
  validate_prop_bindings($$props, [], [], AngleUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "angle up outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root16();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_116();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_216();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AngleUpOutline = hmr(AngleUpOutline, () => AngleUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AngleUpOutline[HMR].source;
    set(AngleUpOutline[HMR].source, module.default[HMR].original);
  });
}
var AngleUpOutline_default = AngleUpOutline;
mark_module_end(AngleUpOutline);

// node_modules/flowbite-svelte-icons/dist/AnnotationOutline.svelte
mark_module_start();
AnnotationOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AnnotationOutline.svelte";
var root_117 = add_locations(ns_template(`<title> </title>`), AnnotationOutline[FILENAME], [[41, 4]]);
var root_217 = add_locations(ns_template(`<desc> </desc>`), AnnotationOutline[FILENAME], [[44, 4]]);
var root17 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.556 8.5h8m-8 3.5H12m7.111-7H4.89a.896.896 0 0 0-.629.256.868.868 0 0 0-.26.619v9.25c0 .232.094.455.26.619A.896.896 0 0 0 4.89 16H9l3 4 3-4h4.111a.896.896 0 0 0 .629-.256.868.868 0 0 0 .26-.619v-9.25a.868.868 0 0 0-.26-.619.896.896 0 0 0-.63-.256Z"></path></svg>`), AnnotationOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AnnotationOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AnnotationOutline);
  validate_prop_bindings($$props, [], [], AnnotationOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "annotation outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root17();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_117();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_217();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AnnotationOutline = hmr(AnnotationOutline, () => AnnotationOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnnotationOutline[HMR].source;
    set(AnnotationOutline[HMR].source, module.default[HMR].original);
  });
}
var AnnotationOutline_default = AnnotationOutline;
mark_module_end(AnnotationOutline);

// node_modules/flowbite-svelte-icons/dist/AnnotationSolid.svelte
mark_module_start();
AnnotationSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AnnotationSolid.svelte";
var root_118 = add_locations(ns_template(`<title> </title>`), AnnotationSolid[FILENAME], [[39, 4]]);
var root_218 = add_locations(ns_template(`<desc> </desc>`), AnnotationSolid[FILENAME], [[42, 4]]);
var root18 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M3.559 4.544c.355-.35.834-.544 1.33-.544H19.11c.496 0 .975.194 1.33.544.356.35.559.829.559 1.331v9.25c0 .502-.203.981-.559 1.331-.355.35-.834.544-1.33.544H15.5l-2.7 3.6a1 1 0 0 1-1.6 0L8.5 17H4.889c-.496 0-.975-.194-1.33-.544A1.868 1.868 0 0 1 3 15.125v-9.25c0-.502.203-.981.559-1.331ZM7.556 7.5a1 1 0 1 0 0 2h8a1 1 0 0 0 0-2h-8Zm0 3.5a1 1 0 1 0 0 2H12a1 1 0 1 0 0-2H7.556Z" clip-rule="evenodd"></path></svg>`), AnnotationSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function AnnotationSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AnnotationSolid);
  validate_prop_bindings($$props, [], [], AnnotationSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "annotation solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root18();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_118();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_218();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AnnotationSolid = hmr(AnnotationSolid, () => AnnotationSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AnnotationSolid[HMR].source;
    set(AnnotationSolid[HMR].source, module.default[HMR].original);
  });
}
var AnnotationSolid_default = AnnotationSolid;
mark_module_end(AnnotationSolid);

// node_modules/flowbite-svelte-icons/dist/ApiKeyOutline.svelte
mark_module_start();
ApiKeyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ApiKeyOutline.svelte";
var root_119 = add_locations(ns_template(`<title> </title>`), ApiKeyOutline[FILENAME], [[41, 4]]);
var root_219 = add_locations(ns_template(`<desc> </desc>`), ApiKeyOutline[FILENAME], [[44, 4]]);
var root19 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M6.94318 11h-.85227l.96023-2.90909h1.07954L9.09091 11h-.85227l-.63637-2.10795h-.02272L6.94318 11Zm-.15909-1.14773h1.60227v.59093H6.78409v-.59093ZM9.37109 11V8.09091h1.25571c.2159 0 .4048.04261.5667.12784.162.08523.2879.20502.3779.35937.0899.15436.1349.33476.1349.5412 0 .20833-.0464.38873-.1392.54119-.0918.15246-.2211.26989-.3878.35229-.1657.0824-.3593.1236-.5809.1236h-.75003v-.61367h.59093c.0928 0 .1719-.0161.2372-.0483.0663-.03314.1169-.08002.152-.14062.036-.06061.054-.13211.054-.21449 0-.08334-.018-.15436-.054-.21307-.0351-.05966-.0857-.10511-.152-.13636-.0653-.0322-.1444-.0483-.2372-.0483h-.2784V11h-.78981Zm3.41481-2.90909V11h-.7898V8.09091h.7898Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M8.31818 2c-.55228 0-1 .44772-1 1v.72878c-.06079.0236-.12113.04809-.18098.07346l-.55228-.53789c-.38828-.37817-1.00715-.37817-1.39543 0L3.30923 5.09564c-.19327.18824-.30229.44659-.30229.71638 0 .26979.10902.52813.30229.71637l.52844.51468c-.01982.04526-.03911.0908-.05785.13662H3c-.55228 0-1 .44771-1 1v2.58981c0 .5523.44772 1 1 1h.77982c.01873.0458.03802.0914.05783.1366l-.52847.5147c-.19327.1883-.30228.4466-.30228.7164 0 .2698.10901.5281.30228.7164l1.88026 1.8313c.38828.3781 1.00715.3781 1.39544 0l.55228-.5379c.05987.0253.12021.0498.18102.0734v.7288c0 .5523.44772 1 1 1h2.65912c.5523 0 1-.4477 1-1v-.7288c.1316-.0511.2612-.1064.3883-.1657l.5435.2614v.4339c0 .5523.4477 1 1 1H14v.0625c0 .5523.4477 1 1 1h.0909v.0625c0 .5523.4477 1 1 1h.6844l.4952.4823c1.1648 1.1345 3.0214 1.1345 4.1863 0l.2409-.2347c.1961-.191.3053-.454.3022-.7277-.0031-.2737-.1183-.5342-.3187-.7207l-6.2162-5.7847c.0173-.0398.0342-.0798.0506-.12h.7799c.5522 0 1-.4477 1-1V8.17969c0-.55229-.4478-1-1-1h-.7799c-.0187-.04583-.038-.09139-.0578-.13666l.5284-.51464c.1933-.18824.3023-.44659.3023-.71638 0-.26979-.109-.52813-.3023-.71637l-1.8803-1.8313c-.3883-.37816-1.0071-.37816-1.3954 0l-.5523.53788c-.0598-.02536-.1201-.04985-.1809-.07344V3c0-.55228-.4477-1-1-1H8.31818Z"></path></svg>`), ApiKeyOutline[FILENAME], [
  [30, 0, [[46, 2], [50, 2]]]
]);
function ApiKeyOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ApiKeyOutline);
  validate_prop_bindings($$props, [], [], ApiKeyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "api key outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root19();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_119();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_219();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1, 2);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ApiKeyOutline = hmr(ApiKeyOutline, () => ApiKeyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ApiKeyOutline[HMR].source;
    set(ApiKeyOutline[HMR].source, module.default[HMR].original);
  });
}
var ApiKeyOutline_default = ApiKeyOutline;
mark_module_end(ApiKeyOutline);

// node_modules/flowbite-svelte-icons/dist/AppleSolid.svelte
mark_module_start();
AppleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AppleSolid.svelte";
var root_120 = add_locations(ns_template(`<title> </title>`), AppleSolid[FILENAME], [[39, 4]]);
var root_220 = add_locations(ns_template(`<desc> </desc>`), AppleSolid[FILENAME], [[42, 4]]);
var root20 = add_locations(ns_template(`<svg><!><!><path d="M17.537 12.625a4.421 4.421 0 0 0 2.684 4.047 10.96 10.96 0 0 1-1.384 2.845c-.834 1.218-1.7 2.432-3.062 2.457-1.34.025-1.77-.794-3.3-.794-1.531 0-2.01.769-3.275.82-1.316.049-2.317-1.318-3.158-2.532-1.72-2.484-3.032-7.017-1.27-10.077A4.9 4.9 0 0 1 8.91 6.884c1.292-.025 2.51.869 3.3.869.789 0 2.27-1.075 3.828-.917a4.67 4.67 0 0 1 3.66 1.984 4.524 4.524 0 0 0-2.16 3.805m-2.52-7.432A4.4 4.4 0 0 0 16.06 2a4.482 4.482 0 0 0-2.945 1.516 4.185 4.185 0 0 0-1.061 3.093 3.708 3.708 0 0 0 2.967-1.416Z"></path></svg>`), AppleSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function AppleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AppleSolid);
  validate_prop_bindings($$props, [], [], AppleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "apple solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root20();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_120();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_220();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AppleSolid = hmr(AppleSolid, () => AppleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AppleSolid[HMR].source;
    set(AppleSolid[HMR].source, module.default[HMR].original);
  });
}
var AppleSolid_default = AppleSolid;
mark_module_end(AppleSolid);

// node_modules/flowbite-svelte-icons/dist/ArchiveArrowDownOutline.svelte
mark_module_start();
ArchiveArrowDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArchiveArrowDownOutline.svelte";
var root_121 = add_locations(ns_template(`<title> </title>`), ArchiveArrowDownOutline[FILENAME], [[41, 4]]);
var root_221 = add_locations(ns_template(`<desc> </desc>`), ArchiveArrowDownOutline[FILENAME], [[44, 4]]);
var root21 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 11v5m0 0 2-2m-2 2-2-2M3 6v1a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1Zm2 2v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V8H5Z"></path></svg>`), ArchiveArrowDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArchiveArrowDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArchiveArrowDownOutline);
  validate_prop_bindings($$props, [], [], ArchiveArrowDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "archive arrow down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root21();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_121();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_221();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArchiveArrowDownOutline = hmr(ArchiveArrowDownOutline, () => ArchiveArrowDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArchiveArrowDownOutline[HMR].source;
    set(ArchiveArrowDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ArchiveArrowDownOutline_default = ArchiveArrowDownOutline;
mark_module_end(ArchiveArrowDownOutline);

// node_modules/flowbite-svelte-icons/dist/ArchiveArrowDownSolid.svelte
mark_module_start();
ArchiveArrowDownSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArchiveArrowDownSolid.svelte";
var root_122 = add_locations(ns_template(`<title> </title>`), ArchiveArrowDownSolid[FILENAME], [[39, 4]]);
var root_222 = add_locations(ns_template(`<desc> </desc>`), ArchiveArrowDownSolid[FILENAME], [[42, 4]]);
var root22 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 1 0 0 4h16a2 2 0 1 0 0-4H4Zm0 6h16v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-8Zm10.707 5.707a1 1 0 0 0-1.414-1.414l-.293.293V12a1 1 0 1 0-2 0v2.586l-.293-.293a1 1 0 0 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l2-2Z" clip-rule="evenodd"></path></svg>`), ArchiveArrowDownSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ArchiveArrowDownSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArchiveArrowDownSolid);
  validate_prop_bindings($$props, [], [], ArchiveArrowDownSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "archive arrow down solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root22();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_122();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_222();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArchiveArrowDownSolid = hmr(ArchiveArrowDownSolid, () => ArchiveArrowDownSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArchiveArrowDownSolid[HMR].source;
    set(ArchiveArrowDownSolid[HMR].source, module.default[HMR].original);
  });
}
var ArchiveArrowDownSolid_default = ArchiveArrowDownSolid;
mark_module_end(ArchiveArrowDownSolid);

// node_modules/flowbite-svelte-icons/dist/ArchiveOutline.svelte
mark_module_start();
ArchiveOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArchiveOutline.svelte";
var root_123 = add_locations(ns_template(`<title> </title>`), ArchiveOutline[FILENAME], [[41, 4]]);
var root_223 = add_locations(ns_template(`<desc> </desc>`), ArchiveOutline[FILENAME], [[44, 4]]);
var root23 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M10 12v1h4v-1m4 7H6a1 1 0 0 1-1-1V9h14v9a1 1 0 0 1-1 1ZM4 5h16a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), ArchiveOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArchiveOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArchiveOutline);
  validate_prop_bindings($$props, [], [], ArchiveOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "archive outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root23();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_123();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_223();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArchiveOutline = hmr(ArchiveOutline, () => ArchiveOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArchiveOutline[HMR].source;
    set(ArchiveOutline[HMR].source, module.default[HMR].original);
  });
}
var ArchiveOutline_default = ArchiveOutline;
mark_module_end(ArchiveOutline);

// node_modules/flowbite-svelte-icons/dist/ArchiveSolid.svelte
mark_module_start();
ArchiveSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArchiveSolid.svelte";
var root_124 = add_locations(ns_template(`<title> </title>`), ArchiveSolid[FILENAME], [[39, 4]]);
var root_224 = add_locations(ns_template(`<desc> </desc>`), ArchiveSolid[FILENAME], [[42, 4]]);
var root24 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M20 10H4v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8ZM9 13v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path><path d="M2 6a2 2 0 0 1 2-2h16a2 2 0 1 1 0 4H4a2 2 0 0 1-2-2Z"></path></svg>`), ArchiveSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 5]]]
]);
function ArchiveSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArchiveSolid);
  validate_prop_bindings($$props, [], [], ArchiveSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "archive solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root24();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_124();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_224();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArchiveSolid = hmr(ArchiveSolid, () => ArchiveSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArchiveSolid[HMR].source;
    set(ArchiveSolid[HMR].source, module.default[HMR].original);
  });
}
var ArchiveSolid_default = ArchiveSolid;
mark_module_end(ArchiveSolid);

// node_modules/flowbite-svelte-icons/dist/ArrowDownOutline.svelte
mark_module_start();
ArrowDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowDownOutline.svelte";
var root_125 = add_locations(ns_template(`<title> </title>`), ArrowDownOutline[FILENAME], [[41, 4]]);
var root_225 = add_locations(ns_template(`<desc> </desc>`), ArrowDownOutline[FILENAME], [[44, 4]]);
var root25 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 19V5m0 14-4-4m4 4 4-4"></path></svg>`), ArrowDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowDownOutline);
  validate_prop_bindings($$props, [], [], ArrowDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root25();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_125();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_225();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowDownOutline = hmr(ArrowDownOutline, () => ArrowDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowDownOutline[HMR].source;
    set(ArrowDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowDownOutline_default = ArrowDownOutline;
mark_module_end(ArrowDownOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowDownToBracketOutline.svelte
mark_module_start();
ArrowDownToBracketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowDownToBracketOutline.svelte";
var root_126 = add_locations(ns_template(`<title> </title>`), ArrowDownToBracketOutline[FILENAME], [[41, 4]]);
var root_226 = add_locations(ns_template(`<desc> </desc>`), ArrowDownToBracketOutline[FILENAME], [[44, 4]]);
var root26 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 15v2a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-2m-8 1V4m0 12-4-4m4 4 4-4"></path></svg>`), ArrowDownToBracketOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowDownToBracketOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowDownToBracketOutline);
  validate_prop_bindings($$props, [], [], ArrowDownToBracketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow down to bracket outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root26();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_126();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_226();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowDownToBracketOutline = hmr(ArrowDownToBracketOutline, () => ArrowDownToBracketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowDownToBracketOutline[HMR].source;
    set(ArrowDownToBracketOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowDownToBracketOutline_default = ArrowDownToBracketOutline;
mark_module_end(ArrowDownToBracketOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowLeftOutline.svelte
mark_module_start();
ArrowLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowLeftOutline.svelte";
var root_127 = add_locations(ns_template(`<title> </title>`), ArrowLeftOutline[FILENAME], [[41, 4]]);
var root_227 = add_locations(ns_template(`<desc> </desc>`), ArrowLeftOutline[FILENAME], [[44, 4]]);
var root27 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12h14M5 12l4-4m-4 4 4 4"></path></svg>`), ArrowLeftOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowLeftOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowLeftOutline);
  validate_prop_bindings($$props, [], [], ArrowLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow left outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root27();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_127();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_227();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowLeftOutline = hmr(ArrowLeftOutline, () => ArrowLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowLeftOutline[HMR].source;
    set(ArrowLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowLeftOutline_default = ArrowLeftOutline;
mark_module_end(ArrowLeftOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowLeftToBracketOutline.svelte
mark_module_start();
ArrowLeftToBracketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowLeftToBracketOutline.svelte";
var root_128 = add_locations(ns_template(`<title> </title>`), ArrowLeftToBracketOutline[FILENAME], [[41, 4]]);
var root_228 = add_locations(ns_template(`<desc> </desc>`), ArrowLeftToBracketOutline[FILENAME], [[44, 4]]);
var root28 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 12H4m12 0-4 4m4-4-4-4m3-4h2a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-2"></path></svg>`), ArrowLeftToBracketOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowLeftToBracketOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowLeftToBracketOutline);
  validate_prop_bindings($$props, [], [], ArrowLeftToBracketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow left to bracket outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root28();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_128();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_228();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowLeftToBracketOutline = hmr(ArrowLeftToBracketOutline, () => ArrowLeftToBracketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowLeftToBracketOutline[HMR].source;
    set(ArrowLeftToBracketOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowLeftToBracketOutline_default = ArrowLeftToBracketOutline;
mark_module_end(ArrowLeftToBracketOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowRightAltOutline.svelte
mark_module_start();
ArrowRightAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowRightAltOutline.svelte";
var root_129 = add_locations(ns_template(`<title> </title>`), ArrowRightAltOutline[FILENAME], [[41, 4]]);
var root_229 = add_locations(ns_template(`<desc> </desc>`), ArrowRightAltOutline[FILENAME], [[44, 4]]);
var root29 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16.153 19 21 12l-4.847-7H3l4.848 7L3 19h13.153Z"></path></svg>`), ArrowRightAltOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowRightAltOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowRightAltOutline);
  validate_prop_bindings($$props, [], [], ArrowRightAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow right alt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root29();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_129();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_229();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowRightAltOutline = hmr(ArrowRightAltOutline, () => ArrowRightAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowRightAltOutline[HMR].source;
    set(ArrowRightAltOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowRightAltOutline_default = ArrowRightAltOutline;
mark_module_end(ArrowRightAltOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowRightAltSolid.svelte
mark_module_start();
ArrowRightAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowRightAltSolid.svelte";
var root_130 = add_locations(ns_template(`<title> </title>`), ArrowRightAltSolid[FILENAME], [[39, 4]]);
var root_230 = add_locations(ns_template(`<desc> </desc>`), ArrowRightAltSolid[FILENAME], [[42, 4]]);
var root30 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M3 4a1 1 0 0 0-.822 1.57L6.632 12l-4.454 6.43A1 1 0 0 0 3 20h13.153a1 1 0 0 0 .822-.43l4.847-7a1 1 0 0 0 0-1.14l-4.847-7a1 1 0 0 0-.822-.43H3Z" clip-rule="evenodd"></path></svg>`), ArrowRightAltSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ArrowRightAltSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowRightAltSolid);
  validate_prop_bindings($$props, [], [], ArrowRightAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow right alt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root30();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_130();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_230();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowRightAltSolid = hmr(ArrowRightAltSolid, () => ArrowRightAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowRightAltSolid[HMR].source;
    set(ArrowRightAltSolid[HMR].source, module.default[HMR].original);
  });
}
var ArrowRightAltSolid_default = ArrowRightAltSolid;
mark_module_end(ArrowRightAltSolid);

// node_modules/flowbite-svelte-icons/dist/ArrowRightOutline.svelte
mark_module_start();
ArrowRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowRightOutline.svelte";
var root_131 = add_locations(ns_template(`<title> </title>`), ArrowRightOutline[FILENAME], [[41, 4]]);
var root_231 = add_locations(ns_template(`<desc> </desc>`), ArrowRightOutline[FILENAME], [[44, 4]]);
var root31 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 12H5m14 0-4 4m4-4-4-4"></path></svg>`), ArrowRightOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowRightOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowRightOutline);
  validate_prop_bindings($$props, [], [], ArrowRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow right outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root31();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_131();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_231();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowRightOutline = hmr(ArrowRightOutline, () => ArrowRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowRightOutline[HMR].source;
    set(ArrowRightOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowRightOutline_default = ArrowRightOutline;
mark_module_end(ArrowRightOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowRightToBracketOutline.svelte
mark_module_start();
ArrowRightToBracketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowRightToBracketOutline.svelte";
var root_132 = add_locations(ns_template(`<title> </title>`), ArrowRightToBracketOutline[FILENAME], [[41, 4]]);
var root_232 = add_locations(ns_template(`<desc> </desc>`), ArrowRightToBracketOutline[FILENAME], [[44, 4]]);
var root32 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20 12H8m12 0-4 4m4-4-4-4M9 4H7a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h2"></path></svg>`), ArrowRightToBracketOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowRightToBracketOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowRightToBracketOutline);
  validate_prop_bindings($$props, [], [], ArrowRightToBracketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow right to bracket outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root32();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_132();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_232();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowRightToBracketOutline = hmr(ArrowRightToBracketOutline, () => ArrowRightToBracketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowRightToBracketOutline[HMR].source;
    set(ArrowRightToBracketOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowRightToBracketOutline_default = ArrowRightToBracketOutline;
mark_module_end(ArrowRightToBracketOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowSortLettersOutline.svelte
mark_module_start();
ArrowSortLettersOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowSortLettersOutline.svelte";
var root_133 = add_locations(ns_template(`<title> </title>`), ArrowSortLettersOutline[FILENAME], [[41, 4]]);
var root_233 = add_locations(ns_template(`<desc> </desc>`), ArrowSortLettersOutline[FILENAME], [[44, 4]]);
var root33 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 4v16M7 4l3 3M7 4 4 7m9-3h6l-6 6h6m-6.5 10 3.5-7 3.5 7M14 18h4"></path></svg>`), ArrowSortLettersOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowSortLettersOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowSortLettersOutline);
  validate_prop_bindings($$props, [], [], ArrowSortLettersOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow sort letters outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root33();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_133();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_233();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowSortLettersOutline = hmr(ArrowSortLettersOutline, () => ArrowSortLettersOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowSortLettersOutline[HMR].source;
    set(ArrowSortLettersOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowSortLettersOutline_default = ArrowSortLettersOutline;
mark_module_end(ArrowSortLettersOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowUpDownOutline.svelte
mark_module_start();
ArrowUpDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpDownOutline.svelte";
var root_134 = add_locations(ns_template(`<title> </title>`), ArrowUpDownOutline[FILENAME], [[41, 4]]);
var root_234 = add_locations(ns_template(`<desc> </desc>`), ArrowUpDownOutline[FILENAME], [[44, 4]]);
var root34 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 20V7m0 13-4-4m4 4 4-4m4-12v13m0-13 4 4m-4-4-4 4"></path></svg>`), ArrowUpDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowUpDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowUpDownOutline);
  validate_prop_bindings($$props, [], [], ArrowUpDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow up down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root34();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_134();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_234();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowUpDownOutline = hmr(ArrowUpDownOutline, () => ArrowUpDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpDownOutline[HMR].source;
    set(ArrowUpDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpDownOutline_default = ArrowUpDownOutline;
mark_module_end(ArrowUpDownOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowUpFromBracketOutline.svelte
mark_module_start();
ArrowUpFromBracketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpFromBracketOutline.svelte";
var root_135 = add_locations(ns_template(`<title> </title>`), ArrowUpFromBracketOutline[FILENAME], [[41, 4]]);
var root_235 = add_locations(ns_template(`<desc> </desc>`), ArrowUpFromBracketOutline[FILENAME], [[44, 4]]);
var root35 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 15v2a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3v-2M12 4v12m0-12 4 4m-4-4L8 8"></path></svg>`), ArrowUpFromBracketOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowUpFromBracketOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowUpFromBracketOutline);
  validate_prop_bindings($$props, [], [], ArrowUpFromBracketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow up from bracket outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root35();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_135();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_235();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowUpFromBracketOutline = hmr(ArrowUpFromBracketOutline, () => ArrowUpFromBracketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpFromBracketOutline[HMR].source;
    set(ArrowUpFromBracketOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpFromBracketOutline_default = ArrowUpFromBracketOutline;
mark_module_end(ArrowUpFromBracketOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowUpOutline.svelte
mark_module_start();
ArrowUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpOutline.svelte";
var root_136 = add_locations(ns_template(`<title> </title>`), ArrowUpOutline[FILENAME], [[41, 4]]);
var root_236 = add_locations(ns_template(`<desc> </desc>`), ArrowUpOutline[FILENAME], [[44, 4]]);
var root36 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 6v13m0-13 4 4m-4-4-4 4"></path></svg>`), ArrowUpOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowUpOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowUpOutline);
  validate_prop_bindings($$props, [], [], ArrowUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow up outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root36();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_136();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_236();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowUpOutline = hmr(ArrowUpOutline, () => ArrowUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpOutline[HMR].source;
    set(ArrowUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpOutline_default = ArrowUpOutline;
mark_module_end(ArrowUpOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowUpRightDownLeftOutline.svelte
mark_module_start();
ArrowUpRightDownLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpRightDownLeftOutline.svelte";
var root_137 = add_locations(ns_template(`<title> </title>`), ArrowUpRightDownLeftOutline[FILENAME], [[41, 4]]);
var root_237 = add_locations(ns_template(`<desc> </desc>`), ArrowUpRightDownLeftOutline[FILENAME], [[44, 4]]);
var root37 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 4h4m0 0v4m0-4-5 5M8 20H4m0 0v-4m0 4 5-5"></path></svg>`), ArrowUpRightDownLeftOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowUpRightDownLeftOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowUpRightDownLeftOutline);
  validate_prop_bindings($$props, [], [], ArrowUpRightDownLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow up right down left outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root37();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_137();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_237();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowUpRightDownLeftOutline = hmr(ArrowUpRightDownLeftOutline, () => ArrowUpRightDownLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpRightDownLeftOutline[HMR].source;
    set(ArrowUpRightDownLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpRightDownLeftOutline_default = ArrowUpRightDownLeftOutline;
mark_module_end(ArrowUpRightDownLeftOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowUpRightFromSquareOutline.svelte
mark_module_start();
ArrowUpRightFromSquareOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpRightFromSquareOutline.svelte";
var root_138 = add_locations(ns_template(`<title> </title>`), ArrowUpRightFromSquareOutline[FILENAME], [[41, 4]]);
var root_238 = add_locations(ns_template(`<desc> </desc>`), ArrowUpRightFromSquareOutline[FILENAME], [[44, 4]]);
var root38 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 14v4.833A1.166 1.166 0 0 1 16.833 20H5.167A1.167 1.167 0 0 1 4 18.833V7.167A1.166 1.166 0 0 1 5.167 6h4.618m4.447-2H20v5.768m-7.889 2.121 7.778-7.778"></path></svg>`), ArrowUpRightFromSquareOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowUpRightFromSquareOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowUpRightFromSquareOutline);
  validate_prop_bindings($$props, [], [], ArrowUpRightFromSquareOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow up right from square outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root38();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_138();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_238();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowUpRightFromSquareOutline = hmr(ArrowUpRightFromSquareOutline, () => ArrowUpRightFromSquareOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpRightFromSquareOutline[HMR].source;
    set(ArrowUpRightFromSquareOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpRightFromSquareOutline_default = ArrowUpRightFromSquareOutline;
mark_module_end(ArrowUpRightFromSquareOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowUpRightFromSquareSolid.svelte
mark_module_start();
ArrowUpRightFromSquareSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowUpRightFromSquareSolid.svelte";
var root_139 = add_locations(ns_template(`<title> </title>`), ArrowUpRightFromSquareSolid[FILENAME], [[39, 4]]);
var root_239 = add_locations(ns_template(`<desc> </desc>`), ArrowUpRightFromSquareSolid[FILENAME], [[42, 4]]);
var root39 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M11.403 5H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-6.403a3.01 3.01 0 0 1-1.743-1.612l-3.025 3.025A3 3 0 1 1 9.99 9.768l3.025-3.025A3.01 3.01 0 0 1 11.403 5Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M13.232 4a1 1 0 0 1 1-1H20a1 1 0 0 1 1 1v5.768a1 1 0 1 1-2 0V6.414l-6.182 6.182a1 1 0 0 1-1.414-1.414L17.586 5h-3.354a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), ArrowUpRightFromSquareSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function ArrowUpRightFromSquareSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowUpRightFromSquareSolid);
  validate_prop_bindings($$props, [], [], ArrowUpRightFromSquareSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "arrow up right from square solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root39();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_139();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_239();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowUpRightFromSquareSolid = hmr(ArrowUpRightFromSquareSolid, () => ArrowUpRightFromSquareSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowUpRightFromSquareSolid[HMR].source;
    set(ArrowUpRightFromSquareSolid[HMR].source, module.default[HMR].original);
  });
}
var ArrowUpRightFromSquareSolid_default = ArrowUpRightFromSquareSolid;
mark_module_end(ArrowUpRightFromSquareSolid);

// node_modules/flowbite-svelte-icons/dist/ArrowsRepeatCountOutline.svelte
mark_module_start();
ArrowsRepeatCountOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowsRepeatCountOutline.svelte";
var root_140 = add_locations(ns_template(`<title> </title>`), ArrowsRepeatCountOutline[FILENAME], [[41, 4]]);
var root_240 = add_locations(ns_template(`<desc> </desc>`), ArrowsRepeatCountOutline[FILENAME], [[44, 4]]);
var root40 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m16 4 3 3H5v3m3 10-3-3h14v-3m-9-2.5 2-1.5v4"></path></svg>`), ArrowsRepeatCountOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowsRepeatCountOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowsRepeatCountOutline);
  validate_prop_bindings($$props, [], [], ArrowsRepeatCountOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrows repeat count outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root40();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_140();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_240();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowsRepeatCountOutline = hmr(ArrowsRepeatCountOutline, () => ArrowsRepeatCountOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowsRepeatCountOutline[HMR].source;
    set(ArrowsRepeatCountOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowsRepeatCountOutline_default = ArrowsRepeatCountOutline;
mark_module_end(ArrowsRepeatCountOutline);

// node_modules/flowbite-svelte-icons/dist/ArrowsRepeatOutline.svelte
mark_module_start();
ArrowsRepeatOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ArrowsRepeatOutline.svelte";
var root_141 = add_locations(ns_template(`<title> </title>`), ArrowsRepeatOutline[FILENAME], [[41, 4]]);
var root_241 = add_locations(ns_template(`<desc> </desc>`), ArrowsRepeatOutline[FILENAME], [[44, 4]]);
var root41 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m16 10 3-3m0 0-3-3m3 3H5v3m3 4-3 3m0 0 3 3m-3-3h14v-3"></path></svg>`), ArrowsRepeatOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ArrowsRepeatOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ArrowsRepeatOutline);
  validate_prop_bindings($$props, [], [], ArrowsRepeatOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "arrows repeat outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root41();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_141();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_241();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ArrowsRepeatOutline = hmr(ArrowsRepeatOutline, () => ArrowsRepeatOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ArrowsRepeatOutline[HMR].source;
    set(ArrowsRepeatOutline[HMR].source, module.default[HMR].original);
  });
}
var ArrowsRepeatOutline_default = ArrowsRepeatOutline;
mark_module_end(ArrowsRepeatOutline);

// node_modules/flowbite-svelte-icons/dist/AtomOutline.svelte
mark_module_start();
AtomOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AtomOutline.svelte";
var root_142 = add_locations(ns_template(`<title> </title>`), AtomOutline[FILENAME], [[41, 4]]);
var root_242 = add_locations(ns_template(`<desc> </desc>`), AtomOutline[FILENAME], [[44, 4]]);
var root42 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M8.737 8.737a21.49 21.49 0 0 1 3.308-2.724m0 0c3.063-2.026 5.99-2.641 7.331-1.3 1.827 1.828.026 6.591-4.023 10.64-4.049 4.049-8.812 5.85-10.64 4.023-1.33-1.33-.736-4.218 1.249-7.253m6.083-6.11c-3.063-2.026-5.99-2.641-7.331-1.3-1.827 1.828-.026 6.591 4.023 10.64m3.308-9.34a21.497 21.497 0 0 1 3.308 2.724m2.775 3.386c1.985 3.035 2.579 5.923 1.248 7.253-1.336 1.337-4.245.732-7.295-1.275M14 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg>`), AtomOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AtomOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AtomOutline);
  validate_prop_bindings($$props, [], [], AtomOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "atom outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root42();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_142();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_242();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AtomOutline = hmr(AtomOutline, () => AtomOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AtomOutline[HMR].source;
    set(AtomOutline[HMR].source, module.default[HMR].original);
  });
}
var AtomOutline_default = AtomOutline;
mark_module_end(AtomOutline);

// node_modules/flowbite-svelte-icons/dist/AwardOutline.svelte
mark_module_start();
AwardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AwardOutline.svelte";
var root_143 = add_locations(ns_template(`<title> </title>`), AwardOutline[FILENAME], [[41, 4]]);
var root_243 = add_locations(ns_template(`<desc> </desc>`), AwardOutline[FILENAME], [[44, 4]]);
var root43 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m7.171 12.906-2.153 6.411 2.672-.89 1.568 2.34 1.825-5.183m5.73-2.678 2.154 6.411-2.673-.89-1.568 2.34-1.825-5.183M9.165 4.3c.58.068 1.153-.17 1.515-.628a1.681 1.681 0 0 1 2.64 0 1.68 1.68 0 0 0 1.515.628 1.681 1.681 0 0 1 1.866 1.866c-.068.58.17 1.154.628 1.516a1.681 1.681 0 0 1 0 2.639 1.682 1.682 0 0 0-.628 1.515 1.681 1.681 0 0 1-1.866 1.866 1.681 1.681 0 0 0-1.516.628 1.681 1.681 0 0 1-2.639 0 1.681 1.681 0 0 0-1.515-.628 1.681 1.681 0 0 1-1.867-1.866 1.681 1.681 0 0 0-.627-1.515 1.681 1.681 0 0 1 0-2.64c.458-.361.696-.935.627-1.515A1.681 1.681 0 0 1 9.165 4.3ZM14 9a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg>`), AwardOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function AwardOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AwardOutline);
  validate_prop_bindings($$props, [], [], AwardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "award outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root43();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_143();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_243();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AwardOutline = hmr(AwardOutline, () => AwardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AwardOutline[HMR].source;
    set(AwardOutline[HMR].source, module.default[HMR].original);
  });
}
var AwardOutline_default = AwardOutline;
mark_module_end(AwardOutline);

// node_modules/flowbite-svelte-icons/dist/AwardSolid.svelte
mark_module_start();
AwardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AwardSolid.svelte";
var root_144 = add_locations(ns_template(`<title> </title>`), AwardSolid[FILENAME], [[39, 4]]);
var root_244 = add_locations(ns_template(`<desc> </desc>`), AwardSolid[FILENAME], [[42, 4]]);
var root44 = add_locations(ns_template(`<svg><!><!><path d="M11 9a1 1 0 1 1 2 0 1 1 0 0 1-2 0Z"></path><path fill-rule="evenodd" d="M9.896 3.051a2.681 2.681 0 0 1 4.208 0c.147.186.38.282.615.255a2.681 2.681 0 0 1 2.976 2.975.681.681 0 0 0 .254.615 2.681 2.681 0 0 1 0 4.208.682.682 0 0 0-.254.615 2.681 2.681 0 0 1-2.976 2.976.681.681 0 0 0-.615.254 2.682 2.682 0 0 1-4.208 0 .681.681 0 0 0-.614-.255 2.681 2.681 0 0 1-2.976-2.975.681.681 0 0 0-.255-.615 2.681 2.681 0 0 1 0-4.208.681.681 0 0 0 .255-.615 2.681 2.681 0 0 1 2.976-2.975.681.681 0 0 0 .614-.255ZM12 6a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z" clip-rule="evenodd"></path><path d="M5.395 15.055 4.07 19a1 1 0 0 0 1.264 1.267l1.95-.65 1.144 1.707A1 1 0 0 0 10.2 21.1l1.12-3.18a4.641 4.641 0 0 1-2.515-1.208 4.667 4.667 0 0 1-3.411-1.656Zm7.269 2.867 1.12 3.177a1 1 0 0 0 1.773.224l1.144-1.707 1.95.65A1 1 0 0 0 19.915 19l-1.32-3.93a4.667 4.667 0 0 1-3.4 1.642 4.643 4.643 0 0 1-2.53 1.21Z"></path></svg>`), AwardSolid[FILENAME], [
  [
    29,
    0,
    [[44, 2], [45, 2], [50, 2]]
  ]
]);
function AwardSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AwardSolid);
  validate_prop_bindings($$props, [], [], AwardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "award solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root44();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_144();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_244();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(3);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AwardSolid = hmr(AwardSolid, () => AwardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AwardSolid[HMR].source;
    set(AwardSolid[HMR].source, module.default[HMR].original);
  });
}
var AwardSolid_default = AwardSolid;
mark_module_end(AwardSolid);

// node_modules/flowbite-svelte-icons/dist/AwsSolid.svelte
mark_module_start();
AwsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/AwsSolid.svelte";
var root_145 = add_locations(ns_template(`<title> </title>`), AwsSolid[FILENAME], [[39, 4]]);
var root_245 = add_locations(ns_template(`<desc> </desc>`), AwsSolid[FILENAME], [[42, 4]]);
var root45 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M7.70858 10.176c-.0059.1918.02016.3833.07716.567.05635.1582.12675.3114.21041.4577.02989.0424.04691.0921.04909.1435-.00368.0394-.01708.0774-.03906.1107-.02198.0333-.05189.0609-.08718.0806l-.41382.2664c-.04921.0342-.10786.0533-.16833.0546-.03729-.0006-.07404-.0088-.10786-.0241-.03383-.0153-.06399-.0373-.08852-.0647-.09084-.0886-.17086-.1872-.23847-.2937-.06312-.1093-.12625-.2323-.19638-.3758-.23007.28-.52286.505-.85597.6577-.3331.1528-.69768.2293-1.0658.2236-.23782.0125-.47581-.0215-.69988-.1002-.22407-.0786-.42969-.2002-.60468-.3575-.16281-.1601-.28937-.3516-.37152-.5622s-.11806-.4357-.10542-.6607c-.0085-.2476.04-.49387.14195-.72084.10194-.22696.25475-.42883.44721-.59079.45708-.34704 1.02741-.5217 1.60615-.49187.23468-.00102.46912.01497.70137.04782.24549.03416.49097.08198.75048.13663V8.2153c.03746-.36552-.07329-.73083-.30861-1.0179-.30324-.22803-.68514-.33327-1.06609-.29376-.23624.00109-.47158.02859-.70138.08198-.23919.05528-.47367.12837-.70137.21861l-.23146.08198h-.09819c-.09819 0-.14027-.06832-.14027-.19812v-.31425c-.00622-.07522.00831-.15069.04208-.21861.05218-.0584.1168-.10503.18937-.13663.2626-.12306.53761-.21922.82061-.28693.33218-.08331.67398-.12464 1.01699-.12297.61832-.0525 1.23302.134 1.71136.5192.19644.21006.34589.45761.43886.72693.09297.26931.12744.55452.1012.83751L7.70858 10.176Zm-2.6512.9701c.23887.0003.47605-.039.70138-.1162.23999-.0798.45329-.2214.61721-.4099.10821-.114.18537-.2525.22444-.403.04532-.1811.06654-.36707.06312-.5534v-.28693c-.20607-.04171-.41451-.07136-.62422-.08881H5.4221c-.34289-.02679-.68477.06249-.9679.25277-.10942.08972-.19564.20325-.25168.33142-.05605.12815-.08036.26735-.07095.40635-.01155.1238.00371.2486.04479.3663.04108.1177.10706.2256.19367.3169.19501.1477.4422.214.68735.1845Zm5.25332.6831c-.0889.0081-.178-.0136-.2525-.0615-.07121-.069-.12-.1569-.14028-.2527l-1.529-4.91878c-.03108-.08355-.04997-.17094-.05611-.2596 0-.10247.04909-.15713.1543-.15713h.64527c.08889-.00805.17795.01364.25249.06149.06832.07011.11457.15783.13326.25277L10.6193 10.743l1.031-4.24242c.0108-.09596.0554-.1853.1263-.25277.0771-.04787.1684-.06949.2595-.06149h.526c.0933-.008.1868.01357.2665.06149.0658.07094.1096.15858.1263.25277l1.017 4.24242 1.1292-4.26292c.0187-.09493.0649-.18265.1332-.25277.0746-.04785.1636-.06953.2525-.06148h.6102c.0218-.00213.0437.00047.0643.00761.0205.00714.0392.01865.0547.03369.0154.01503.0272.03323.0345.05326.0074.02004.01.04141.0079.06257.0026.03411.0026.06836 0 .10247 0 0 0 .08881-.0421.15713l-1.5851 4.91874c-.0187.0949-.065.1826-.1333.2528-.0754.0459-.1638.0675-.2525.0614h-.5611c-.0922.0096-.1848-.0148-.2595-.0683-.0695-.0684-.1139-.1572-.1263-.2527l-1.0169-4.09899-1.01 4.09899c-.0124.0955-.0568.1843-.1263.2527-.0753.0524-.1674.0766-.2595.0683l-.5751.0137Zm8.4165.164c-.3399.0015-.6788-.0351-1.01-.1093-.2607-.051-.5131-.136-.7505-.2528-.0839-.039-.1545-.1006-.2034-.1776-.0272-.0579-.0415-.1208-.042-.1845v-.3211c0-.1298.0491-.1981.1473-.1981.0418-.0065.0844-.0065.1262 0l.1613.0683c.2248.0979.46.1712.7014.2186.2558.0543.5168.0818.7785.082.3323.0202.6634-.0534.9539-.2118.1055-.0624.1921-.1509.2512-.2565.0592-.1055.0886-.2244.0855-.3446.0033-.0818-.0106-.1633-.0407-.2397-.0302-.07633-.076-.14588-.1347-.20439-.1899-.16027-.4157-.27492-.6593-.33474l-.9468-.29376c-.4097-.1003-.7758-.32526-1.0451-.64217-.2118-.26596-.3277-.59251-.3296-.92909-.0039-.23873.0566-.47428.1753-.68316.1173-.2053.2774-.38447.4699-.52603.2109-.15082.4487-.26203.7014-.32792.2689-.07547.5478-.11229.8276-.1093.1448-.00996.2901-.00996.4349 0l.4278.06831.3717.10247.2736.10931c.0734.04221.1396.09522.1964.15713.0391.06392.0585.13741.0561.21178v.30058c0 .13664-.0491.20495-.1473.20495-.0891-.00994-.1751-.03786-.2525-.08198-.3981-.16851-.8285-.25236-1.2625-.24593-.3007-.01421-.6002.04695-.8697.17762-.1001.05934-.1817.14411-.236.24521-.0544.1011-.0795.21471-.0726.32864-.0003.08419.0169.16757.0507.24507.0337.07751.0833.14753.1457.20581.207.16139.4457.27994.7014.34842l.9258.28692c.3924.10142.7444.31568 1.01.61484.201.25675.3073.57207.3016.89491.0041.2554-.0535.5082-.1684.7378-.1126.22-.2758.4117-.4769.5602-.2081.163-.4461.2859-.7014.3621-.3061.0959-.6253.1465-.9468.1503l.021-.0068ZM1.95721 14.0043c.08851-.1117.25276-.1417.40291-.0501 2.956 1.6699 6.30435 2.5466 9.71118 2.5424 2.547-.0102 5.0667-.5176 7.4139-1.4927.2212-.0923.442-.0252.5504.1273.0544.0765.0784.1732.056.2731-.0223.0994-.088.1913-.1929.2664l-.0025.0018c-2.374 1.591-5.18 2.437-8.0499 2.4273-3.62804.0192-7.13297-1.2975-9.82873-3.6929.00006 0-.00007-.0001 0 0-.06599-.0585-.10575-.1289-.1154-.2033-.00962-.0742.01189-.1449.05504-.1993Z"></path><path fill="currentColor" d="M21.9852 13.2357c-.0506-.0587-.1329-.1058-.2258-.1441-.0959-.0396-.2151-.0746-.3508-.1035-.2719-.0579-.6185-.093-.9967-.0876-.7541.0108-1.6508.183-2.3341.6748-.1118.0805-.1949.1945-.1751.3147.0225.1362.1551.1917.2864.1917l.0241-.003c.375-.0465.9652-.1198 1.5-.134.2706-.0072.5225.0009.7232.0339.1003.0164.1845.0386.2506.0663.0667.028.1084.0591.1318.0896l.001.0013c.0211.0266.0396.072.0489.1434.0092.0704.0085.1579-.0018.2604-.0204.2049-.0773.456-.1527.723-.1173.4156-.2758.8577-.4014 1.2081-.0355.0991-.0684.1909-.097.2727-.0253.0645-.0344.13-.0204.1901.0147.063.0538.1145.1113.143.1108.0549.2469.0095.3548-.0833.6431-.5509 1.0488-1.3947 1.2591-2.1349.1055-.3712.1632-.7208.1764-1.0006.0065-.1398.0021-.2647-.0141-.3675-.0155-.099-.0442-.1922-.0977-.2545Z"></path></svg>`), AwsSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 2]]]
]);
function AwsSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, AwsSolid);
  validate_prop_bindings($$props, [], [], AwsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "aws solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root45();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_145();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_245();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AwsSolid = hmr(AwsSolid, () => AwsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AwsSolid[HMR].source;
    set(AwsSolid[HMR].source, module.default[HMR].original);
  });
}
var AwsSolid_default = AwsSolid;
mark_module_end(AwsSolid);

// node_modules/flowbite-svelte-icons/dist/BackwardStepOutline.svelte
mark_module_start();
BackwardStepOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BackwardStepOutline.svelte";
var root_146 = add_locations(ns_template(`<title> </title>`), BackwardStepOutline[FILENAME], [[41, 4]]);
var root_246 = add_locations(ns_template(`<desc> </desc>`), BackwardStepOutline[FILENAME], [[44, 4]]);
var root46 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 6v12m8-12v12l-8-6 8-6Z"></path></svg>`), BackwardStepOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BackwardStepOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BackwardStepOutline);
  validate_prop_bindings($$props, [], [], BackwardStepOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "backward step outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root46();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_146();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_246();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BackwardStepOutline = hmr(BackwardStepOutline, () => BackwardStepOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BackwardStepOutline[HMR].source;
    set(BackwardStepOutline[HMR].source, module.default[HMR].original);
  });
}
var BackwardStepOutline_default = BackwardStepOutline;
mark_module_end(BackwardStepOutline);

// node_modules/flowbite-svelte-icons/dist/BackwardStepSolid.svelte
mark_module_start();
BackwardStepSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BackwardStepSolid.svelte";
var root_147 = add_locations(ns_template(`<title> </title>`), BackwardStepSolid[FILENAME], [[39, 4]]);
var root_247 = add_locations(ns_template(`<desc> </desc>`), BackwardStepSolid[FILENAME], [[42, 4]]);
var root47 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M7 6a1 1 0 0 1 2 0v4l6.4-4.8A1 1 0 0 1 17 6v12a1 1 0 0 1-1.6.8L9 14v4a1 1 0 1 1-2 0V6Z" clip-rule="evenodd"></path></svg>`), BackwardStepSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BackwardStepSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BackwardStepSolid);
  validate_prop_bindings($$props, [], [], BackwardStepSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "backward step solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root47();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_147();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_247();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BackwardStepSolid = hmr(BackwardStepSolid, () => BackwardStepSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BackwardStepSolid[HMR].source;
    set(BackwardStepSolid[HMR].source, module.default[HMR].original);
  });
}
var BackwardStepSolid_default = BackwardStepSolid;
mark_module_end(BackwardStepSolid);

// node_modules/flowbite-svelte-icons/dist/BadgeCheckOutline.svelte
mark_module_start();
BadgeCheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BadgeCheckOutline.svelte";
var root_148 = add_locations(ns_template(`<title> </title>`), BadgeCheckOutline[FILENAME], [[41, 4]]);
var root_248 = add_locations(ns_template(`<desc> </desc>`), BadgeCheckOutline[FILENAME], [[44, 4]]);
var root48 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8.032 12 1.984 1.984 4.96-4.96m4.55 5.272.893-.893a1.984 1.984 0 0 0 0-2.806l-.893-.893a1.984 1.984 0 0 1-.581-1.403V7.04a1.984 1.984 0 0 0-1.984-1.984h-1.262a1.983 1.983 0 0 1-1.403-.581l-.893-.893a1.984 1.984 0 0 0-2.806 0l-.893.893a1.984 1.984 0 0 1-1.403.581H7.04A1.984 1.984 0 0 0 5.055 7.04v1.262c0 .527-.209 1.031-.581 1.403l-.893.893a1.984 1.984 0 0 0 0 2.806l.893.893c.372.372.581.876.581 1.403v1.262a1.984 1.984 0 0 0 1.984 1.984h1.262c.527 0 1.031.209 1.403.581l.893.893a1.984 1.984 0 0 0 2.806 0l.893-.893a1.985 1.985 0 0 1 1.403-.581h1.262a1.984 1.984 0 0 0 1.984-1.984V15.7c0-.527.209-1.031.581-1.403Z"></path></svg>`), BadgeCheckOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BadgeCheckOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BadgeCheckOutline);
  validate_prop_bindings($$props, [], [], BadgeCheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "badge check outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root48();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_148();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_248();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BadgeCheckOutline = hmr(BadgeCheckOutline, () => BadgeCheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BadgeCheckOutline[HMR].source;
    set(BadgeCheckOutline[HMR].source, module.default[HMR].original);
  });
}
var BadgeCheckOutline_default = BadgeCheckOutline;
mark_module_end(BadgeCheckOutline);

// node_modules/flowbite-svelte-icons/dist/BadgeCheckSolid.svelte
mark_module_start();
BadgeCheckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BadgeCheckSolid.svelte";
var root_149 = add_locations(ns_template(`<title> </title>`), BadgeCheckSolid[FILENAME], [[39, 4]]);
var root_249 = add_locations(ns_template(`<desc> </desc>`), BadgeCheckSolid[FILENAME], [[42, 4]]);
var root49 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 2c-.791 0-1.55.314-2.11.874l-.893.893a.985.985 0 0 1-.696.288H7.04A2.984 2.984 0 0 0 4.055 7.04v1.262a.986.986 0 0 1-.288.696l-.893.893a2.984 2.984 0 0 0 0 4.22l.893.893a.985.985 0 0 1 .288.696v1.262a2.984 2.984 0 0 0 2.984 2.984h1.262c.261 0 .512.104.696.288l.893.893a2.984 2.984 0 0 0 4.22 0l.893-.893a.985.985 0 0 1 .696-.288h1.262a2.984 2.984 0 0 0 2.984-2.984V15.7c0-.261.104-.512.288-.696l.893-.893a2.984 2.984 0 0 0 0-4.22l-.893-.893a.985.985 0 0 1-.288-.696V7.04a2.984 2.984 0 0 0-2.984-2.984h-1.262a.985.985 0 0 1-.696-.288l-.893-.893A2.984 2.984 0 0 0 12 2Zm3.683 7.73a1 1 0 1 0-1.414-1.413l-4.253 4.253-1.277-1.277a1 1 0 0 0-1.415 1.414l1.985 1.984a1 1 0 0 0 1.414 0l4.96-4.96Z" clip-rule="evenodd"></path></svg>`), BadgeCheckSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BadgeCheckSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BadgeCheckSolid);
  validate_prop_bindings($$props, [], [], BadgeCheckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "badge check solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root49();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_149();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_249();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BadgeCheckSolid = hmr(BadgeCheckSolid, () => BadgeCheckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BadgeCheckSolid[HMR].source;
    set(BadgeCheckSolid[HMR].source, module.default[HMR].original);
  });
}
var BadgeCheckSolid_default = BadgeCheckSolid;
mark_module_end(BadgeCheckSolid);

// node_modules/flowbite-svelte-icons/dist/BanOutline.svelte
mark_module_start();
BanOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BanOutline.svelte";
var root_150 = add_locations(ns_template(`<title> </title>`), BanOutline[FILENAME], [[41, 4]]);
var root_250 = add_locations(ns_template(`<desc> </desc>`), BanOutline[FILENAME], [[44, 4]]);
var root50 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m6 6 12 12m3-6a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), BanOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BanOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BanOutline);
  validate_prop_bindings($$props, [], [], BanOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "ban outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root50();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_150();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_250();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BanOutline = hmr(BanOutline, () => BanOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BanOutline[HMR].source;
    set(BanOutline[HMR].source, module.default[HMR].original);
  });
}
var BanOutline_default = BanOutline;
mark_module_end(BanOutline);

// node_modules/flowbite-svelte-icons/dist/BarcodeOutline.svelte
mark_module_start();
BarcodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BarcodeOutline.svelte";
var root_151 = add_locations(ns_template(`<title> </title>`), BarcodeOutline[FILENAME], [[41, 4]]);
var root_251 = add_locations(ns_template(`<desc> </desc>`), BarcodeOutline[FILENAME], [[44, 4]]);
var root51 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M2.9917 4.9834V18.917M9.96265 4.9834V18.917M15.9378 4.9834V18.917m2.9875-13.9336V18.917"></path><path stroke="currentColor" stroke-linecap="round" d="M5.47925 4.4834V19.417m1.9917-14.9336V19.417M21.4129 4.4834V19.417M13.4461 4.4834V19.417"></path></svg>`), BarcodeOutline[FILENAME], [
  [30, 0, [[46, 2], [52, 2]]]
]);
function BarcodeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BarcodeOutline);
  validate_prop_bindings($$props, [], [], BarcodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "barcode outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root51();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_151();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_251();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  next();
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BarcodeOutline = hmr(BarcodeOutline, () => BarcodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BarcodeOutline[HMR].source;
    set(BarcodeOutline[HMR].source, module.default[HMR].original);
  });
}
var BarcodeOutline_default = BarcodeOutline;
mark_module_end(BarcodeOutline);

// node_modules/flowbite-svelte-icons/dist/BarsFromLeftOutline.svelte
mark_module_start();
BarsFromLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BarsFromLeftOutline.svelte";
var root_152 = add_locations(ns_template(`<title> </title>`), BarsFromLeftOutline[FILENAME], [[41, 4]]);
var root_252 = add_locations(ns_template(`<desc> </desc>`), BarsFromLeftOutline[FILENAME], [[44, 4]]);
var root52 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 7h14M5 12h14M5 17h10"></path></svg>`), BarsFromLeftOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BarsFromLeftOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BarsFromLeftOutline);
  validate_prop_bindings($$props, [], [], BarsFromLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bars from left outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root52();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_152();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_252();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BarsFromLeftOutline = hmr(BarsFromLeftOutline, () => BarsFromLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BarsFromLeftOutline[HMR].source;
    set(BarsFromLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var BarsFromLeftOutline_default = BarsFromLeftOutline;
mark_module_end(BarsFromLeftOutline);

// node_modules/flowbite-svelte-icons/dist/BarsOutline.svelte
mark_module_start();
BarsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BarsOutline.svelte";
var root_153 = add_locations(ns_template(`<title> </title>`), BarsOutline[FILENAME], [[41, 4]]);
var root_253 = add_locations(ns_template(`<desc> </desc>`), BarsOutline[FILENAME], [[44, 4]]);
var root53 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 7h14M5 12h14M5 17h14"></path></svg>`), BarsOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BarsOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BarsOutline);
  validate_prop_bindings($$props, [], [], BarsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bars outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root53();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_153();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_253();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BarsOutline = hmr(BarsOutline, () => BarsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BarsOutline[HMR].source;
    set(BarsOutline[HMR].source, module.default[HMR].original);
  });
}
var BarsOutline_default = BarsOutline;
mark_module_end(BarsOutline);

// node_modules/flowbite-svelte-icons/dist/BatteryOutline.svelte
mark_module_start();
BatteryOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BatteryOutline.svelte";
var root_154 = add_locations(ns_template(`<title> </title>`), BatteryOutline[FILENAME], [[41, 4]]);
var root_254 = add_locations(ns_template(`<desc> </desc>`), BatteryOutline[FILENAME], [[44, 4]]);
var root54 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M2.98755 7.97095c0-.55229.44771-1 1-1H16.9253c.5523 0 1 .44771 1 1v7.95855c0 .5522-.4477 1-1 1H3.98755c-.55229 0-1-.4478-1-1V7.97095ZM20.9129 12.9419v-1.9834c0-.5523-.4478-1-1-1h-.9876c-.5523 0-1 .4477-1 1v1.9834c0 .5523.4477 1 1 1h.9876c.5522 0 1-.4477 1-1Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M5.9751 9.9585h8.9627v3.9834H5.9751V9.9585Z"></path></svg>`), BatteryOutline[FILENAME], [
  [30, 0, [[46, 2], [52, 2]]]
]);
function BatteryOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BatteryOutline);
  validate_prop_bindings($$props, [], [], BatteryOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "battery outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root54();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_154();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_254();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BatteryOutline = hmr(BatteryOutline, () => BatteryOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BatteryOutline[HMR].source;
    set(BatteryOutline[HMR].source, module.default[HMR].original);
  });
}
var BatteryOutline_default = BatteryOutline;
mark_module_end(BatteryOutline);

// node_modules/flowbite-svelte-icons/dist/BatterySolid.svelte
mark_module_start();
BatterySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BatterySolid.svelte";
var root_155 = add_locations(ns_template(`<title> </title>`), BatterySolid[FILENAME], [[39, 4]]);
var root_255 = add_locations(ns_template(`<desc> </desc>`), BatterySolid[FILENAME], [[42, 4]]);
var root55 = add_locations(ns_template(`<svg><!><!><path d="M7 13v-2h7v2H7Z"></path><path fill-rule="evenodd" d="M2 8a2 2 0 0 1 2-2h13a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8Zm4 1a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h9a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1H6Z" clip-rule="evenodd"></path><path d="M22 14v-4a1 1 0 0 0-1-1h-1v6h1a1 1 0 0 0 1-1Z"></path></svg>`), BatterySolid[FILENAME], [
  [
    29,
    0,
    [[44, 2], [45, 2], [49, 5]]
  ]
]);
function BatterySolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BatterySolid);
  validate_prop_bindings($$props, [], [], BatterySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "battery solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root55();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_155();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_255();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(3);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BatterySolid = hmr(BatterySolid, () => BatterySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BatterySolid[HMR].source;
    set(BatterySolid[HMR].source, module.default[HMR].original);
  });
}
var BatterySolid_default = BatterySolid;
mark_module_end(BatterySolid);

// node_modules/flowbite-svelte-icons/dist/BedOutline.svelte
mark_module_start();
BedOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BedOutline.svelte";
var root_156 = add_locations(ns_template(`<title> </title>`), BedOutline[FILENAME], [[41, 4]]);
var root_256 = add_locations(ns_template(`<desc> </desc>`), BedOutline[FILENAME], [[44, 4]]);
var root56 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 17v2M12 5.5V10m-6 7v2m15-2v-4c0-1.6569-1.3431-3-3-3H6c-1.65685 0-3 1.3431-3 3v4h18Zm-2-7V8c0-1.65685-1.3431-3-3-3H8C6.34315 5 5 6.34315 5 8v2h14Z"></path></svg>`), BedOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BedOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BedOutline);
  validate_prop_bindings($$props, [], [], BedOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bed outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root56();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_156();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_256();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BedOutline = hmr(BedOutline, () => BedOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BedOutline[HMR].source;
    set(BedOutline[HMR].source, module.default[HMR].original);
  });
}
var BedOutline_default = BedOutline;
mark_module_end(BedOutline);

// node_modules/flowbite-svelte-icons/dist/BedSolid.svelte
mark_module_start();
BedSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BedSolid.svelte";
var root_157 = add_locations(ns_template(`<title> </title>`), BedSolid[FILENAME], [[39, 4]]);
var root_257 = add_locations(ns_template(`<desc> </desc>`), BedSolid[FILENAME], [[42, 4]]);
var root57 = add_locations(ns_template(`<svg><!><!><path d="M2.535 11A3.981 3.981 0 0 0 2 13v4a1 1 0 0 0 1 1h2v1a1 1 0 1 0 2 0v-1h10v1a1 1 0 1 0 2 0v-1h2a1 1 0 0 0 1-1v-4c0-.729-.195-1.412-.535-2H2.535ZM20 9V8a4 4 0 0 0-4-4h-3v5h7Zm-9-5H8a4 4 0 0 0-4 4v1h7V4Z"></path></svg>`), BedSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BedSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BedSolid);
  validate_prop_bindings($$props, [], [], BedSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "bed solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root57();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_157();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_257();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BedSolid = hmr(BedSolid, () => BedSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BedSolid[HMR].source;
    set(BedSolid[HMR].source, module.default[HMR].original);
  });
}
var BedSolid_default = BedSolid;
mark_module_end(BedSolid);

// node_modules/flowbite-svelte-icons/dist/BellActiveAltOutline.svelte
mark_module_start();
BellActiveAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellActiveAltOutline.svelte";
var root_158 = add_locations(ns_template(`<title> </title>`), BellActiveAltOutline[FILENAME], [[41, 4]]);
var root_258 = add_locations(ns_template(`<desc> </desc>`), BellActiveAltOutline[FILENAME], [[44, 4]]);
var root58 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5.365V3m0 2.365a5.338 5.338 0 0 1 5.133 5.368v1.8c0 2.386 1.867 2.982 1.867 4.175 0 .593 0 1.193-.538 1.193H5.538c-.538 0-.538-.6-.538-1.193 0-1.193 1.867-1.789 1.867-4.175v-1.8A5.338 5.338 0 0 1 12 5.365Zm-8.134 5.368a8.458 8.458 0 0 1 2.252-5.714m14.016 5.714a8.458 8.458 0 0 0-2.252-5.714M8.54 17.901a3.48 3.48 0 0 0 6.92 0H8.54Z"></path></svg>`), BellActiveAltOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BellActiveAltOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BellActiveAltOutline);
  validate_prop_bindings($$props, [], [], BellActiveAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bell active alt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root58();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_158();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_258();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BellActiveAltOutline = hmr(BellActiveAltOutline, () => BellActiveAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellActiveAltOutline[HMR].source;
    set(BellActiveAltOutline[HMR].source, module.default[HMR].original);
  });
}
var BellActiveAltOutline_default = BellActiveAltOutline;
mark_module_end(BellActiveAltOutline);

// node_modules/flowbite-svelte-icons/dist/BellActiveAltSolid.svelte
mark_module_start();
BellActiveAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellActiveAltSolid.svelte";
var root_159 = add_locations(ns_template(`<title> </title>`), BellActiveAltSolid[FILENAME], [[39, 4]]);
var root_259 = add_locations(ns_template(`<desc> </desc>`), BellActiveAltSolid[FILENAME], [[42, 4]]);
var root59 = add_locations(ns_template(`<svg><!><!><path d="M17.133 12.632v-1.8a5.407 5.407 0 0 0-4.154-5.262.955.955 0 0 0 .021-.106V3.1a1 1 0 0 0-2 0v2.364a.933.933 0 0 0 .021.106 5.406 5.406 0 0 0-4.154 5.262v1.8C6.867 15.018 5 15.614 5 16.807 5 17.4 5 18 5.538 18h12.924C19 18 19 17.4 19 16.807c0-1.193-1.867-1.789-1.867-4.175Zm-13.267-.8a1 1 0 0 1-1-1 9.424 9.424 0 0 1 2.517-6.391A1.001 1.001 0 1 1 6.854 5.8a7.43 7.43 0 0 0-1.988 5.037 1 1 0 0 1-1 .995Zm16.268 0a1 1 0 0 1-1-1A7.431 7.431 0 0 0 17.146 5.8a1 1 0 0 1 1.471-1.354 9.424 9.424 0 0 1 2.517 6.391 1 1 0 0 1-1 .995ZM8.823 19a3.453 3.453 0 0 0 6.354 0H8.823Z"></path></svg>`), BellActiveAltSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BellActiveAltSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BellActiveAltSolid);
  validate_prop_bindings($$props, [], [], BellActiveAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "bell active alt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root59();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_159();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_259();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BellActiveAltSolid = hmr(BellActiveAltSolid, () => BellActiveAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellActiveAltSolid[HMR].source;
    set(BellActiveAltSolid[HMR].source, module.default[HMR].original);
  });
}
var BellActiveAltSolid_default = BellActiveAltSolid;
mark_module_end(BellActiveAltSolid);

// node_modules/flowbite-svelte-icons/dist/BellActiveOutline.svelte
mark_module_start();
BellActiveOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellActiveOutline.svelte";
var root_160 = add_locations(ns_template(`<title> </title>`), BellActiveOutline[FILENAME], [[41, 4]]);
var root_260 = add_locations(ns_template(`<desc> </desc>`), BellActiveOutline[FILENAME], [[44, 4]]);
var root60 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10.827 5.465-.435-2.324m.435 2.324a5.338 5.338 0 0 1 6.033 4.333l.331 1.769c.44 2.345 2.383 2.588 2.6 3.761.11.586.22 1.171-.31 1.271l-12.7 2.377c-.529.099-.639-.488-.749-1.074C5.813 16.73 7.538 15.8 7.1 13.455c-.219-1.169.218 1.162-.33-1.769a5.338 5.338 0 0 1 4.058-6.221Zm-7.046 4.41c.143-1.877.822-3.461 2.086-4.856m2.646 13.633a3.472 3.472 0 0 0 6.728-.777l.09-.5-6.818 1.277Z"></path></svg>`), BellActiveOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BellActiveOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BellActiveOutline);
  validate_prop_bindings($$props, [], [], BellActiveOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bell active outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root60();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_160();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_260();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BellActiveOutline = hmr(BellActiveOutline, () => BellActiveOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellActiveOutline[HMR].source;
    set(BellActiveOutline[HMR].source, module.default[HMR].original);
  });
}
var BellActiveOutline_default = BellActiveOutline;
mark_module_end(BellActiveOutline);

// node_modules/flowbite-svelte-icons/dist/BellActiveSolid.svelte
mark_module_start();
BellActiveSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellActiveSolid.svelte";
var root_161 = add_locations(ns_template(`<title> </title>`), BellActiveSolid[FILENAME], [[39, 4]]);
var root_261 = add_locations(ns_template(`<desc> </desc>`), BellActiveSolid[FILENAME], [[42, 4]]);
var root61 = add_locations(ns_template(`<svg><!><!><path d="M11.209 3.816a1 1 0 0 0-1.966.368l.325 1.74a5.338 5.338 0 0 0-2.8 5.762l.276 1.473.055.296c.258 1.374-.228 2.262-.63 2.998-.285.52-.527.964-.437 1.449.11.586.22 1.173.75 1.074l12.7-2.377c.528-.1.418-.685.308-1.27-.103-.564-.636-1.123-1.195-1.711-.606-.636-1.243-1.306-1.404-2.051-.233-1.085-.275-1.387-.303-1.587-.009-.063-.016-.117-.028-.182a5.338 5.338 0 0 0-5.353-4.39l-.298-1.592Z"></path><path fill-rule="evenodd" d="M6.539 4.278a1 1 0 0 1 .07 1.412c-1.115 1.23-1.705 2.605-1.83 4.26a1 1 0 0 1-1.995-.15c.16-2.099.929-3.893 2.342-5.453a1 1 0 0 1 1.413-.069Z" clip-rule="evenodd"></path><path d="M8.95 19.7c.7.8 1.7 1.3 2.8 1.3 1.6 0 2.9-1.1 3.3-2.5l-6.1 1.2Z"></path></svg>`), BellActiveSolid[FILENAME], [
  [
    29,
    0,
    [[44, 2], [47, 2], [51, 5]]
  ]
]);
function BellActiveSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BellActiveSolid);
  validate_prop_bindings($$props, [], [], BellActiveSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "bell active solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root61();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_161();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_261();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(3);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BellActiveSolid = hmr(BellActiveSolid, () => BellActiveSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellActiveSolid[HMR].source;
    set(BellActiveSolid[HMR].source, module.default[HMR].original);
  });
}
var BellActiveSolid_default = BellActiveSolid;
mark_module_end(BellActiveSolid);

// node_modules/flowbite-svelte-icons/dist/BellOutline.svelte
mark_module_start();
BellOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellOutline.svelte";
var root_162 = add_locations(ns_template(`<title> </title>`), BellOutline[FILENAME], [[41, 4]]);
var root_262 = add_locations(ns_template(`<desc> </desc>`), BellOutline[FILENAME], [[44, 4]]);
var root62 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5.365V3m0 2.365a5.338 5.338 0 0 1 5.133 5.368v1.8c0 2.386 1.867 2.982 1.867 4.175 0 .593 0 1.292-.538 1.292H5.538C5 18 5 17.301 5 16.708c0-1.193 1.867-1.789 1.867-4.175v-1.8A5.338 5.338 0 0 1 12 5.365ZM8.733 18c.094.852.306 1.54.944 2.112a3.48 3.48 0 0 0 4.646 0c.638-.572 1.236-1.26 1.33-2.112h-6.92Z"></path></svg>`), BellOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BellOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BellOutline);
  validate_prop_bindings($$props, [], [], BellOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bell outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root62();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_162();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_262();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BellOutline = hmr(BellOutline, () => BellOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellOutline[HMR].source;
    set(BellOutline[HMR].source, module.default[HMR].original);
  });
}
var BellOutline_default = BellOutline;
mark_module_end(BellOutline);

// node_modules/flowbite-svelte-icons/dist/BellRingOutline.svelte
mark_module_start();
BellRingOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellRingOutline.svelte";
var root_163 = add_locations(ns_template(`<title> </title>`), BellRingOutline[FILENAME], [[41, 4]]);
var root_263 = add_locations(ns_template(`<desc> </desc>`), BellRingOutline[FILENAME], [[44, 4]]);
var root63 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5.464V3.099m0 2.365a5.338 5.338 0 0 1 5.133 5.368v1.8c0 2.386 1.867 2.982 1.867 4.175C19 17.4 19 18 18.462 18H5.538C5 18 5 17.4 5 16.807c0-1.193 1.867-1.789 1.867-4.175v-1.8A5.338 5.338 0 0 1 12 5.464ZM6 5 5 4M4 9H3m15-4 1-1m1 5h1M8.54 18a3.48 3.48 0 0 0 6.92 0H8.54Z"></path></svg>`), BellRingOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BellRingOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BellRingOutline);
  validate_prop_bindings($$props, [], [], BellRingOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bell ring outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root63();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_163();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_263();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BellRingOutline = hmr(BellRingOutline, () => BellRingOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellRingOutline[HMR].source;
    set(BellRingOutline[HMR].source, module.default[HMR].original);
  });
}
var BellRingOutline_default = BellRingOutline;
mark_module_end(BellRingOutline);

// node_modules/flowbite-svelte-icons/dist/BellRingSolid.svelte
mark_module_start();
BellRingSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellRingSolid.svelte";
var root_164 = add_locations(ns_template(`<title> </title>`), BellRingSolid[FILENAME], [[39, 4]]);
var root_264 = add_locations(ns_template(`<desc> </desc>`), BellRingSolid[FILENAME], [[42, 4]]);
var root64 = add_locations(ns_template(`<svg><!><!><path d="M17.133 12.632v-1.8a5.406 5.406 0 0 0-4.154-5.262.955.955 0 0 0 .021-.106V3.1a1 1 0 0 0-2 0v2.364a.955.955 0 0 0 .021.106 5.406 5.406 0 0 0-4.154 5.262v1.8C6.867 15.018 5 15.614 5 16.807 5 17.4 5 18 5.538 18h12.924C19 18 19 17.4 19 16.807c0-1.193-1.867-1.789-1.867-4.175ZM6 6a1 1 0 0 1-.707-.293l-1-1a1 1 0 0 1 1.414-1.414l1 1A1 1 0 0 1 6 6Zm-2 4H3a1 1 0 0 1 0-2h1a1 1 0 1 1 0 2Zm14-4a1 1 0 0 1-.707-1.707l1-1a1 1 0 1 1 1.414 1.414l-1 1A1 1 0 0 1 18 6Zm3 4h-1a1 1 0 1 1 0-2h1a1 1 0 1 1 0 2ZM8.823 19a3.453 3.453 0 0 0 6.354 0H8.823Z"></path></svg>`), BellRingSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BellRingSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BellRingSolid);
  validate_prop_bindings($$props, [], [], BellRingSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "bell ring solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root64();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_164();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_264();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BellRingSolid = hmr(BellRingSolid, () => BellRingSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellRingSolid[HMR].source;
    set(BellRingSolid[HMR].source, module.default[HMR].original);
  });
}
var BellRingSolid_default = BellRingSolid;
mark_module_end(BellRingSolid);

// node_modules/flowbite-svelte-icons/dist/BellSolid.svelte
mark_module_start();
BellSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BellSolid.svelte";
var root_165 = add_locations(ns_template(`<title> </title>`), BellSolid[FILENAME], [[39, 4]]);
var root_265 = add_locations(ns_template(`<desc> </desc>`), BellSolid[FILENAME], [[42, 4]]);
var root65 = add_locations(ns_template(`<svg><!><!><path d="M17.133 12.632v-1.8a5.406 5.406 0 0 0-4.154-5.262.955.955 0 0 0 .021-.106V3.1a1 1 0 0 0-2 0v2.364a.955.955 0 0 0 .021.106 5.406 5.406 0 0 0-4.154 5.262v1.8C6.867 15.018 5 15.614 5 16.807 5 17.4 5 18 5.538 18h12.924C19 18 19 17.4 19 16.807c0-1.193-1.867-1.789-1.867-4.175ZM8.823 19a3.453 3.453 0 0 0 6.354 0H8.823Z"></path></svg>`), BellSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BellSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BellSolid);
  validate_prop_bindings($$props, [], [], BellSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "bell solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root65();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_165();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_265();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BellSolid = hmr(BellSolid, () => BellSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BellSolid[HMR].source;
    set(BellSolid[HMR].source, module.default[HMR].original);
  });
}
var BellSolid_default = BellSolid;
mark_module_end(BellSolid);

// node_modules/flowbite-svelte-icons/dist/BitcoinSolid.svelte
mark_module_start();
BitcoinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BitcoinSolid.svelte";
var root_166 = add_locations(ns_template(`<title> </title>`), BitcoinSolid[FILENAME], [[39, 4]]);
var root_266 = add_locations(ns_template(`<desc> </desc>`), BitcoinSolid[FILENAME], [[42, 4]]);
var root66 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M10.7367 14.5876c.895.2365 2.8528.754 3.1643-.4966.3179-1.2781-1.5795-1.7039-2.5053-1.9117-.1034-.0232-.1947-.0437-.2694-.0623l-.6025 2.4153c.0611.0152.1328.0341.2129.0553Zm.8452-3.5291c.7468.1993 2.3746.6335 2.6581-.5025.2899-1.16213-1.2929-1.5124-2.066-1.68348-.0869-.01923-.1635-.03619-.2262-.0518l-.5462 2.19058c.0517.0129.1123.0291.1803.0472Z"></path><path fill="currentColor" fill-rule="evenodd" d="M9.57909 21.7008c5.35781 1.3356 10.78401-1.9244 12.11971-7.2816 1.3356-5.35745-1.9247-10.78433-7.2822-12.11995C9.06034.963624 3.6344 4.22425 2.2994 9.58206.963461 14.9389 4.22377 20.3652 9.57909 21.7008ZM14.2085 8.0526c1.3853.47719 2.3984 1.1925 2.1997 2.5231-.1441.9741-.6844 1.4456-1.4013 1.6116.9844.5128 1.485 1.2987 1.0078 2.6612-.5915 1.6919-1.9987 1.8347-3.8697 1.4807l-.454 1.8196-1.0972-.2734.4481-1.7953c-.2844-.0706-.575-.1456-.8741-.2269l-.44996 1.8038-1.09594-.2735.45407-1.8234c-.10059-.0258-.20185-.0522-.30385-.0788-.15753-.0411-.3168-.0827-.47803-.1231l-1.42812-.3559.54468-1.2563s.80844.215.7975.1991c.31063.0769.44844-.1256.50282-.2606l.71781-2.8766.11562.0288c-.04375-.0175-.08343-.0288-.11406-.0366l.51188-2.05344c.01375-.23312-.06688-.52719-.51125-.63812.01718-.01157-.79688-.19813-.79688-.19813l.29188-1.17187 1.51313.37781-.0013.00562c.2275.05657.4619.11032.7007.16469l.4497-1.80187 1.0965.27343-.4406 1.76657c.2944.06718.5906.135.8787.20687l.4375-1.755 1.0975.27344-.4493 1.8025Z" clip-rule="evenodd"></path></svg>`), BitcoinSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 2]]]
]);
function BitcoinSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BitcoinSolid);
  validate_prop_bindings($$props, [], [], BitcoinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "bitcoin solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root66();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_166();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_266();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BitcoinSolid = hmr(BitcoinSolid, () => BitcoinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BitcoinSolid[HMR].source;
    set(BitcoinSolid[HMR].source, module.default[HMR].original);
  });
}
var BitcoinSolid_default = BitcoinSolid;
mark_module_end(BitcoinSolid);

// node_modules/flowbite-svelte-icons/dist/BlenderPhoneOutline.svelte
mark_module_start();
BlenderPhoneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BlenderPhoneOutline.svelte";
var root_167 = add_locations(ns_template(`<title> </title>`), BlenderPhoneOutline[FILENAME], [[41, 4]]);
var root_267 = add_locations(ns_template(`<desc> </desc>`), BlenderPhoneOutline[FILENAME], [[44, 4]]);
var root67 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20.283 8h-4.285m3.85 3h-3.85m4.061-6H11v11h8.27l1.715-9.847A.983.983 0 0 0 20.059 5ZM6.581 13.23h-.838A13.752 13.752 0 0 1 5.622 11c-.02-.745.02-1.49.12-2.23h1.04c.252 0 .496-.088.683-.245a.927.927 0 0 0 .329-.61l.2-1.872a.888.888 0 0 0-.045-.39.936.936 0 0 0-.212-.34 1.017 1.017 0 0 0-.341-.231A1.08 1.08 0 0 0 6.983 5h-2.06a1.27 1.27 0 0 0-.699.204 1.135 1.135 0 0 0-.442.543A15.066 15.066 0 0 0 3.007 11a15.656 15.656 0 0 0 .795 5.229c.165.462 1.342.771 1.864.771h1.116c.142 0 .283-.028.413-.082.13-.053.246-.132.341-.23a.936.936 0 0 0 .212-.34.889.889 0 0 0 .046-.391l-.201-1.873a.927.927 0 0 0-.33-.609 1.059 1.059 0 0 0-.682-.245ZM10 18v1h10v-1a2 2 0 0 0-2-2h-6a2 2 0 0 0-2 2Z"></path></svg>`), BlenderPhoneOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BlenderPhoneOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BlenderPhoneOutline);
  validate_prop_bindings($$props, [], [], BlenderPhoneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "blender phone outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root67();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_167();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_267();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BlenderPhoneOutline = hmr(BlenderPhoneOutline, () => BlenderPhoneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BlenderPhoneOutline[HMR].source;
    set(BlenderPhoneOutline[HMR].source, module.default[HMR].original);
  });
}
var BlenderPhoneOutline_default = BlenderPhoneOutline;
mark_module_end(BlenderPhoneOutline);

// node_modules/flowbite-svelte-icons/dist/BlenderPhoneSolid.svelte
mark_module_start();
BlenderPhoneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BlenderPhoneSolid.svelte";
var root_168 = add_locations(ns_template(`<title> </title>`), BlenderPhoneSolid[FILENAME], [[39, 4]]);
var root_268 = add_locations(ns_template(`<desc> </desc>`), BlenderPhoneSolid[FILENAME], [[42, 4]]);
var root68 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M11 4a1 1 0 0 0-1 1v10h10.459l.522-3H16a1 1 0 1 1 0-2h5.33l.174-1H16a1 1 0 1 1 0-2h5.852l.117-.67v-.003A1.983 1.983 0 0 0 20.06 4H11ZM9 18c0-.35.06-.687.17-1h11.66c.11.313.17.65.17 1v1a1 1 0 0 1-1 1H10a1 1 0 0 1-1-1v-1Zm-6.991-7a17.8 17.8 0 0 0 .953 6.1c.198.54 1.61.9 2.237.9h1.34c.17 0 .339-.032.495-.095a1.24 1.24 0 0 0 .41-.27c.114-.114.2-.25.254-.396a1.01 1.01 0 0 0 .055-.456l-.242-2.185a1.073 1.073 0 0 0-.395-.71 1.292 1.292 0 0 0-.819-.286H5.291c-.12-.863-.17-1.732-.145-2.602-.024-.87.024-1.74.145-2.602H6.54c.302 0 .594-.102.818-.286a1.07 1.07 0 0 0 .396-.71l.24-2.185a1.01 1.01 0 0 0-.054-.456 1.088 1.088 0 0 0-.254-.397 1.223 1.223 0 0 0-.41-.269A1.328 1.328 0 0 0 6.78 4H4.307c-.3-.001-.592.082-.838.238a1.335 1.335 0 0 0-.531.634A17.127 17.127 0 0 0 2.008 11Z" clip-rule="evenodd"></path></svg>`), BlenderPhoneSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BlenderPhoneSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BlenderPhoneSolid);
  validate_prop_bindings($$props, [], [], BlenderPhoneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "blender phone solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root68();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_168();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_268();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BlenderPhoneSolid = hmr(BlenderPhoneSolid, () => BlenderPhoneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BlenderPhoneSolid[HMR].source;
    set(BlenderPhoneSolid[HMR].source, module.default[HMR].original);
  });
}
var BlenderPhoneSolid_default = BlenderPhoneSolid;
mark_module_end(BlenderPhoneSolid);

// node_modules/flowbite-svelte-icons/dist/BookOpenOutline.svelte
mark_module_start();
BookOpenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookOpenOutline.svelte";
var root_169 = add_locations(ns_template(`<title> </title>`), BookOpenOutline[FILENAME], [[41, 4]]);
var root_269 = add_locations(ns_template(`<desc> </desc>`), BookOpenOutline[FILENAME], [[44, 4]]);
var root69 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 6.03v13m0-13c-2.819-.831-4.715-1.076-8.029-1.023A.99.99 0 0 0 3 6v11c0 .563.466 1.014 1.03 1.007 3.122-.043 5.018.212 7.97 1.023m0-13c2.819-.831 4.715-1.076 8.029-1.023A.99.99 0 0 1 21 6v11c0 .563-.466 1.014-1.03 1.007-3.122-.043-5.018.212-7.97 1.023"></path></svg>`), BookOpenOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BookOpenOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BookOpenOutline);
  validate_prop_bindings($$props, [], [], BookOpenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "book open outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root69();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_169();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_269();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BookOpenOutline = hmr(BookOpenOutline, () => BookOpenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookOpenOutline[HMR].source;
    set(BookOpenOutline[HMR].source, module.default[HMR].original);
  });
}
var BookOpenOutline_default = BookOpenOutline;
mark_module_end(BookOpenOutline);

// node_modules/flowbite-svelte-icons/dist/BookOpenSolid.svelte
mark_module_start();
BookOpenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookOpenSolid.svelte";
var root_170 = add_locations(ns_template(`<title> </title>`), BookOpenSolid[FILENAME], [[39, 4]]);
var root_270 = add_locations(ns_template(`<desc> </desc>`), BookOpenSolid[FILENAME], [[42, 4]]);
var root70 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M11 4.717c-2.286-.58-4.16-.756-7.045-.71A1.99 1.99 0 0 0 2 6v11c0 1.133.934 2.022 2.044 2.007 2.759-.038 4.5.16 6.956.791V4.717Zm2 15.081c2.456-.631 4.198-.829 6.956-.791A2.013 2.013 0 0 0 22 16.999V6a1.99 1.99 0 0 0-1.955-1.993c-2.885-.046-4.76.13-7.045.71v15.081Z" clip-rule="evenodd"></path></svg>`), BookOpenSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BookOpenSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BookOpenSolid);
  validate_prop_bindings($$props, [], [], BookOpenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "book open solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root70();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_170();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_270();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BookOpenSolid = hmr(BookOpenSolid, () => BookOpenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookOpenSolid[HMR].source;
    set(BookOpenSolid[HMR].source, module.default[HMR].original);
  });
}
var BookOpenSolid_default = BookOpenSolid;
mark_module_end(BookOpenSolid);

// node_modules/flowbite-svelte-icons/dist/BookOutline.svelte
mark_module_start();
BookOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookOutline.svelte";
var root_171 = add_locations(ns_template(`<title> </title>`), BookOutline[FILENAME], [[41, 4]]);
var root_271 = add_locations(ns_template(`<desc> </desc>`), BookOutline[FILENAME], [[44, 4]]);
var root71 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 19V4a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v13H7a2 2 0 0 0-2 2Zm0 0a2 2 0 0 0 2 2h12M9 3v14m7 0v4"></path></svg>`), BookOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BookOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BookOutline);
  validate_prop_bindings($$props, [], [], BookOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "book outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root71();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_171();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_271();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BookOutline = hmr(BookOutline, () => BookOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookOutline[HMR].source;
    set(BookOutline[HMR].source, module.default[HMR].original);
  });
}
var BookOutline_default = BookOutline;
mark_module_end(BookOutline);

// node_modules/flowbite-svelte-icons/dist/BookSolid.svelte
mark_module_start();
BookSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookSolid.svelte";
var root_172 = add_locations(ns_template(`<title> </title>`), BookSolid[FILENAME], [[39, 4]]);
var root_272 = add_locations(ns_template(`<desc> </desc>`), BookSolid[FILENAME], [[42, 4]]);
var root72 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M6 2a2 2 0 0 0-2 2v15a3 3 0 0 0 3 3h12a1 1 0 1 0 0-2h-2v-2h2a1 1 0 0 0 1-1V4a2 2 0 0 0-2-2h-8v16h5v2H7a1 1 0 1 1 0-2h1V2H6Z" clip-rule="evenodd"></path></svg>`), BookSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BookSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BookSolid);
  validate_prop_bindings($$props, [], [], BookSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "book solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root72();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_172();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_272();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BookSolid = hmr(BookSolid, () => BookSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookSolid[HMR].source;
    set(BookSolid[HMR].source, module.default[HMR].original);
  });
}
var BookSolid_default = BookSolid;
mark_module_end(BookSolid);

// node_modules/flowbite-svelte-icons/dist/BookmarkOutline.svelte
mark_module_start();
BookmarkOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookmarkOutline.svelte";
var root_173 = add_locations(ns_template(`<title> </title>`), BookmarkOutline[FILENAME], [[41, 4]]);
var root_273 = add_locations(ns_template(`<desc> </desc>`), BookmarkOutline[FILENAME], [[44, 4]]);
var root73 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m17 21-5-4-5 4V3.889a.92.92 0 0 1 .244-.629.808.808 0 0 1 .59-.26h8.333a.81.81 0 0 1 .589.26.92.92 0 0 1 .244.63V21Z"></path></svg>`), BookmarkOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BookmarkOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BookmarkOutline);
  validate_prop_bindings($$props, [], [], BookmarkOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bookmark outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root73();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_173();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_273();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BookmarkOutline = hmr(BookmarkOutline, () => BookmarkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookmarkOutline[HMR].source;
    set(BookmarkOutline[HMR].source, module.default[HMR].original);
  });
}
var BookmarkOutline_default = BookmarkOutline;
mark_module_end(BookmarkOutline);

// node_modules/flowbite-svelte-icons/dist/BookmarkSolid.svelte
mark_module_start();
BookmarkSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BookmarkSolid.svelte";
var root_174 = add_locations(ns_template(`<title> </title>`), BookmarkSolid[FILENAME], [[39, 4]]);
var root_274 = add_locations(ns_template(`<desc> </desc>`), BookmarkSolid[FILENAME], [[42, 4]]);
var root74 = add_locations(ns_template(`<svg><!><!><path d="M7.833 2c-.507 0-.98.216-1.318.576A1.92 1.92 0 0 0 6 3.89V21a1 1 0 0 0 1.625.78L12 18.28l4.375 3.5A1 1 0 0 0 18 21V3.889c0-.481-.178-.954-.515-1.313A1.808 1.808 0 0 0 16.167 2H7.833Z"></path></svg>`), BookmarkSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BookmarkSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BookmarkSolid);
  validate_prop_bindings($$props, [], [], BookmarkSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "bookmark solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root74();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_174();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_274();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BookmarkSolid = hmr(BookmarkSolid, () => BookmarkSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BookmarkSolid[HMR].source;
    set(BookmarkSolid[HMR].source, module.default[HMR].original);
  });
}
var BookmarkSolid_default = BookmarkSolid;
mark_module_end(BookmarkSolid);

// node_modules/flowbite-svelte-icons/dist/BoothCurtainOutline.svelte
mark_module_start();
BoothCurtainOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BoothCurtainOutline.svelte";
var root_175 = add_locations(ns_template(`<title> </title>`), BoothCurtainOutline[FILENAME], [[41, 4]]);
var root_275 = add_locations(ns_template(`<desc> </desc>`), BoothCurtainOutline[FILENAME], [[44, 4]]);
var root75 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 5v14m14 0V8h2M3 8h6m0-2v8.5858c0 .8909 1.0771 1.3371 1.7071.7071l.5858-.5858c.3905-.3905 1.0237-.3905 1.4142 0l.5858.5858c.3905.3905 1.0237.3905 1.4142 0l.5858-.5858c.3905-.3905 1.0237-.3905 1.4142 0l.5858.5858c.63.63 1.7071.1838 1.7071-.7071V6c0-.55228-.4477-1-1-1h-8c-.55229 0-1 .44772-1 1Z"></path></svg>`), BoothCurtainOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BoothCurtainOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BoothCurtainOutline);
  validate_prop_bindings($$props, [], [], BoothCurtainOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "booth curtain outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root75();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_175();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_275();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BoothCurtainOutline = hmr(BoothCurtainOutline, () => BoothCurtainOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BoothCurtainOutline[HMR].source;
    set(BoothCurtainOutline[HMR].source, module.default[HMR].original);
  });
}
var BoothCurtainOutline_default = BoothCurtainOutline;
mark_module_end(BoothCurtainOutline);

// node_modules/flowbite-svelte-icons/dist/BoothCurtainSolid.svelte
mark_module_start();
BoothCurtainSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BoothCurtainSolid.svelte";
var root_176 = add_locations(ns_template(`<title> </title>`), BoothCurtainSolid[FILENAME], [[39, 4]]);
var root_276 = add_locations(ns_template(`<desc> </desc>`), BoothCurtainSolid[FILENAME], [[42, 4]]);
var root76 = add_locations(ns_template(`<svg><!><!><path d="M4 5v2H3a1 1 0 0 0 0 2h1v10a1 1 0 1 0 2 0V9h2v5.586c0 1.782 2.154 2.674 3.414 1.414l.586-.586.586.586a2 2 0 0 0 2.828 0l.586-.586.586.586c.411.411.918.593 1.414.59V19a1 1 0 1 0 2 0V9h1a1 1 0 1 0 0-2h-1V6a2 2 0 0 0-2-2h-8a2 2 0 0 0-2 2v1H6V5a1 1 0 0 0-2 0Z"></path></svg>`), BoothCurtainSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BoothCurtainSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BoothCurtainSolid);
  validate_prop_bindings($$props, [], [], BoothCurtainSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "booth curtain solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root76();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_176();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_276();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BoothCurtainSolid = hmr(BoothCurtainSolid, () => BoothCurtainSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BoothCurtainSolid[HMR].source;
    set(BoothCurtainSolid[HMR].source, module.default[HMR].original);
  });
}
var BoothCurtainSolid_default = BoothCurtainSolid;
mark_module_end(BoothCurtainSolid);

// node_modules/flowbite-svelte-icons/dist/BrainOutline.svelte
mark_module_start();
BrainOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BrainOutline.svelte";
var root_177 = add_locations(ns_template(`<title> </title>`), BrainOutline[FILENAME], [[41, 4]]);
var root_277 = add_locations(ns_template(`<desc> </desc>`), BrainOutline[FILENAME], [[44, 4]]);
var root77 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 18.5A2.493 2.493 0 0 1 7.51 20H7.5a2.468 2.468 0 0 1-2.4-3.154 2.98 2.98 0 0 1-.85-5.274 2.468 2.468 0 0 1 .92-3.182 2.477 2.477 0 0 1 1.876-3.344 2.5 2.5 0 0 1 3.41-1.856A2.5 2.5 0 0 1 12 5.5m0 13v-13m0 13a2.493 2.493 0 0 0 4.49 1.5h.01a2.468 2.468 0 0 0 2.403-3.154 2.98 2.98 0 0 0 .847-5.274 2.468 2.468 0 0 0-.921-3.182 2.477 2.477 0 0 0-1.875-3.344A2.5 2.5 0 0 0 14.5 3 2.5 2.5 0 0 0 12 5.5m-8 5a2.5 2.5 0 0 1 3.48-2.3m-.28 8.551a3 3 0 0 1-2.953-5.185M20 10.5a2.5 2.5 0 0 0-3.481-2.3m.28 8.551a3 3 0 0 0 2.954-5.185"></path></svg>`), BrainOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BrainOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BrainOutline);
  validate_prop_bindings($$props, [], [], BrainOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "brain outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root77();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_177();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_277();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BrainOutline = hmr(BrainOutline, () => BrainOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BrainOutline[HMR].source;
    set(BrainOutline[HMR].source, module.default[HMR].original);
  });
}
var BrainOutline_default = BrainOutline;
mark_module_end(BrainOutline);

// node_modules/flowbite-svelte-icons/dist/BrainSolid.svelte
mark_module_start();
BrainSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BrainSolid.svelte";
var root_178 = add_locations(ns_template(`<title> </title>`), BrainSolid[FILENAME], [[39, 4]]);
var root_278 = add_locations(ns_template(`<desc> </desc>`), BrainSolid[FILENAME], [[42, 4]]);
var root78 = add_locations(ns_template(`<svg><!><!><path d="M11 21V2.352A3.451 3.451 0 0 0 9.5 2a3.5 3.5 0 0 0-3.261 2.238A3.5 3.5 0 0 0 4.04 8.015a3.518 3.518 0 0 0-.766 1.128c-.042.1-.064.209-.1.313a3.34 3.34 0 0 0-.106.344 3.463 3.463 0 0 0 .02 1.468A4.017 4.017 0 0 0 2.3 12.5l-.015.036a3.861 3.861 0 0 0-.216.779A3.968 3.968 0 0 0 2 14c.003.24.027.48.072.716a4 4 0 0 0 .235.832c.006.014.015.027.021.041a3.85 3.85 0 0 0 .417.727c.105.146.219.285.342.415.072.076.148.146.225.216.1.091.205.179.315.26.11.081.2.14.308.2.02.013.039.028.059.04v.053a3.506 3.506 0 0 0 3.03 3.469 3.426 3.426 0 0 0 4.154.577A.972.972 0 0 1 11 21Zm10.934-7.68a3.956 3.956 0 0 0-.215-.779l-.017-.038a4.016 4.016 0 0 0-.79-1.235 3.417 3.417 0 0 0 .017-1.468 3.387 3.387 0 0 0-.1-.333c-.034-.108-.057-.22-.1-.324a3.517 3.517 0 0 0-.766-1.128 3.5 3.5 0 0 0-2.202-3.777A3.5 3.5 0 0 0 14.5 2a3.451 3.451 0 0 0-1.5.352V21a.972.972 0 0 1-.184.546 3.426 3.426 0 0 0 4.154-.577A3.506 3.506 0 0 0 20 17.5v-.049c.02-.012.039-.027.059-.04.106-.064.208-.13.308-.2s.214-.169.315-.26c.077-.07.153-.14.225-.216a4.007 4.007 0 0 0 .459-.588c.115-.176.215-.361.3-.554.006-.014.015-.027.021-.041.087-.213.156-.434.205-.659.013-.057.024-.115.035-.173.046-.237.07-.478.073-.72a3.948 3.948 0 0 0-.066-.68Z"></path></svg>`), BrainSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BrainSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BrainSolid);
  validate_prop_bindings($$props, [], [], BrainSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "brain solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root78();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_178();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_278();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BrainSolid = hmr(BrainSolid, () => BrainSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BrainSolid[HMR].source;
    set(BrainSolid[HMR].source, module.default[HMR].original);
  });
}
var BrainSolid_default = BrainSolid;
mark_module_end(BrainSolid);

// node_modules/flowbite-svelte-icons/dist/BriefcaseOutline.svelte
mark_module_start();
BriefcaseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BriefcaseOutline.svelte";
var root_179 = add_locations(ns_template(`<title> </title>`), BriefcaseOutline[FILENAME], [[41, 4]]);
var root_279 = add_locations(ns_template(`<desc> </desc>`), BriefcaseOutline[FILENAME], [[44, 4]]);
var root79 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 7H5a2 2 0 0 0-2 2v4m5-6h8M8 7V5a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m0 0h3a2 2 0 0 1 2 2v4m0 0v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-6m18 0s-4 2-9 2-9-2-9-2m9-2h.01"></path></svg>`), BriefcaseOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BriefcaseOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BriefcaseOutline);
  validate_prop_bindings($$props, [], [], BriefcaseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "briefcase outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root79();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_179();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_279();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BriefcaseOutline = hmr(BriefcaseOutline, () => BriefcaseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BriefcaseOutline[HMR].source;
    set(BriefcaseOutline[HMR].source, module.default[HMR].original);
  });
}
var BriefcaseOutline_default = BriefcaseOutline;
mark_module_end(BriefcaseOutline);

// node_modules/flowbite-svelte-icons/dist/BriefcaseSolid.svelte
mark_module_start();
BriefcaseSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BriefcaseSolid.svelte";
var root_180 = add_locations(ns_template(`<title> </title>`), BriefcaseSolid[FILENAME], [[39, 4]]);
var root_280 = add_locations(ns_template(`<desc> </desc>`), BriefcaseSolid[FILENAME], [[42, 4]]);
var root80 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M10 2a3 3 0 0 0-3 3v1H5a3 3 0 0 0-3 3v2.382l1.447.723.005.003.027.013.12.056c.108.05.272.123.486.212.429.177 1.056.416 1.834.655C7.481 13.524 9.63 14 12 14c2.372 0 4.52-.475 6.08-.956.78-.24 1.406-.478 1.835-.655a14.028 14.028 0 0 0 .606-.268l.027-.013.005-.002L22 11.381V9a3 3 0 0 0-3-3h-2V5a3 3 0 0 0-3-3h-4Zm5 4V5a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v1h6Zm6.447 7.894.553-.276V19a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3v-5.382l.553.276.002.002.004.002.013.006.041.02.151.07c.13.06.318.144.557.242.478.198 1.163.46 2.01.72C7.019 15.476 9.37 16 12 16c2.628 0 4.98-.525 6.67-1.044a22.95 22.95 0 0 0 2.01-.72 15.994 15.994 0 0 0 .707-.312l.041-.02.013-.006.004-.002.001-.001-.431-.866.432.865ZM12 10a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z" clip-rule="evenodd"></path></svg>`), BriefcaseSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BriefcaseSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BriefcaseSolid);
  validate_prop_bindings($$props, [], [], BriefcaseSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "briefcase solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root80();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_180();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_280();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BriefcaseSolid = hmr(BriefcaseSolid, () => BriefcaseSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BriefcaseSolid[HMR].source;
    set(BriefcaseSolid[HMR].source, module.default[HMR].original);
  });
}
var BriefcaseSolid_default = BriefcaseSolid;
mark_module_end(BriefcaseSolid);

// node_modules/flowbite-svelte-icons/dist/BugOutline.svelte
mark_module_start();
BugOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BugOutline.svelte";
var root_181 = add_locations(ns_template(`<title> </title>`), BugOutline[FILENAME], [[41, 4]]);
var root_281 = add_locations(ns_template(`<desc> </desc>`), BugOutline[FILENAME], [[44, 4]]);
var root81 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 5 9 4V3m5 2 1-1V3m-3 6v11m0-11a5 5 0 0 1 5 5m-5-5a5 5 0 0 0-5 5m5-5a4.959 4.959 0 0 1 2.973 1H15V8a3 3 0 0 0-6 0v2h.027A4.959 4.959 0 0 1 12 9Zm-5 5H5m2 0v2a5 5 0 0 0 10 0v-2m2.025 0H17m-9.975 4H6a1 1 0 0 0-1 1v2m12-3h1.025a1 1 0 0 1 1 1v2M16 11h1a1 1 0 0 0 1-1V8m-9.975 3H7a1 1 0 0 1-1-1V8"></path></svg>`), BugOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BugOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BugOutline);
  validate_prop_bindings($$props, [], [], BugOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bug outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root81();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_181();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_281();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BugOutline = hmr(BugOutline, () => BugOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BugOutline[HMR].source;
    set(BugOutline[HMR].source, module.default[HMR].original);
  });
}
var BugOutline_default = BugOutline;
mark_module_end(BugOutline);

// node_modules/flowbite-svelte-icons/dist/BugSolid.svelte
mark_module_start();
BugSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BugSolid.svelte";
var root_182 = add_locations(ns_template(`<title> </title>`), BugSolid[FILENAME], [[39, 4]]);
var root_282 = add_locations(ns_template(`<desc> </desc>`), BugSolid[FILENAME], [[42, 4]]);
var root82 = add_locations(ns_template(`<svg><!><!><path d="M18 17h-.09c.058-.33.088-.665.09-1v-1h1a1 1 0 0 0 0-2h-1.09a5.97 5.97 0 0 0-.26-1H17a2 2 0 0 0 2-2V8a1 1 0 1 0-2 0v2h-.54a6.239 6.239 0 0 0-.46-.46V8a3.963 3.963 0 0 0-.986-2.6l.693-.693A1 1 0 0 0 16 4V3a1 1 0 1 0-2 0v.586l-.661.661a3.753 3.753 0 0 0-2.678 0L10 3.586V3a1 1 0 1 0-2 0v1a1 1 0 0 0 .293.707l.693.693A3.963 3.963 0 0 0 8 8v1.54a6.239 6.239 0 0 0-.46.46H7V8a1 1 0 0 0-2 0v2a2 2 0 0 0 2 2h-.65a5.97 5.97 0 0 0-.26 1H5a1 1 0 0 0 0 2h1v1a6 6 0 0 0 .09 1H6a2 2 0 0 0-2 2v2a1 1 0 1 0 2 0v-2h.812A6.012 6.012 0 0 0 11 21.907V12a1 1 0 0 1 2 0v9.907A6.011 6.011 0 0 0 17.188 19H18v2a1 1 0 0 0 2 0v-2a2 2 0 0 0-2-2Zm-4-8.65a5.922 5.922 0 0 0-.941-.251l-.111-.017a5.52 5.52 0 0 0-1.9 0l-.111.017A5.925 5.925 0 0 0 10 8.35V8a2 2 0 1 1 4 0v.35Z"></path></svg>`), BugSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BugSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BugSolid);
  validate_prop_bindings($$props, [], [], BugSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "bug solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root82();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_182();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_282();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BugSolid = hmr(BugSolid, () => BugSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BugSolid[HMR].source;
    set(BugSolid[HMR].source, module.default[HMR].original);
  });
}
var BugSolid_default = BugSolid;
mark_module_end(BugSolid);

// node_modules/flowbite-svelte-icons/dist/BuildingOutline.svelte
mark_module_start();
BuildingOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BuildingOutline.svelte";
var root_183 = add_locations(ns_template(`<title> </title>`), BuildingOutline[FILENAME], [[41, 4]]);
var root_283 = add_locations(ns_template(`<desc> </desc>`), BuildingOutline[FILENAME], [[44, 4]]);
var root83 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 4h12M6 4v16M6 4H5m13 0v16m0-16h1m-1 16H6m12 0h1M6 20H5M9 7h1v1H9V7Zm5 0h1v1h-1V7Zm-5 4h1v1H9v-1Zm5 0h1v1h-1v-1Zm-3 4h2a1 1 0 0 1 1 1v4h-4v-4a1 1 0 0 1 1-1Z"></path></svg>`), BuildingOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BuildingOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BuildingOutline);
  validate_prop_bindings($$props, [], [], BuildingOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "building outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root83();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_183();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_283();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BuildingOutline = hmr(BuildingOutline, () => BuildingOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BuildingOutline[HMR].source;
    set(BuildingOutline[HMR].source, module.default[HMR].original);
  });
}
var BuildingOutline_default = BuildingOutline;
mark_module_end(BuildingOutline);

// node_modules/flowbite-svelte-icons/dist/BuildingSolid.svelte
mark_module_start();
BuildingSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BuildingSolid.svelte";
var root_184 = add_locations(ns_template(`<title> </title>`), BuildingSolid[FILENAME], [[39, 4]]);
var root_284 = add_locations(ns_template(`<desc> </desc>`), BuildingSolid[FILENAME], [[42, 4]]);
var root84 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 4a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2v14a1 1 0 1 1 0 2H5a1 1 0 1 1 0-2V5a1 1 0 0 1-1-1Zm5 2a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H9Zm5 0a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1h-1Zm-5 4a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1v-1a1 1 0 0 0-1-1H9Zm5 0a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1v-1a1 1 0 0 0-1-1h-1Zm-3 4a2 2 0 0 0-2 2v3h2v-3h2v3h2v-3a2 2 0 0 0-2-2h-2Z" clip-rule="evenodd"></path></svg>`), BuildingSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BuildingSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BuildingSolid);
  validate_prop_bindings($$props, [], [], BuildingSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "building solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root84();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_184();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_284();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BuildingSolid = hmr(BuildingSolid, () => BuildingSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BuildingSolid[HMR].source;
    set(BuildingSolid[HMR].source, module.default[HMR].original);
  });
}
var BuildingSolid_default = BuildingSolid;
mark_module_end(BuildingSolid);

// node_modules/flowbite-svelte-icons/dist/BullhornOutline.svelte
mark_module_start();
BullhornOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BullhornOutline.svelte";
var root_185 = add_locations(ns_template(`<title> </title>`), BullhornOutline[FILENAME], [[41, 4]]);
var root_285 = add_locations(ns_template(`<desc> </desc>`), BullhornOutline[FILENAME], [[44, 4]]);
var root85 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 9H5a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h6m0-6v6m0-6 5.419-3.87A1 1 0 0 1 18 5.942v12.114a1 1 0 0 1-1.581.814L11 15m7 0a3 3 0 0 0 0-6M6 15h3v5H6v-5Z"></path></svg>`), BullhornOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function BullhornOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BullhornOutline);
  validate_prop_bindings($$props, [], [], BullhornOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "bullhorn outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root85();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_185();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_285();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BullhornOutline = hmr(BullhornOutline, () => BullhornOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BullhornOutline[HMR].source;
    set(BullhornOutline[HMR].source, module.default[HMR].original);
  });
}
var BullhornOutline_default = BullhornOutline;
mark_module_end(BullhornOutline);

// node_modules/flowbite-svelte-icons/dist/BullhornSolid.svelte
mark_module_start();
BullhornSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/BullhornSolid.svelte";
var root_186 = add_locations(ns_template(`<title> </title>`), BullhornSolid[FILENAME], [[39, 4]]);
var root_286 = add_locations(ns_template(`<desc> </desc>`), BullhornSolid[FILENAME], [[42, 4]]);
var root86 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M18.458 3.11A1 1 0 0 1 19 4v16a1 1 0 0 1-1.581.814L12 16.944V7.056l5.419-3.87a1 1 0 0 1 1.039-.076ZM22 12c0 1.48-.804 2.773-2 3.465v-6.93c1.196.692 2 1.984 2 3.465ZM10 8H4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h6V8Zm0 9H5v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-3Z" clip-rule="evenodd"></path></svg>`), BullhornSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function BullhornSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, BullhornSolid);
  validate_prop_bindings($$props, [], [], BullhornSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "bullhorn solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root86();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_186();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_286();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  BullhornSolid = hmr(BullhornSolid, () => BullhornSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = BullhornSolid[HMR].source;
    set(BullhornSolid[HMR].source, module.default[HMR].original);
  });
}
var BullhornSolid_default = BullhornSolid;
mark_module_end(BullhornSolid);

// node_modules/flowbite-svelte-icons/dist/CalendarEditOutline.svelte
mark_module_start();
CalendarEditOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarEditOutline.svelte";
var root_187 = add_locations(ns_template(`<title> </title>`), CalendarEditOutline[FILENAME], [[41, 4]]);
var root_287 = add_locations(ns_template(`<desc> </desc>`), CalendarEditOutline[FILENAME], [[44, 4]]);
var root87 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m11.5 11.5 2.071 1.994M4 10h5m11 0h-1.5M12 7V4M7 7V4m10 3V4m-7 13H8v-2l5.227-5.292a1.46 1.46 0 0 1 2.065 2.065L10 17Zm-5 3h14a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), CalendarEditOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CalendarEditOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CalendarEditOutline);
  validate_prop_bindings($$props, [], [], CalendarEditOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "calendar edit outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root87();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_187();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_287();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CalendarEditOutline = hmr(CalendarEditOutline, () => CalendarEditOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarEditOutline[HMR].source;
    set(CalendarEditOutline[HMR].source, module.default[HMR].original);
  });
}
var CalendarEditOutline_default = CalendarEditOutline;
mark_module_end(CalendarEditOutline);

// node_modules/flowbite-svelte-icons/dist/CalendarEditSolid.svelte
mark_module_start();
CalendarEditSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarEditSolid.svelte";
var root_188 = add_locations(ns_template(`<title> </title>`), CalendarEditSolid[FILENAME], [[39, 4]]);
var root_288 = add_locations(ns_template(`<desc> </desc>`), CalendarEditSolid[FILENAME], [[42, 4]]);
var root88 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12.512 8.72a2.46 2.46 0 0 1 3.479 0 2.461 2.461 0 0 1 0 3.479l-.004.005-1.094 1.08a.998.998 0 0 0-.194-.272l-3-3a1 1 0 0 0-.272-.193l1.085-1.1Zm-2.415 2.445L7.28 14.017a1 1 0 0 0-.289.702v2a1 1 0 0 0 1 1h2a1 1 0 0 0 .703-.288l2.851-2.816a.995.995 0 0 1-.26-.189l-3-3a.998.998 0 0 1-.19-.26Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M7 3a1 1 0 0 1 1 1v1h3V4a1 1 0 1 1 2 0v1h3V4a1 1 0 1 1 2 0v1h1a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h1V4a1 1 0 0 1 1-1Zm10.67 8H19v8H5v-8h3.855l.53-.537a1 1 0 0 1 .87-.285c.097.015.233.13.277.087.045-.043-.073-.18-.09-.276a1 1 0 0 1 .274-.873l1.09-1.104a3.46 3.46 0 0 1 4.892 0l.001.002A3.461 3.461 0 0 1 17.67 11Z" clip-rule="evenodd"></path></svg>`), CalendarEditSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function CalendarEditSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CalendarEditSolid);
  validate_prop_bindings($$props, [], [], CalendarEditSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "calendar edit solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root88();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_188();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_288();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CalendarEditSolid = hmr(CalendarEditSolid, () => CalendarEditSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarEditSolid[HMR].source;
    set(CalendarEditSolid[HMR].source, module.default[HMR].original);
  });
}
var CalendarEditSolid_default = CalendarEditSolid;
mark_module_end(CalendarEditSolid);

// node_modules/flowbite-svelte-icons/dist/CalendarMonthOutline.svelte
mark_module_start();
CalendarMonthOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarMonthOutline.svelte";
var root_189 = add_locations(ns_template(`<title> </title>`), CalendarMonthOutline[FILENAME], [[41, 4]]);
var root_289 = add_locations(ns_template(`<desc> </desc>`), CalendarMonthOutline[FILENAME], [[44, 4]]);
var root89 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 10h16m-8-3V4M7 7V4m10 3V4M5 20h14a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Zm3-7h.01v.01H8V13Zm4 0h.01v.01H12V13Zm4 0h.01v.01H16V13Zm-8 4h.01v.01H8V17Zm4 0h.01v.01H12V17Zm4 0h.01v.01H16V17Z"></path></svg>`), CalendarMonthOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CalendarMonthOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CalendarMonthOutline);
  validate_prop_bindings($$props, [], [], CalendarMonthOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "calendar month outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root89();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_189();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_289();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CalendarMonthOutline = hmr(CalendarMonthOutline, () => CalendarMonthOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarMonthOutline[HMR].source;
    set(CalendarMonthOutline[HMR].source, module.default[HMR].original);
  });
}
var CalendarMonthOutline_default = CalendarMonthOutline;
mark_module_end(CalendarMonthOutline);

// node_modules/flowbite-svelte-icons/dist/CalendarMonthSolid.svelte
mark_module_start();
CalendarMonthSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarMonthSolid.svelte";
var root_190 = add_locations(ns_template(`<title> </title>`), CalendarMonthSolid[FILENAME], [[39, 4]]);
var root_290 = add_locations(ns_template(`<desc> </desc>`), CalendarMonthSolid[FILENAME], [[42, 4]]);
var root90 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 5a1 1 0 0 0 1-1 1 1 0 1 1 2 0 1 1 0 0 0 1 1h1a1 1 0 0 0 1-1 1 1 0 1 1 2 0 1 1 0 0 0 1 1h1a1 1 0 0 0 1-1 1 1 0 1 1 2 0 1 1 0 0 0 1 1 2 2 0 0 1 2 2v1a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V7a2 2 0 0 1 2-2ZM3 19v-7a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm6.01-6a1 1 0 1 0-2 0 1 1 0 0 0 2 0Zm2 0a1 1 0 1 1 2 0 1 1 0 0 1-2 0Zm6 0a1 1 0 1 0-2 0 1 1 0 0 0 2 0Zm-10 4a1 1 0 1 1 2 0 1 1 0 0 1-2 0Zm6 0a1 1 0 1 0-2 0 1 1 0 0 0 2 0Zm2 0a1 1 0 1 1 2 0 1 1 0 0 1-2 0Z" clip-rule="evenodd"></path></svg>`), CalendarMonthSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CalendarMonthSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CalendarMonthSolid);
  validate_prop_bindings($$props, [], [], CalendarMonthSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "calendar month solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root90();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_190();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_290();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CalendarMonthSolid = hmr(CalendarMonthSolid, () => CalendarMonthSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarMonthSolid[HMR].source;
    set(CalendarMonthSolid[HMR].source, module.default[HMR].original);
  });
}
var CalendarMonthSolid_default = CalendarMonthSolid;
mark_module_end(CalendarMonthSolid);

// node_modules/flowbite-svelte-icons/dist/CalendarPlusOutline.svelte
mark_module_start();
CalendarPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarPlusOutline.svelte";
var root_191 = add_locations(ns_template(`<title> </title>`), CalendarPlusOutline[FILENAME], [[40, 4]]);
var root_291 = add_locations(ns_template(`<desc> </desc>`), CalendarPlusOutline[FILENAME], [[43, 4]]);
var root91 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M4 9.05H3v2h1v-2Zm16 2h1v-2h-1v2ZM10 14a1 1 0 1 0 0 2v-2Zm4 2a1 1 0 1 0 0-2v2Zm-3 1a1 1 0 1 0 2 0h-2Zm2-4a1 1 0 1 0-2 0h2Zm-2-5.95a1 1 0 1 0 2 0h-2Zm2-3a1 1 0 1 0-2 0h2Zm-7 3a1 1 0 0 0 2 0H6Zm2-3a1 1 0 1 0-2 0h2Zm8 3a1 1 0 1 0 2 0h-2Zm2-3a1 1 0 1 0-2 0h2Zm-13 3h14v-2H5v2Zm14 0v12h2v-12h-2Zm0 12H5v2h14v-2Zm-14 0v-12H3v12h2Zm0 0H3a2 2 0 0 0 2 2v-2Zm14 0v2a2 2 0 0 0 2-2h-2Zm0-12h2a2 2 0 0 0-2-2v2Zm-14-2a2 2 0 0 0-2 2h2v-2Zm-1 6h16v-2H4v2ZM10 16h4v-2h-4v2Zm3 1v-4h-2v4h2Zm0-9.95v-3h-2v3h2Zm-5 0v-3H6v3h2Zm10 0v-3h-2v3h2Z"></path></svg>`), CalendarPlusOutline[FILENAME], [[29, 0, [[45, 2]]]]);
function CalendarPlusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CalendarPlusOutline);
  validate_prop_bindings($$props, [], [], CalendarPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "calendar plus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root91();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_191();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_291();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CalendarPlusOutline = hmr(CalendarPlusOutline, () => CalendarPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarPlusOutline[HMR].source;
    set(CalendarPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var CalendarPlusOutline_default = CalendarPlusOutline;
mark_module_end(CalendarPlusOutline);

// node_modules/flowbite-svelte-icons/dist/CalendarPlusSolid.svelte
mark_module_start();
CalendarPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarPlusSolid.svelte";
var root_192 = add_locations(ns_template(`<title> </title>`), CalendarPlusSolid[FILENAME], [[39, 4]]);
var root_292 = add_locations(ns_template(`<desc> </desc>`), CalendarPlusSolid[FILENAME], [[42, 4]]);
var root92 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M18 5.05h1a2 2 0 0 1 2 2v2H3v-2a2 2 0 0 1 2-2h1v-1a1 1 0 1 1 2 0v1h3v-1a1 1 0 1 1 2 0v1h3v-1a1 1 0 1 1 2 0v1Zm-15 6v8a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-8H3ZM11 18a1 1 0 1 0 2 0v-1h1a1 1 0 1 0 0-2h-1v-1a1 1 0 1 0-2 0v1h-1a1 1 0 1 0 0 2h1v1Z" clip-rule="evenodd"></path></svg>`), CalendarPlusSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CalendarPlusSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CalendarPlusSolid);
  validate_prop_bindings($$props, [], [], CalendarPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "calendar plus solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root92();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_192();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_292();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CalendarPlusSolid = hmr(CalendarPlusSolid, () => CalendarPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarPlusSolid[HMR].source;
    set(CalendarPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var CalendarPlusSolid_default = CalendarPlusSolid;
mark_module_end(CalendarPlusSolid);

// node_modules/flowbite-svelte-icons/dist/CalendarWeekOutline.svelte
mark_module_start();
CalendarWeekOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarWeekOutline.svelte";
var root_193 = add_locations(ns_template(`<title> </title>`), CalendarWeekOutline[FILENAME], [[41, 4]]);
var root_293 = add_locations(ns_template(`<desc> </desc>`), CalendarWeekOutline[FILENAME], [[44, 4]]);
var root93 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 10h16M8 14h8m-4-7V4M7 7V4m10 3V4M5 20h14a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), CalendarWeekOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CalendarWeekOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CalendarWeekOutline);
  validate_prop_bindings($$props, [], [], CalendarWeekOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "calendar week outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root93();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_193();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_293();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CalendarWeekOutline = hmr(CalendarWeekOutline, () => CalendarWeekOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarWeekOutline[HMR].source;
    set(CalendarWeekOutline[HMR].source, module.default[HMR].original);
  });
}
var CalendarWeekOutline_default = CalendarWeekOutline;
mark_module_end(CalendarWeekOutline);

// node_modules/flowbite-svelte-icons/dist/CalendarWeekSolid.svelte
mark_module_start();
CalendarWeekSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CalendarWeekSolid.svelte";
var root_194 = add_locations(ns_template(`<title> </title>`), CalendarWeekSolid[FILENAME], [[39, 4]]);
var root_294 = add_locations(ns_template(`<desc> </desc>`), CalendarWeekSolid[FILENAME], [[42, 4]]);
var root94 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M6 5V4a1 1 0 1 1 2 0v1h3V4a1 1 0 1 1 2 0v1h3V4a1 1 0 1 1 2 0v1h1a2 2 0 0 1 2 2v2H3V7a2 2 0 0 1 2-2h1ZM3 19v-8h18v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm5-6a1 1 0 1 0 0 2h8a1 1 0 1 0 0-2H8Z" clip-rule="evenodd"></path></svg>`), CalendarWeekSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CalendarWeekSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CalendarWeekSolid);
  validate_prop_bindings($$props, [], [], CalendarWeekSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "calendar week solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root94();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_194();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_294();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CalendarWeekSolid = hmr(CalendarWeekSolid, () => CalendarWeekSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CalendarWeekSolid[HMR].source;
    set(CalendarWeekSolid[HMR].source, module.default[HMR].original);
  });
}
var CalendarWeekSolid_default = CalendarWeekSolid;
mark_module_end(CalendarWeekSolid);

// node_modules/flowbite-svelte-icons/dist/CameraPhotoOutline.svelte
mark_module_start();
CameraPhotoOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CameraPhotoOutline.svelte";
var root_195 = add_locations(ns_template(`<title> </title>`), CameraPhotoOutline[FILENAME], [[41, 4]]);
var root_295 = add_locations(ns_template(`<desc> </desc>`), CameraPhotoOutline[FILENAME], [[44, 4]]);
var root95 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M4 18V8a1 1 0 0 1 1-1h1.5l1.707-1.707A1 1 0 0 1 8.914 5h6.172a1 1 0 0 1 .707.293L17.5 7H19a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), CameraPhotoOutline[FILENAME], [
  [30, 0, [[46, 2], [52, 2]]]
]);
function CameraPhotoOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CameraPhotoOutline);
  validate_prop_bindings($$props, [], [], CameraPhotoOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "camera photo outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root95();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_195();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_295();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CameraPhotoOutline = hmr(CameraPhotoOutline, () => CameraPhotoOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CameraPhotoOutline[HMR].source;
    set(CameraPhotoOutline[HMR].source, module.default[HMR].original);
  });
}
var CameraPhotoOutline_default = CameraPhotoOutline;
mark_module_end(CameraPhotoOutline);

// node_modules/flowbite-svelte-icons/dist/CameraPhotoSolid.svelte
mark_module_start();
CameraPhotoSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CameraPhotoSolid.svelte";
var root_196 = add_locations(ns_template(`<title> </title>`), CameraPhotoSolid[FILENAME], [[39, 4]]);
var root_296 = add_locations(ns_template(`<desc> </desc>`), CameraPhotoSolid[FILENAME], [[42, 4]]);
var root96 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M7.5 4.586A2 2 0 0 1 8.914 4h6.172a2 2 0 0 1 1.414.586L17.914 6H19a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h1.086L7.5 4.586ZM10 12a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm2-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z" clip-rule="evenodd"></path></svg>`), CameraPhotoSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CameraPhotoSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CameraPhotoSolid);
  validate_prop_bindings($$props, [], [], CameraPhotoSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "camera photo solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root96();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_196();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_296();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CameraPhotoSolid = hmr(CameraPhotoSolid, () => CameraPhotoSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CameraPhotoSolid[HMR].source;
    set(CameraPhotoSolid[HMR].source, module.default[HMR].original);
  });
}
var CameraPhotoSolid_default = CameraPhotoSolid;
mark_module_end(CameraPhotoSolid);

// node_modules/flowbite-svelte-icons/dist/CaptionOutline.svelte
mark_module_start();
CaptionOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaptionOutline.svelte";
var root_197 = add_locations(ns_template(`<title> </title>`), CaptionOutline[FILENAME], [[41, 4]]);
var root_297 = add_locations(ns_template(`<desc> </desc>`), CaptionOutline[FILENAME], [[44, 4]]);
var root97 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10.855 14.322a2.475 2.475 0 1 1 .133-4.241m6.053 4.241a2.475 2.475 0 1 1 .133-4.241M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), CaptionOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CaptionOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaptionOutline);
  validate_prop_bindings($$props, [], [], CaptionOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "caption outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root97();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_197();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_297();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaptionOutline = hmr(CaptionOutline, () => CaptionOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaptionOutline[HMR].source;
    set(CaptionOutline[HMR].source, module.default[HMR].original);
  });
}
var CaptionOutline_default = CaptionOutline;
mark_module_end(CaptionOutline);

// node_modules/flowbite-svelte-icons/dist/CaptionSolid.svelte
mark_module_start();
CaptionSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaptionSolid.svelte";
var root_198 = add_locations(ns_template(`<title> </title>`), CaptionSolid[FILENAME], [[39, 4]]);
var root_298 = add_locations(ns_template(`<desc> </desc>`), CaptionSolid[FILENAME], [[42, 4]]);
var root98 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6Zm6.962 4.856a1.475 1.475 0 0 1 1.484.066A1 1 0 1 0 11.53 9.24a3.475 3.475 0 1 0-.187 5.955 1 1 0 1 0-.976-1.746 1.474 1.474 0 1 1-1.405-2.593Zm6.186 0a1.475 1.475 0 0 1 1.484.066 1 1 0 1 0 1.084-1.682 3.475 3.475 0 1 0-.187 5.955 1 1 0 1 0-.976-1.746 1.474 1.474 0 1 1-1.405-2.593Z" clip-rule="evenodd"></path></svg>`), CaptionSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CaptionSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaptionSolid);
  validate_prop_bindings($$props, [], [], CaptionSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "caption solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root98();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_198();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_298();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaptionSolid = hmr(CaptionSolid, () => CaptionSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaptionSolid[HMR].source;
    set(CaptionSolid[HMR].source, module.default[HMR].original);
  });
}
var CaptionSolid_default = CaptionSolid;
mark_module_end(CaptionSolid);

// node_modules/flowbite-svelte-icons/dist/CaretDownOutline.svelte
mark_module_start();
CaretDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretDownOutline.svelte";
var root_199 = add_locations(ns_template(`<title> </title>`), CaretDownOutline[FILENAME], [[41, 4]]);
var root_299 = add_locations(ns_template(`<desc> </desc>`), CaretDownOutline[FILENAME], [[44, 4]]);
var root99 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.119 8h9.762a1 1 0 0 1 .772 1.636l-4.881 5.927a1 1 0 0 1-1.544 0l-4.88-5.927A1 1 0 0 1 7.118 8Z"></path></svg>`), CaretDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretDownOutline);
  validate_prop_bindings($$props, [], [], CaretDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "caret down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root99();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_199();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_299();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretDownOutline = hmr(CaretDownOutline, () => CaretDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretDownOutline[HMR].source;
    set(CaretDownOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretDownOutline_default = CaretDownOutline;
mark_module_end(CaretDownOutline);

// node_modules/flowbite-svelte-icons/dist/CaretDownSolid.svelte
mark_module_start();
CaretDownSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretDownSolid.svelte";
var root_1100 = add_locations(ns_template(`<title> </title>`), CaretDownSolid[FILENAME], [[39, 4]]);
var root_2100 = add_locations(ns_template(`<desc> </desc>`), CaretDownSolid[FILENAME], [[42, 4]]);
var root100 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M18.425 10.271C19.499 8.967 18.57 7 16.88 7H7.12c-1.69 0-2.618 1.967-1.544 3.271l4.881 5.927a2 2 0 0 0 3.088 0l4.88-5.927Z" clip-rule="evenodd"></path></svg>`), CaretDownSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CaretDownSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretDownSolid);
  validate_prop_bindings($$props, [], [], CaretDownSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "caret down solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root100();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1100();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2100();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretDownSolid = hmr(CaretDownSolid, () => CaretDownSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretDownSolid[HMR].source;
    set(CaretDownSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretDownSolid_default = CaretDownSolid;
mark_module_end(CaretDownSolid);

// node_modules/flowbite-svelte-icons/dist/CaretLeftOutline.svelte
mark_module_start();
CaretLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretLeftOutline.svelte";
var root_1101 = add_locations(ns_template(`<title> </title>`), CaretLeftOutline[FILENAME], [[41, 4]]);
var root_2101 = add_locations(ns_template(`<desc> </desc>`), CaretLeftOutline[FILENAME], [[44, 4]]);
var root101 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 16.881V7.119a1 1 0 0 0-1.636-.772l-5.927 4.881a1 1 0 0 0 0 1.544l5.927 4.88a1 1 0 0 0 1.636-.77Z"></path></svg>`), CaretLeftOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretLeftOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretLeftOutline);
  validate_prop_bindings($$props, [], [], CaretLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "caret left outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root101();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1101();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2101();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretLeftOutline = hmr(CaretLeftOutline, () => CaretLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretLeftOutline[HMR].source;
    set(CaretLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretLeftOutline_default = CaretLeftOutline;
mark_module_end(CaretLeftOutline);

// node_modules/flowbite-svelte-icons/dist/CaretLeftSolid.svelte
mark_module_start();
CaretLeftSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretLeftSolid.svelte";
var root_1102 = add_locations(ns_template(`<title> </title>`), CaretLeftSolid[FILENAME], [[39, 4]]);
var root_2102 = add_locations(ns_template(`<desc> </desc>`), CaretLeftSolid[FILENAME], [[42, 4]]);
var root102 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M13.729 5.575c1.304-1.074 3.27-.146 3.27 1.544v9.762c0 1.69-1.966 2.618-3.27 1.544l-5.927-4.881a2 2 0 0 1 0-3.088l5.927-4.88Z" clip-rule="evenodd"></path></svg>`), CaretLeftSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CaretLeftSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretLeftSolid);
  validate_prop_bindings($$props, [], [], CaretLeftSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "caret left solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root102();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1102();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2102();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretLeftSolid = hmr(CaretLeftSolid, () => CaretLeftSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretLeftSolid[HMR].source;
    set(CaretLeftSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretLeftSolid_default = CaretLeftSolid;
mark_module_end(CaretLeftSolid);

// node_modules/flowbite-svelte-icons/dist/CaretRightOutline.svelte
mark_module_start();
CaretRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretRightOutline.svelte";
var root_1103 = add_locations(ns_template(`<title> </title>`), CaretRightOutline[FILENAME], [[41, 4]]);
var root_2103 = add_locations(ns_template(`<desc> </desc>`), CaretRightOutline[FILENAME], [[44, 4]]);
var root103 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 16.881V7.119a1 1 0 0 1 1.636-.772l5.927 4.881a1 1 0 0 1 0 1.544l-5.927 4.88A1 1 0 0 1 8 16.882Z"></path></svg>`), CaretRightOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretRightOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretRightOutline);
  validate_prop_bindings($$props, [], [], CaretRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "caret right outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root103();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1103();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2103();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretRightOutline = hmr(CaretRightOutline, () => CaretRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretRightOutline[HMR].source;
    set(CaretRightOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretRightOutline_default = CaretRightOutline;
mark_module_end(CaretRightOutline);

// node_modules/flowbite-svelte-icons/dist/CaretRightSolid.svelte
mark_module_start();
CaretRightSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretRightSolid.svelte";
var root_1104 = add_locations(ns_template(`<title> </title>`), CaretRightSolid[FILENAME], [[39, 4]]);
var root_2104 = add_locations(ns_template(`<desc> </desc>`), CaretRightSolid[FILENAME], [[42, 4]]);
var root104 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M10.271 5.575C8.967 4.501 7 5.43 7 7.12v9.762c0 1.69 1.967 2.618 3.271 1.544l5.927-4.881a2 2 0 0 0 0-3.088l-5.927-4.88Z" clip-rule="evenodd"></path></svg>`), CaretRightSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CaretRightSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretRightSolid);
  validate_prop_bindings($$props, [], [], CaretRightSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "caret right solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root104();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1104();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2104();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretRightSolid = hmr(CaretRightSolid, () => CaretRightSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretRightSolid[HMR].source;
    set(CaretRightSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretRightSolid_default = CaretRightSolid;
mark_module_end(CaretRightSolid);

// node_modules/flowbite-svelte-icons/dist/CaretSortOutline.svelte
mark_module_start();
CaretSortOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretSortOutline.svelte";
var root_1105 = add_locations(ns_template(`<title> </title>`), CaretSortOutline[FILENAME], [[41, 4]]);
var root_2105 = add_locations(ns_template(`<desc> </desc>`), CaretSortOutline[FILENAME], [[44, 4]]);
var root105 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 10 4-6 4 6H8Zm8 4-4 6-4-6h8Z"></path></svg>`), CaretSortOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretSortOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretSortOutline);
  validate_prop_bindings($$props, [], [], CaretSortOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "caret sort outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root105();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1105();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2105();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretSortOutline = hmr(CaretSortOutline, () => CaretSortOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretSortOutline[HMR].source;
    set(CaretSortOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretSortOutline_default = CaretSortOutline;
mark_module_end(CaretSortOutline);

// node_modules/flowbite-svelte-icons/dist/CaretSortSolid.svelte
mark_module_start();
CaretSortSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretSortSolid.svelte";
var root_1106 = add_locations(ns_template(`<title> </title>`), CaretSortSolid[FILENAME], [[39, 4]]);
var root_2106 = add_locations(ns_template(`<desc> </desc>`), CaretSortSolid[FILENAME], [[42, 4]]);
var root106 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12.832 3.445a1 1 0 0 0-1.664 0l-4 6A1 1 0 0 0 8 11h8a1 1 0 0 0 .832-1.555l-4-6Zm-1.664 17.11a1 1 0 0 0 1.664 0l4-6A1 1 0 0 0 16 13H8a1 1 0 0 0-.832 1.555l4 6Z" clip-rule="evenodd"></path></svg>`), CaretSortSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CaretSortSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretSortSolid);
  validate_prop_bindings($$props, [], [], CaretSortSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "caret sort solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root106();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1106();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2106();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretSortSolid = hmr(CaretSortSolid, () => CaretSortSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretSortSolid[HMR].source;
    set(CaretSortSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretSortSolid_default = CaretSortSolid;
mark_module_end(CaretSortSolid);

// node_modules/flowbite-svelte-icons/dist/CaretUpOutline.svelte
mark_module_start();
CaretUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretUpOutline.svelte";
var root_1107 = add_locations(ns_template(`<title> </title>`), CaretUpOutline[FILENAME], [[41, 4]]);
var root_2107 = add_locations(ns_template(`<desc> </desc>`), CaretUpOutline[FILENAME], [[44, 4]]);
var root107 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16.881 16H7.119a1 1 0 0 1-.772-1.636l4.881-5.927a1 1 0 0 1 1.544 0l4.88 5.927a1 1 0 0 1-.77 1.636Z"></path></svg>`), CaretUpOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CaretUpOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretUpOutline);
  validate_prop_bindings($$props, [], [], CaretUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "caret up outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root107();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1107();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2107();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretUpOutline = hmr(CaretUpOutline, () => CaretUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretUpOutline[HMR].source;
    set(CaretUpOutline[HMR].source, module.default[HMR].original);
  });
}
var CaretUpOutline_default = CaretUpOutline;
mark_module_end(CaretUpOutline);

// node_modules/flowbite-svelte-icons/dist/CaretUpSolid.svelte
mark_module_start();
CaretUpSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CaretUpSolid.svelte";
var root_1108 = add_locations(ns_template(`<title> </title>`), CaretUpSolid[FILENAME], [[39, 4]]);
var root_2108 = add_locations(ns_template(`<desc> </desc>`), CaretUpSolid[FILENAME], [[42, 4]]);
var root108 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5.575 13.729C4.501 15.033 5.43 17 7.12 17h9.762c1.69 0 2.618-1.967 1.544-3.271l-4.881-5.927a2 2 0 0 0-3.088 0l-4.88 5.927Z" clip-rule="evenodd"></path></svg>`), CaretUpSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CaretUpSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CaretUpSolid);
  validate_prop_bindings($$props, [], [], CaretUpSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "caret up solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root108();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1108();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2108();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CaretUpSolid = hmr(CaretUpSolid, () => CaretUpSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CaretUpSolid[HMR].source;
    set(CaretUpSolid[HMR].source, module.default[HMR].original);
  });
}
var CaretUpSolid_default = CaretUpSolid;
mark_module_end(CaretUpSolid);

// node_modules/flowbite-svelte-icons/dist/CartOutline.svelte
mark_module_start();
CartOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartOutline.svelte";
var root_1109 = add_locations(ns_template(`<title> </title>`), CartOutline[FILENAME], [[41, 4]]);
var root_2109 = add_locations(ns_template(`<desc> </desc>`), CartOutline[FILENAME], [[44, 4]]);
var root109 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 4h1.5L9 16m0 0h8m-8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm-8.5-3h9.25L19 7H7.312"></path></svg>`), CartOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CartOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CartOutline);
  validate_prop_bindings($$props, [], [], CartOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "cart outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root109();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1109();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2109();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CartOutline = hmr(CartOutline, () => CartOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartOutline[HMR].source;
    set(CartOutline[HMR].source, module.default[HMR].original);
  });
}
var CartOutline_default = CartOutline;
mark_module_end(CartOutline);

// node_modules/flowbite-svelte-icons/dist/CartPlusAltOutline.svelte
mark_module_start();
CartPlusAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartPlusAltOutline.svelte";
var root_1110 = add_locations(ns_template(`<title> </title>`), CartPlusAltOutline[FILENAME], [[41, 4]]);
var root_2110 = add_locations(ns_template(`<desc> </desc>`), CartPlusAltOutline[FILENAME], [[44, 4]]);
var root110 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 4h1.5L8 16m0 0h8m-8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm.75-3H7.5M11 7H6.312M17 4v6m-3-3h6"></path></svg>`), CartPlusAltOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CartPlusAltOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CartPlusAltOutline);
  validate_prop_bindings($$props, [], [], CartPlusAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "cart plus alt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root110();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1110();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2110();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CartPlusAltOutline = hmr(CartPlusAltOutline, () => CartPlusAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartPlusAltOutline[HMR].source;
    set(CartPlusAltOutline[HMR].source, module.default[HMR].original);
  });
}
var CartPlusAltOutline_default = CartPlusAltOutline;
mark_module_end(CartPlusAltOutline);

// node_modules/flowbite-svelte-icons/dist/CartPlusAltSolid.svelte
mark_module_start();
CartPlusAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartPlusAltSolid.svelte";
var root_1111 = add_locations(ns_template(`<title> </title>`), CartPlusAltSolid[FILENAME], [[39, 4]]);
var root_2111 = add_locations(ns_template(`<desc> </desc>`), CartPlusAltSolid[FILENAME], [[42, 4]]);
var root111 = add_locations(ns_template(`<svg><!><!><path d="M12.268 6A2 2 0 0 0 14 9h1v1a2 2 0 0 0 3.04 1.708l-.311 1.496a1 1 0 0 1-.979.796H8.605l.208 1H16a3 3 0 1 1-2.83 2h-2.34a3 3 0 1 1-4.009-1.76L4.686 5H4a1 1 0 0 1 0-2h1.5a1 1 0 0 1 .979.796L6.939 6h5.329Z"></path><path d="M18 4a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0V8h2a1 1 0 1 0 0-2h-2V4Z"></path></svg>`), CartPlusAltSolid[FILENAME], [
  [29, 0, [[44, 2], [46, 5]]]
]);
function CartPlusAltSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CartPlusAltSolid);
  validate_prop_bindings($$props, [], [], CartPlusAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "cart plus alt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root111();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1111();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2111();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CartPlusAltSolid = hmr(CartPlusAltSolid, () => CartPlusAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartPlusAltSolid[HMR].source;
    set(CartPlusAltSolid[HMR].source, module.default[HMR].original);
  });
}
var CartPlusAltSolid_default = CartPlusAltSolid;
mark_module_end(CartPlusAltSolid);

// node_modules/flowbite-svelte-icons/dist/CartPlusOutline.svelte
mark_module_start();
CartPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartPlusOutline.svelte";
var root_1112 = add_locations(ns_template(`<title> </title>`), CartPlusOutline[FILENAME], [[41, 4]]);
var root_2112 = add_locations(ns_template(`<desc> </desc>`), CartPlusOutline[FILENAME], [[44, 4]]);
var root112 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 4h1.5L9 16m0 0h8m-8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm8 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm-8.5-3h9.25L19 7h-1M8 7h-.688M13 5v4m-2-2h4"></path></svg>`), CartPlusOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CartPlusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CartPlusOutline);
  validate_prop_bindings($$props, [], [], CartPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "cart plus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root112();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1112();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2112();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CartPlusOutline = hmr(CartPlusOutline, () => CartPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartPlusOutline[HMR].source;
    set(CartPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var CartPlusOutline_default = CartPlusOutline;
mark_module_end(CartPlusOutline);

// node_modules/flowbite-svelte-icons/dist/CartPlusSolid.svelte
mark_module_start();
CartPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartPlusSolid.svelte";
var root_1113 = add_locations(ns_template(`<title> </title>`), CartPlusSolid[FILENAME], [[39, 4]]);
var root_2113 = add_locations(ns_template(`<desc> </desc>`), CartPlusSolid[FILENAME], [[42, 4]]);
var root113 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 3a1 1 0 0 0 0 2h.687L7.82 15.24A3 3 0 1 0 11.83 17h2.34A3 3 0 1 0 17 15H9.813l-.208-1h8.145a1 1 0 0 0 .979-.796l1.25-6A1 1 0 0 0 19 6h-2.268A2 2 0 0 1 15 9a2 2 0 1 1-4 0 2 2 0 0 1-1.732-3h-1.33L7.48 3.796A1 1 0 0 0 6.5 3H5Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M14 5a1 1 0 1 0-2 0v1h-1a1 1 0 1 0 0 2h1v1a1 1 0 1 0 2 0V8h1a1 1 0 1 0 0-2h-1V5Z" clip-rule="evenodd"></path></svg>`), CartPlusSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function CartPlusSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CartPlusSolid);
  validate_prop_bindings($$props, [], [], CartPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "cart plus solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root113();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1113();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2113();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CartPlusSolid = hmr(CartPlusSolid, () => CartPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartPlusSolid[HMR].source;
    set(CartPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var CartPlusSolid_default = CartPlusSolid;
mark_module_end(CartPlusSolid);

// node_modules/flowbite-svelte-icons/dist/CartSolid.svelte
mark_module_start();
CartSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CartSolid.svelte";
var root_1114 = add_locations(ns_template(`<title> </title>`), CartSolid[FILENAME], [[39, 4]]);
var root_2114 = add_locations(ns_template(`<desc> </desc>`), CartSolid[FILENAME], [[42, 4]]);
var root114 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 4a1 1 0 0 1 1-1h1.5a1 1 0 0 1 .979.796L7.939 6H19a1 1 0 0 1 .979 1.204l-1.25 6a1 1 0 0 1-.979.796H9.605l.208 1H17a3 3 0 1 1-2.83 2h-2.34a3 3 0 1 1-4.009-1.76L5.686 5H5a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), CartSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CartSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CartSolid);
  validate_prop_bindings($$props, [], [], CartSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "cart solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root114();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1114();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2114();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CartSolid = hmr(CartSolid, () => CartSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CartSolid[HMR].source;
    set(CartSolid[HMR].source, module.default[HMR].original);
  });
}
var CartSolid_default = CartSolid;
mark_module_end(CartSolid);

// node_modules/flowbite-svelte-icons/dist/CashOutline.svelte
mark_module_start();
CashOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CashOutline.svelte";
var root_1115 = add_locations(ns_template(`<title> </title>`), CashOutline[FILENAME], [[41, 4]]);
var root_2115 = add_locations(ns_template(`<desc> </desc>`), CashOutline[FILENAME], [[44, 4]]);
var root115 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M8 7V6a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1h-1M3 18v-7a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1Zm8-3.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Z"></path></svg>`), CashOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CashOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CashOutline);
  validate_prop_bindings($$props, [], [], CashOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "cash outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root115();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1115();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2115();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CashOutline = hmr(CashOutline, () => CashOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CashOutline[HMR].source;
    set(CashOutline[HMR].source, module.default[HMR].original);
  });
}
var CashOutline_default = CashOutline;
mark_module_end(CashOutline);

// node_modules/flowbite-svelte-icons/dist/CashRegisterOutline.svelte
mark_module_start();
CashRegisterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CashRegisterOutline.svelte";
var root_1116 = add_locations(ns_template(`<title> </title>`), CashRegisterOutline[FILENAME], [[41, 4]]);
var root_2116 = add_locations(ns_template(`<desc> </desc>`), CashRegisterOutline[FILENAME], [[44, 4]]);
var root116 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 18h14M5 18v3h14v-3M5 18l1-9h12l1 9M16 6v3m-4-3v3m-2-6h8v3h-8V3Zm-1 9h.01v.01H9V12Zm3 0h.01v.01H12V12Zm3 0h.01v.01H15V12Zm-6 3h.01v.01H9V15Zm3 0h.01v.01H12V15Zm3 0h.01v.01H15V15Z"></path></svg>`), CashRegisterOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CashRegisterOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CashRegisterOutline);
  validate_prop_bindings($$props, [], [], CashRegisterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "cash register outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root116();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1116();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2116();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CashRegisterOutline = hmr(CashRegisterOutline, () => CashRegisterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CashRegisterOutline[HMR].source;
    set(CashRegisterOutline[HMR].source, module.default[HMR].original);
  });
}
var CashRegisterOutline_default = CashRegisterOutline;
mark_module_end(CashRegisterOutline);

// node_modules/flowbite-svelte-icons/dist/CashRegisterSolid.svelte
mark_module_start();
CashRegisterSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CashRegisterSolid.svelte";
var root_1117 = add_locations(ns_template(`<title> </title>`), CashRegisterSolid[FILENAME], [[39, 4]]);
var root_2117 = add_locations(ns_template(`<desc> </desc>`), CashRegisterSolid[FILENAME], [[42, 4]]);
var root117 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M4 19v2c0 .5523.44772 1 1 1h14c.5523 0 1-.4477 1-1v-2H4Z"></path><path fill="currentColor" fill-rule="evenodd" d="M9 3c0-.55228.44772-1 1-1h8c.5523 0 1 .44772 1 1v3c0 .55228-.4477 1-1 1h-2v1h2c.5096 0 .9376.38314.9939.88957L19.8951 17H4.10498l.90116-8.11043C5.06241 8.38314 5.49047 8 6.00002 8H12V7h-2c-.55228 0-1-.44772-1-1V3Zm1.01 8H8.00002v2.01H10.01V11Zm.99 0h2.01v2.01H11V11Zm5.01 0H14v2.01h2.01V11Zm-8.00998 3H10.01v2.01H8.00002V14ZM13.01 14H11v2.01h2.01V14Zm.99 0h2.01v2.01H14V14ZM11 4h6v1h-6V4Z" clip-rule="evenodd"></path></svg>`), CashRegisterSolid[FILENAME], [
  [29, 0, [[44, 2], [45, 2]]]
]);
function CashRegisterSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CashRegisterSolid);
  validate_prop_bindings($$props, [], [], CashRegisterSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "cash register solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root117();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1117();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2117();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CashRegisterSolid = hmr(CashRegisterSolid, () => CashRegisterSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CashRegisterSolid[HMR].source;
    set(CashRegisterSolid[HMR].source, module.default[HMR].original);
  });
}
var CashRegisterSolid_default = CashRegisterSolid;
mark_module_end(CashRegisterSolid);

// node_modules/flowbite-svelte-icons/dist/CashSolid.svelte
mark_module_start();
CashSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CashSolid.svelte";
var root_1118 = add_locations(ns_template(`<title> </title>`), CashSolid[FILENAME], [[39, 4]]);
var root_2118 = add_locations(ns_template(`<desc> </desc>`), CashSolid[FILENAME], [[42, 4]]);
var root118 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M7 6a2 2 0 0 1 2-2h11a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2h-2v-4a3 3 0 0 0-3-3H7V6Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M2 11a2 2 0 0 1 2-2h11a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2v-7Zm7.5 1a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Z" clip-rule="evenodd"></path><path d="M10.5 14.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>`), CashSolid[FILENAME], [
  [
    29,
    0,
    [[44, 2], [49, 2], [53, 5]]
  ]
]);
function CashSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CashSolid);
  validate_prop_bindings($$props, [], [], CashSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "cash solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root118();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1118();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2118();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(3);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CashSolid = hmr(CashSolid, () => CashSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CashSolid[HMR].source;
    set(CashSolid[HMR].source, module.default[HMR].original);
  });
}
var CashSolid_default = CashSolid;
mark_module_end(CashSolid);

// node_modules/flowbite-svelte-icons/dist/CellAttributesOutline.svelte
mark_module_start();
CellAttributesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CellAttributesOutline.svelte";
var root_1119 = add_locations(ns_template(`<title> </title>`), CellAttributesOutline[FILENAME], [[41, 4]]);
var root_2119 = add_locations(ns_template(`<desc> </desc>`), CellAttributesOutline[FILENAME], [[44, 4]]);
var root119 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h8v-8m-9 4v-4m0 4h9m-9-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v4M3 11h11m6.25 5c0 1.2426-1.0073 2.25-2.25 2.25M20.25 16c0-1.2426-1.0073-2.25-2.25-2.25M20.25 16H21m-3 2.25c-1.2426 0-2.25-1.0074-2.25-2.25M18 18.25V19m-2.25-3c0-1.2426 1.0074-2.25 2.25-2.25M15.75 16H15m3-2.25V13m-1.591 1.409-.5303-.5303m4.2426 4.2426-.5303-.5303m-3.182 0-.5303.5303m4.2426-4.2426-.5303.5303"></path></svg>`), CellAttributesOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CellAttributesOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CellAttributesOutline);
  validate_prop_bindings($$props, [], [], CellAttributesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "cell attributes outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root119();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1119();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2119();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CellAttributesOutline = hmr(CellAttributesOutline, () => CellAttributesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CellAttributesOutline[HMR].source;
    set(CellAttributesOutline[HMR].source, module.default[HMR].original);
  });
}
var CellAttributesOutline_default = CellAttributesOutline;
mark_module_end(CellAttributesOutline);

// node_modules/flowbite-svelte-icons/dist/ChartLineDownOutline.svelte
mark_module_start();
ChartLineDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartLineDownOutline.svelte";
var root_1120 = add_locations(ns_template(`<title> </title>`), ChartLineDownOutline[FILENAME], [[41, 4]]);
var root_2120 = add_locations(ns_template(`<desc> </desc>`), ChartLineDownOutline[FILENAME], [[44, 4]]);
var root120 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 4.5V19a1 1 0 0 0 1 1h15M7 10l4 4 4-4 5 5m0 0h-3.207M20 15v-3.207"></path></svg>`), ChartLineDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChartLineDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChartLineDownOutline);
  validate_prop_bindings($$props, [], [], ChartLineDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chart line down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root120();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1120();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2120();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartLineDownOutline = hmr(ChartLineDownOutline, () => ChartLineDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartLineDownOutline[HMR].source;
    set(ChartLineDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartLineDownOutline_default = ChartLineDownOutline;
mark_module_end(ChartLineDownOutline);

// node_modules/flowbite-svelte-icons/dist/ChartLineUpOutline.svelte
mark_module_start();
ChartLineUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartLineUpOutline.svelte";
var root_1121 = add_locations(ns_template(`<title> </title>`), ChartLineUpOutline[FILENAME], [[41, 4]]);
var root_2121 = add_locations(ns_template(`<desc> </desc>`), ChartLineUpOutline[FILENAME], [[44, 4]]);
var root121 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 4.5V19a1 1 0 0 0 1 1h15M7 14l4-4 4 4 5-5m0 0h-3.207M20 9v3.207"></path></svg>`), ChartLineUpOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChartLineUpOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChartLineUpOutline);
  validate_prop_bindings($$props, [], [], ChartLineUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chart line up outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root121();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1121();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2121();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartLineUpOutline = hmr(ChartLineUpOutline, () => ChartLineUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartLineUpOutline[HMR].source;
    set(ChartLineUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartLineUpOutline_default = ChartLineUpOutline;
mark_module_end(ChartLineUpOutline);

// node_modules/flowbite-svelte-icons/dist/ChartMixedDollarOutline.svelte
mark_module_start();
ChartMixedDollarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartMixedDollarOutline.svelte";
var root_1122 = add_locations(ns_template(`<title> </title>`), ChartMixedDollarOutline[FILENAME], [[41, 4]]);
var root_2122 = add_locations(ns_template(`<desc> </desc>`), ChartMixedDollarOutline[FILENAME], [[44, 4]]);
var root122 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.6 16.733c.234.269.548.456.895.534a1.4 1.4 0 0 0 1.75-.762c.172-.615-.446-1.287-1.242-1.481-.796-.194-1.41-.861-1.241-1.481a1.4 1.4 0 0 1 1.75-.762c.343.077.654.26.888.524m-1.358 4.017v.617m0-5.939v.725M4 15v4m3-6v6M6 8.5 10.5 5 14 7.5 18 4m0 0h-3.5M18 4v3m2 8a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"></path></svg>`), ChartMixedDollarOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChartMixedDollarOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChartMixedDollarOutline);
  validate_prop_bindings($$props, [], [], ChartMixedDollarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chart mixed dollar outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root122();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1122();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2122();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartMixedDollarOutline = hmr(ChartMixedDollarOutline, () => ChartMixedDollarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartMixedDollarOutline[HMR].source;
    set(ChartMixedDollarOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartMixedDollarOutline_default = ChartMixedDollarOutline;
mark_module_end(ChartMixedDollarOutline);

// node_modules/flowbite-svelte-icons/dist/ChartMixedDollarSolid.svelte
mark_module_start();
ChartMixedDollarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartMixedDollarSolid.svelte";
var root_1123 = add_locations(ns_template(`<title> </title>`), ChartMixedDollarSolid[FILENAME], [[39, 4]]);
var root_2123 = add_locations(ns_template(`<desc> </desc>`), ChartMixedDollarSolid[FILENAME], [[42, 4]]);
var root123 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 15a6 6 0 1 1 12 0 6 6 0 0 1-12 0Zm3.845-1.855a2.4 2.4 0 0 1 1.2-1.226 1 1 0 0 1 1.992-.026c.426.15.809.408 1.111.749a1 1 0 1 1-1.496 1.327.682.682 0 0 0-.36-.213.997.997 0 0 1-.113-.032.4.4 0 0 0-.394.074.93.93 0 0 0 .455.254 2.914 2.914 0 0 1 1.504.9c.373.433.669 1.092.464 1.823a.996.996 0 0 1-.046.129c-.226.519-.627.94-1.132 1.192a1 1 0 0 1-1.956.093 2.68 2.68 0 0 1-1.227-.798 1 1 0 1 1 1.506-1.315.682.682 0 0 0 .363.216c.038.009.075.02.111.032a.4.4 0 0 0 .395-.074.93.93 0 0 0-.455-.254 2.91 2.91 0 0 1-1.503-.9c-.375-.433-.666-1.089-.466-1.817a.994.994 0 0 1 .047-.134Zm1.884.573.003.008c-.003-.005-.003-.008-.003-.008Zm.55 2.613s-.002-.002-.003-.007a.032.032 0 0 1 .003.007ZM4 14a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0v-4a1 1 0 0 1 1-1Zm3-2a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-6a1 1 0 0 1 1-1Zm6.5-8a1 1 0 0 1 1-1H18a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0v-.796l-2.341 2.049a1 1 0 0 1-1.24.06l-2.894-2.066L6.614 9.29a1 1 0 1 1-1.228-1.578l4.5-3.5a1 1 0 0 1 1.195-.025l2.856 2.04L15.34 5h-.84a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), ChartMixedDollarSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ChartMixedDollarSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChartMixedDollarSolid);
  validate_prop_bindings($$props, [], [], ChartMixedDollarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "chart mixed dollar solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root123();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1123();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2123();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartMixedDollarSolid = hmr(ChartMixedDollarSolid, () => ChartMixedDollarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartMixedDollarSolid[HMR].source;
    set(ChartMixedDollarSolid[HMR].source, module.default[HMR].original);
  });
}
var ChartMixedDollarSolid_default = ChartMixedDollarSolid;
mark_module_end(ChartMixedDollarSolid);

// node_modules/flowbite-svelte-icons/dist/ChartMixedOutline.svelte
mark_module_start();
ChartMixedOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartMixedOutline.svelte";
var root_1124 = add_locations(ns_template(`<title> </title>`), ChartMixedOutline[FILENAME], [[41, 4]]);
var root_2124 = add_locations(ns_template(`<desc> </desc>`), ChartMixedOutline[FILENAME], [[44, 4]]);
var root124 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v4m6-6v6m6-4v4m6-6v6M3 11l6-5 6 5 5.5-5.5"></path></svg>`), ChartMixedOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChartMixedOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChartMixedOutline);
  validate_prop_bindings($$props, [], [], ChartMixedOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chart mixed outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root124();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1124();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2124();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartMixedOutline = hmr(ChartMixedOutline, () => ChartMixedOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartMixedOutline[HMR].source;
    set(ChartMixedOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartMixedOutline_default = ChartMixedOutline;
mark_module_end(ChartMixedOutline);

// node_modules/flowbite-svelte-icons/dist/ChartOutline.svelte
mark_module_start();
ChartOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartOutline.svelte";
var root_1125 = add_locations(ns_template(`<title> </title>`), ChartOutline[FILENAME], [[41, 4]]);
var root_2125 = add_locations(ns_template(`<desc> </desc>`), ChartOutline[FILENAME], [[44, 4]]);
var root125 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 4v15a1 1 0 0 0 1 1h15M8 16l2.5-5.5 3 3L17.273 7 20 9.667"></path></svg>`), ChartOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChartOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChartOutline);
  validate_prop_bindings($$props, [], [], ChartOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chart outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root125();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1125();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2125();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartOutline = hmr(ChartOutline, () => ChartOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartOutline[HMR].source;
    set(ChartOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartOutline_default = ChartOutline;
mark_module_end(ChartOutline);

// node_modules/flowbite-svelte-icons/dist/ChartPieOutline.svelte
mark_module_start();
ChartPieOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartPieOutline.svelte";
var root_1126 = add_locations(ns_template(`<title> </title>`), ChartPieOutline[FILENAME], [[41, 4]]);
var root_2126 = add_locations(ns_template(`<desc> </desc>`), ChartPieOutline[FILENAME], [[44, 4]]);
var root126 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 6.025A7.5 7.5 0 1 0 17.975 14H10V6.025Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.5 3c-.169 0-.334.014-.5.025V11h7.975c.011-.166.025-.331.025-.5A7.5 7.5 0 0 0 13.5 3Z"></path></svg>`), ChartPieOutline[FILENAME], [
  [30, 0, [[46, 2], [53, 2]]]
]);
function ChartPieOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChartPieOutline);
  validate_prop_bindings($$props, [], [], ChartPieOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chart pie outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root126();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1126();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2126();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartPieOutline = hmr(ChartPieOutline, () => ChartPieOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartPieOutline[HMR].source;
    set(ChartPieOutline[HMR].source, module.default[HMR].original);
  });
}
var ChartPieOutline_default = ChartPieOutline;
mark_module_end(ChartPieOutline);

// node_modules/flowbite-svelte-icons/dist/ChartPieSolid.svelte
mark_module_start();
ChartPieSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChartPieSolid.svelte";
var root_1127 = add_locations(ns_template(`<title> </title>`), ChartPieSolid[FILENAME], [[39, 4]]);
var root_2127 = add_locations(ns_template(`<desc> </desc>`), ChartPieSolid[FILENAME], [[42, 4]]);
var root127 = add_locations(ns_template(`<svg><!><!><path d="M13.5 2c-.178 0-.356.013-.492.022l-.074.005a1 1 0 0 0-.934.998V11a1 1 0 0 0 1 1h7.975a1 1 0 0 0 .998-.934l.005-.074A7.04 7.04 0 0 0 22 10.5 8.5 8.5 0 0 0 13.5 2Z"></path><path d="M11 6.025a1 1 0 0 0-1.065-.998 8.5 8.5 0 1 0 9.038 9.039A1 1 0 0 0 17.975 13H11V6.025Z"></path></svg>`), ChartPieSolid[FILENAME], [
  [29, 0, [[44, 2], [47, 2]]]
]);
function ChartPieSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChartPieSolid);
  validate_prop_bindings($$props, [], [], ChartPieSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "chart pie solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root127();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1127();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2127();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChartPieSolid = hmr(ChartPieSolid, () => ChartPieSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChartPieSolid[HMR].source;
    set(ChartPieSolid[HMR].source, module.default[HMR].original);
  });
}
var ChartPieSolid_default = ChartPieSolid;
mark_module_end(ChartPieSolid);

// node_modules/flowbite-svelte-icons/dist/CheckCircleOutline.svelte
mark_module_start();
CheckCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckCircleOutline.svelte";
var root_1128 = add_locations(ns_template(`<title> </title>`), CheckCircleOutline[FILENAME], [[41, 4]]);
var root_2128 = add_locations(ns_template(`<desc> </desc>`), CheckCircleOutline[FILENAME], [[44, 4]]);
var root128 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.5 11.5 11 14l4-4m6 2a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CheckCircleOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CheckCircleOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CheckCircleOutline);
  validate_prop_bindings($$props, [], [], CheckCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "check circle outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root128();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1128();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2128();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CheckCircleOutline = hmr(CheckCircleOutline, () => CheckCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckCircleOutline[HMR].source;
    set(CheckCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var CheckCircleOutline_default = CheckCircleOutline;
mark_module_end(CheckCircleOutline);

// node_modules/flowbite-svelte-icons/dist/CheckCircleSolid.svelte
mark_module_start();
CheckCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckCircleSolid.svelte";
var root_1129 = add_locations(ns_template(`<title> </title>`), CheckCircleSolid[FILENAME], [[39, 4]]);
var root_2129 = add_locations(ns_template(`<desc> </desc>`), CheckCircleSolid[FILENAME], [[42, 4]]);
var root129 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm13.707-1.293a1 1 0 0 0-1.414-1.414L11 12.586l-1.793-1.793a1 1 0 0 0-1.414 1.414l2.5 2.5a1 1 0 0 0 1.414 0l4-4Z" clip-rule="evenodd"></path></svg>`), CheckCircleSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CheckCircleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CheckCircleSolid);
  validate_prop_bindings($$props, [], [], CheckCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "check circle solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root129();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1129();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2129();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CheckCircleSolid = hmr(CheckCircleSolid, () => CheckCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckCircleSolid[HMR].source;
    set(CheckCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var CheckCircleSolid_default = CheckCircleSolid;
mark_module_end(CheckCircleSolid);

// node_modules/flowbite-svelte-icons/dist/CheckOutline.svelte
mark_module_start();
CheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckOutline.svelte";
var root_1130 = add_locations(ns_template(`<title> </title>`), CheckOutline[FILENAME], [[41, 4]]);
var root_2130 = add_locations(ns_template(`<desc> </desc>`), CheckOutline[FILENAME], [[44, 4]]);
var root130 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 11.917 9.724 16.5 19 7.5"></path></svg>`), CheckOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CheckOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CheckOutline);
  validate_prop_bindings($$props, [], [], CheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "check outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root130();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1130();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2130();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CheckOutline = hmr(CheckOutline, () => CheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckOutline[HMR].source;
    set(CheckOutline[HMR].source, module.default[HMR].original);
  });
}
var CheckOutline_default = CheckOutline;
mark_module_end(CheckOutline);

// node_modules/flowbite-svelte-icons/dist/CheckPlusCircleOutline.svelte
mark_module_start();
CheckPlusCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckPlusCircleOutline.svelte";
var root_1131 = add_locations(ns_template(`<title> </title>`), CheckPlusCircleOutline[FILENAME], [[41, 4]]);
var root_2131 = add_locations(ns_template(`<desc> </desc>`), CheckPlusCircleOutline[FILENAME], [[44, 4]]);
var root131 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 21a9 9 0 1 1 0-18c1.052 0 2.062.18 3 .512M7 9.577l3.923 3.923 8.5-8.5M17 14v6m-3-3h6"></path></svg>`), CheckPlusCircleOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CheckPlusCircleOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CheckPlusCircleOutline);
  validate_prop_bindings($$props, [], [], CheckPlusCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "check plus circle outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root131();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1131();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2131();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CheckPlusCircleOutline = hmr(CheckPlusCircleOutline, () => CheckPlusCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckPlusCircleOutline[HMR].source;
    set(CheckPlusCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var CheckPlusCircleOutline_default = CheckPlusCircleOutline;
mark_module_end(CheckPlusCircleOutline);

// node_modules/flowbite-svelte-icons/dist/CheckPlusCircleSolid.svelte
mark_module_start();
CheckPlusCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CheckPlusCircleSolid.svelte";
var root_1132 = add_locations(ns_template(`<title> </title>`), CheckPlusCircleSolid[FILENAME], [[39, 4]]);
var root_2132 = add_locations(ns_template(`<desc> </desc>`), CheckPlusCircleSolid[FILENAME], [[42, 4]]);
var root132 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M18 14a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M15.026 21.534A9.994 9.994 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2c2.51 0 4.802.924 6.558 2.45l-7.635 7.636L7.707 8.87a1 1 0 0 0-1.414 1.414l3.923 3.923a1 1 0 0 0 1.414 0l8.3-8.3A9.956 9.956 0 0 1 22 12a9.994 9.994 0 0 1-.466 3.026A2.49 2.49 0 0 0 20 14.5h-.5V14a2.5 2.5 0 0 0-5 0v.5H14a2.5 2.5 0 0 0 0 5h.5v.5c0 .578.196 1.11.526 1.534Z" clip-rule="evenodd"></path></svg>`), CheckPlusCircleSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function CheckPlusCircleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CheckPlusCircleSolid);
  validate_prop_bindings($$props, [], [], CheckPlusCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "check plus circle solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root132();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1132();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2132();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CheckPlusCircleSolid = hmr(CheckPlusCircleSolid, () => CheckPlusCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CheckPlusCircleSolid[HMR].source;
    set(CheckPlusCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var CheckPlusCircleSolid_default = CheckPlusCircleSolid;
mark_module_end(CheckPlusCircleSolid);

// node_modules/flowbite-svelte-icons/dist/ChevronDoubleDownOutline.svelte
mark_module_start();
ChevronDoubleDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDoubleDownOutline.svelte";
var root_1133 = add_locations(ns_template(`<title> </title>`), ChevronDoubleDownOutline[FILENAME], [[41, 4]]);
var root_2133 = add_locations(ns_template(`<desc> </desc>`), ChevronDoubleDownOutline[FILENAME], [[44, 4]]);
var root133 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 7 4 4 4-4m-8 6 4 4 4-4"></path></svg>`), ChevronDoubleDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChevronDoubleDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChevronDoubleDownOutline);
  validate_prop_bindings($$props, [], [], ChevronDoubleDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chevron double down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root133();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1133();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2133();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronDoubleDownOutline = hmr(ChevronDoubleDownOutline, () => ChevronDoubleDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDoubleDownOutline[HMR].source;
    set(ChevronDoubleDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDoubleDownOutline_default = ChevronDoubleDownOutline;
mark_module_end(ChevronDoubleDownOutline);

// node_modules/flowbite-svelte-icons/dist/ChevronDoubleLeftOutline.svelte
mark_module_start();
ChevronDoubleLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDoubleLeftOutline.svelte";
var root_1134 = add_locations(ns_template(`<title> </title>`), ChevronDoubleLeftOutline[FILENAME], [[41, 4]]);
var root_2134 = add_locations(ns_template(`<desc> </desc>`), ChevronDoubleLeftOutline[FILENAME], [[44, 4]]);
var root134 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m17 16-4-4 4-4m-6 8-4-4 4-4"></path></svg>`), ChevronDoubleLeftOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChevronDoubleLeftOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChevronDoubleLeftOutline);
  validate_prop_bindings($$props, [], [], ChevronDoubleLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chevron double left outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root134();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1134();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2134();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronDoubleLeftOutline = hmr(ChevronDoubleLeftOutline, () => ChevronDoubleLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDoubleLeftOutline[HMR].source;
    set(ChevronDoubleLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDoubleLeftOutline_default = ChevronDoubleLeftOutline;
mark_module_end(ChevronDoubleLeftOutline);

// node_modules/flowbite-svelte-icons/dist/ChevronDoubleRightOutline.svelte
mark_module_start();
ChevronDoubleRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDoubleRightOutline.svelte";
var root_1135 = add_locations(ns_template(`<title> </title>`), ChevronDoubleRightOutline[FILENAME], [[41, 4]]);
var root_2135 = add_locations(ns_template(`<desc> </desc>`), ChevronDoubleRightOutline[FILENAME], [[44, 4]]);
var root135 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m7 16 4-4-4-4m6 8 4-4-4-4"></path></svg>`), ChevronDoubleRightOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChevronDoubleRightOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChevronDoubleRightOutline);
  validate_prop_bindings($$props, [], [], ChevronDoubleRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chevron double right outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root135();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1135();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2135();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronDoubleRightOutline = hmr(ChevronDoubleRightOutline, () => ChevronDoubleRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDoubleRightOutline[HMR].source;
    set(ChevronDoubleRightOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDoubleRightOutline_default = ChevronDoubleRightOutline;
mark_module_end(ChevronDoubleRightOutline);

// node_modules/flowbite-svelte-icons/dist/ChevronDoubleUpOutline.svelte
mark_module_start();
ChevronDoubleUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDoubleUpOutline.svelte";
var root_1136 = add_locations(ns_template(`<title> </title>`), ChevronDoubleUpOutline[FILENAME], [[41, 4]]);
var root_2136 = add_locations(ns_template(`<desc> </desc>`), ChevronDoubleUpOutline[FILENAME], [[44, 4]]);
var root136 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m16 17-4-4-4 4m8-6-4-4-4 4"></path></svg>`), ChevronDoubleUpOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChevronDoubleUpOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChevronDoubleUpOutline);
  validate_prop_bindings($$props, [], [], ChevronDoubleUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chevron double up outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root136();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1136();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2136();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronDoubleUpOutline = hmr(ChevronDoubleUpOutline, () => ChevronDoubleUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDoubleUpOutline[HMR].source;
    set(ChevronDoubleUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDoubleUpOutline_default = ChevronDoubleUpOutline;
mark_module_end(ChevronDoubleUpOutline);

// node_modules/flowbite-svelte-icons/dist/ChevronDownOutline.svelte
mark_module_start();
ChevronDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronDownOutline.svelte";
var root_1137 = add_locations(ns_template(`<title> </title>`), ChevronDownOutline[FILENAME], [[41, 4]]);
var root_2137 = add_locations(ns_template(`<desc> </desc>`), ChevronDownOutline[FILENAME], [[44, 4]]);
var root137 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 10 4 4 4-4"></path></svg>`), ChevronDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChevronDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChevronDownOutline);
  validate_prop_bindings($$props, [], [], ChevronDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chevron down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root137();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1137();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2137();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronDownOutline = hmr(ChevronDownOutline, () => ChevronDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronDownOutline[HMR].source;
    set(ChevronDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronDownOutline_default = ChevronDownOutline;
mark_module_end(ChevronDownOutline);

// node_modules/flowbite-svelte-icons/dist/ChevronLeftOutline.svelte
mark_module_start();
ChevronLeftOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronLeftOutline.svelte";
var root_1138 = add_locations(ns_template(`<title> </title>`), ChevronLeftOutline[FILENAME], [[41, 4]]);
var root_2138 = add_locations(ns_template(`<desc> </desc>`), ChevronLeftOutline[FILENAME], [[44, 4]]);
var root138 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m14 8-4 4 4 4"></path></svg>`), ChevronLeftOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChevronLeftOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChevronLeftOutline);
  validate_prop_bindings($$props, [], [], ChevronLeftOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chevron left outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root138();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1138();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2138();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronLeftOutline = hmr(ChevronLeftOutline, () => ChevronLeftOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronLeftOutline[HMR].source;
    set(ChevronLeftOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronLeftOutline_default = ChevronLeftOutline;
mark_module_end(ChevronLeftOutline);

// node_modules/flowbite-svelte-icons/dist/ChevronRightOutline.svelte
mark_module_start();
ChevronRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronRightOutline.svelte";
var root_1139 = add_locations(ns_template(`<title> </title>`), ChevronRightOutline[FILENAME], [[41, 4]]);
var root_2139 = add_locations(ns_template(`<desc> </desc>`), ChevronRightOutline[FILENAME], [[44, 4]]);
var root139 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10 16 4-4-4-4"></path></svg>`), ChevronRightOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChevronRightOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChevronRightOutline);
  validate_prop_bindings($$props, [], [], ChevronRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chevron right outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root139();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1139();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2139();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronRightOutline = hmr(ChevronRightOutline, () => ChevronRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronRightOutline[HMR].source;
    set(ChevronRightOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronRightOutline_default = ChevronRightOutline;
mark_module_end(ChevronRightOutline);

// node_modules/flowbite-svelte-icons/dist/ChevronSortOutline.svelte
mark_module_start();
ChevronSortOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronSortOutline.svelte";
var root_1140 = add_locations(ns_template(`<title> </title>`), ChevronSortOutline[FILENAME], [[41, 4]]);
var root_2140 = add_locations(ns_template(`<desc> </desc>`), ChevronSortOutline[FILENAME], [[44, 4]]);
var root140 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 15 4 4 4-4m0-6-4-4-4 4"></path></svg>`), ChevronSortOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChevronSortOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChevronSortOutline);
  validate_prop_bindings($$props, [], [], ChevronSortOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chevron sort outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root140();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1140();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2140();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronSortOutline = hmr(ChevronSortOutline, () => ChevronSortOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronSortOutline[HMR].source;
    set(ChevronSortOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronSortOutline_default = ChevronSortOutline;
mark_module_end(ChevronSortOutline);

// node_modules/flowbite-svelte-icons/dist/ChevronUpOutline.svelte
mark_module_start();
ChevronUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ChevronUpOutline.svelte";
var root_1141 = add_locations(ns_template(`<title> </title>`), ChevronUpOutline[FILENAME], [[41, 4]]);
var root_2141 = add_locations(ns_template(`<desc> </desc>`), ChevronUpOutline[FILENAME], [[44, 4]]);
var root141 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m16 14-4-4-4 4"></path></svg>`), ChevronUpOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ChevronUpOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ChevronUpOutline);
  validate_prop_bindings($$props, [], [], ChevronUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "chevron up outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root141();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1141();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2141();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ChevronUpOutline = hmr(ChevronUpOutline, () => ChevronUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ChevronUpOutline[HMR].source;
    set(ChevronUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ChevronUpOutline_default = ChevronUpOutline;
mark_module_end(ChevronUpOutline);

// node_modules/flowbite-svelte-icons/dist/CircleMinusOutline.svelte
mark_module_start();
CircleMinusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CircleMinusOutline.svelte";
var root_1142 = add_locations(ns_template(`<title> </title>`), CircleMinusOutline[FILENAME], [[41, 4]]);
var root_2142 = add_locations(ns_template(`<desc> </desc>`), CircleMinusOutline[FILENAME], [[44, 4]]);
var root142 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.757 12h8.486M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CircleMinusOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CircleMinusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CircleMinusOutline);
  validate_prop_bindings($$props, [], [], CircleMinusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "circle minus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root142();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1142();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2142();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CircleMinusOutline = hmr(CircleMinusOutline, () => CircleMinusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CircleMinusOutline[HMR].source;
    set(CircleMinusOutline[HMR].source, module.default[HMR].original);
  });
}
var CircleMinusOutline_default = CircleMinusOutline;
mark_module_end(CircleMinusOutline);

// node_modules/flowbite-svelte-icons/dist/CircleMinusSolid.svelte
mark_module_start();
CircleMinusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CircleMinusSolid.svelte";
var root_1143 = add_locations(ns_template(`<title> </title>`), CircleMinusSolid[FILENAME], [[39, 4]]);
var root_2143 = add_locations(ns_template(`<desc> </desc>`), CircleMinusSolid[FILENAME], [[42, 4]]);
var root143 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm5.757-1a1 1 0 1 0 0 2h8.486a1 1 0 1 0 0-2H7.757Z" clip-rule="evenodd"></path></svg>`), CircleMinusSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CircleMinusSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CircleMinusSolid);
  validate_prop_bindings($$props, [], [], CircleMinusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "circle minus solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root143();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1143();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2143();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CircleMinusSolid = hmr(CircleMinusSolid, () => CircleMinusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CircleMinusSolid[HMR].source;
    set(CircleMinusSolid[HMR].source, module.default[HMR].original);
  });
}
var CircleMinusSolid_default = CircleMinusSolid;
mark_module_end(CircleMinusSolid);

// node_modules/flowbite-svelte-icons/dist/CirclePauseOutline.svelte
mark_module_start();
CirclePauseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CirclePauseOutline.svelte";
var root_1144 = add_locations(ns_template(`<title> </title>`), CirclePauseOutline[FILENAME], [[41, 4]]);
var root_2144 = add_locations(ns_template(`<desc> </desc>`), CirclePauseOutline[FILENAME], [[44, 4]]);
var root144 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CirclePauseOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CirclePauseOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CirclePauseOutline);
  validate_prop_bindings($$props, [], [], CirclePauseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "circle pause outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root144();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1144();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2144();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CirclePauseOutline = hmr(CirclePauseOutline, () => CirclePauseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CirclePauseOutline[HMR].source;
    set(CirclePauseOutline[HMR].source, module.default[HMR].original);
  });
}
var CirclePauseOutline_default = CirclePauseOutline;
mark_module_end(CirclePauseOutline);

// node_modules/flowbite-svelte-icons/dist/CirclePauseSolid.svelte
mark_module_start();
CirclePauseSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CirclePauseSolid.svelte";
var root_1145 = add_locations(ns_template(`<title> </title>`), CirclePauseSolid[FILENAME], [[39, 4]]);
var root_2145 = add_locations(ns_template(`<desc> </desc>`), CirclePauseSolid[FILENAME], [[42, 4]]);
var root145 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm9-3a1 1 0 1 0-2 0v6a1 1 0 1 0 2 0V9Zm4 0a1 1 0 1 0-2 0v6a1 1 0 1 0 2 0V9Z" clip-rule="evenodd"></path></svg>`), CirclePauseSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CirclePauseSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CirclePauseSolid);
  validate_prop_bindings($$props, [], [], CirclePauseSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "circle pause solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root145();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1145();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2145();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CirclePauseSolid = hmr(CirclePauseSolid, () => CirclePauseSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CirclePauseSolid[HMR].source;
    set(CirclePauseSolid[HMR].source, module.default[HMR].original);
  });
}
var CirclePauseSolid_default = CirclePauseSolid;
mark_module_end(CirclePauseSolid);

// node_modules/flowbite-svelte-icons/dist/CirclePlusOutline.svelte
mark_module_start();
CirclePlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CirclePlusOutline.svelte";
var root_1146 = add_locations(ns_template(`<title> </title>`), CirclePlusOutline[FILENAME], [[41, 4]]);
var root_2146 = add_locations(ns_template(`<desc> </desc>`), CirclePlusOutline[FILENAME], [[44, 4]]);
var root146 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 7.757v8.486M7.757 12h8.486M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CirclePlusOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CirclePlusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CirclePlusOutline);
  validate_prop_bindings($$props, [], [], CirclePlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "circle plus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root146();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1146();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2146();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CirclePlusOutline = hmr(CirclePlusOutline, () => CirclePlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CirclePlusOutline[HMR].source;
    set(CirclePlusOutline[HMR].source, module.default[HMR].original);
  });
}
var CirclePlusOutline_default = CirclePlusOutline;
mark_module_end(CirclePlusOutline);

// node_modules/flowbite-svelte-icons/dist/CirclePlusSolid.svelte
mark_module_start();
CirclePlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CirclePlusSolid.svelte";
var root_1147 = add_locations(ns_template(`<title> </title>`), CirclePlusSolid[FILENAME], [[39, 4]]);
var root_2147 = add_locations(ns_template(`<desc> </desc>`), CirclePlusSolid[FILENAME], [[42, 4]]);
var root147 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm11-4.243a1 1 0 1 0-2 0V11H7.757a1 1 0 1 0 0 2H11v3.243a1 1 0 1 0 2 0V13h3.243a1 1 0 1 0 0-2H13V7.757Z" clip-rule="evenodd"></path></svg>`), CirclePlusSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CirclePlusSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CirclePlusSolid);
  validate_prop_bindings($$props, [], [], CirclePlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "circle plus solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root147();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1147();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2147();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CirclePlusSolid = hmr(CirclePlusSolid, () => CirclePlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CirclePlusSolid[HMR].source;
    set(CirclePlusSolid[HMR].source, module.default[HMR].original);
  });
}
var CirclePlusSolid_default = CirclePlusSolid;
mark_module_end(CirclePlusSolid);

// node_modules/flowbite-svelte-icons/dist/ClapperboardPlayOutline.svelte
mark_module_start();
ClapperboardPlayOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClapperboardPlayOutline.svelte";
var root_1148 = add_locations(ns_template(`<title> </title>`), ClapperboardPlayOutline[FILENAME], [[41, 4]]);
var root_2148 = add_locations(ns_template(`<desc> </desc>`), ClapperboardPlayOutline[FILENAME], [[44, 4]]);
var root148 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 4H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1Zm0 0-4 4m5 0H4m1 0 4-4m1 4 4-4m-4 7v6l4-3-4-3Z"></path></svg>`), ClapperboardPlayOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ClapperboardPlayOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClapperboardPlayOutline);
  validate_prop_bindings($$props, [], [], ClapperboardPlayOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "clapperboard play outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root148();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1148();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2148();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClapperboardPlayOutline = hmr(ClapperboardPlayOutline, () => ClapperboardPlayOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClapperboardPlayOutline[HMR].source;
    set(ClapperboardPlayOutline[HMR].source, module.default[HMR].original);
  });
}
var ClapperboardPlayOutline_default = ClapperboardPlayOutline;
mark_module_end(ClapperboardPlayOutline);

// node_modules/flowbite-svelte-icons/dist/ClapperboardPlaySolid.svelte
mark_module_start();
ClapperboardPlaySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClapperboardPlaySolid.svelte";
var root_1149 = add_locations(ns_template(`<title> </title>`), ClapperboardPlaySolid[FILENAME], [[39, 4]]);
var root_2149 = add_locations(ns_template(`<desc> </desc>`), ClapperboardPlaySolid[FILENAME], [[42, 4]]);
var root149 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M19.003 3A2 2 0 0 1 21 5v2h-2V5.414L17.414 7h-2.828l2-2h-2.172l-2 2H9.586l2-2H9.414l-2 2H3V5a2 2 0 0 1 2-2h14.003ZM3 9v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9H3Zm2-2.414L6.586 5H5v1.586Zm4.553 4.52a1 1 0 0 1 1.047.094l4 3a1 1 0 0 1 0 1.6l-4 3A1 1 0 0 1 9 18v-6a1 1 0 0 1 .553-.894Z" clip-rule="evenodd"></path></svg>`), ClapperboardPlaySolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ClapperboardPlaySolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClapperboardPlaySolid);
  validate_prop_bindings($$props, [], [], ClapperboardPlaySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "clapperboard play solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root149();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1149();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2149();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClapperboardPlaySolid = hmr(ClapperboardPlaySolid, () => ClapperboardPlaySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClapperboardPlaySolid[HMR].source;
    set(ClapperboardPlaySolid[HMR].source, module.default[HMR].original);
  });
}
var ClapperboardPlaySolid_default = ClapperboardPlaySolid;
mark_module_end(ClapperboardPlaySolid);

// node_modules/flowbite-svelte-icons/dist/ClipboardCheckOutline.svelte
mark_module_start();
ClipboardCheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardCheckOutline.svelte";
var root_1150 = add_locations(ns_template(`<title> </title>`), ClipboardCheckOutline[FILENAME], [[41, 4]]);
var root_2150 = add_locations(ns_template(`<desc> </desc>`), ClipboardCheckOutline[FILENAME], [[44, 4]]);
var root150 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 4h3a1 1 0 0 1 1 1v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3m0 3h6m-6 7 2 2 4-4m-5-9v4h4V3h-4Z"></path></svg>`), ClipboardCheckOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ClipboardCheckOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClipboardCheckOutline);
  validate_prop_bindings($$props, [], [], ClipboardCheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "clipboard check outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root150();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1150();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2150();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClipboardCheckOutline = hmr(ClipboardCheckOutline, () => ClipboardCheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardCheckOutline[HMR].source;
    set(ClipboardCheckOutline[HMR].source, module.default[HMR].original);
  });
}
var ClipboardCheckOutline_default = ClipboardCheckOutline;
mark_module_end(ClipboardCheckOutline);

// node_modules/flowbite-svelte-icons/dist/ClipboardCheckSolid.svelte
mark_module_start();
ClipboardCheckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardCheckSolid.svelte";
var root_1151 = add_locations(ns_template(`<title> </title>`), ClipboardCheckSolid[FILENAME], [[39, 4]]);
var root_2151 = add_locations(ns_template(`<desc> </desc>`), ClipboardCheckSolid[FILENAME], [[42, 4]]);
var root151 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 2a1 1 0 0 0-1 1H6a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-2a1 1 0 0 0-1-1H9Zm1 2h4v2h1a1 1 0 1 1 0 2H9a1 1 0 0 1 0-2h1V4Zm5.707 8.707a1 1 0 0 0-1.414-1.414L11 14.586l-1.293-1.293a1 1 0 0 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l4-4Z" clip-rule="evenodd"></path></svg>`), ClipboardCheckSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ClipboardCheckSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClipboardCheckSolid);
  validate_prop_bindings($$props, [], [], ClipboardCheckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "clipboard check solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root151();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1151();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2151();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClipboardCheckSolid = hmr(ClipboardCheckSolid, () => ClipboardCheckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardCheckSolid[HMR].source;
    set(ClipboardCheckSolid[HMR].source, module.default[HMR].original);
  });
}
var ClipboardCheckSolid_default = ClipboardCheckSolid;
mark_module_end(ClipboardCheckSolid);

// node_modules/flowbite-svelte-icons/dist/ClipboardCleanOutline.svelte
mark_module_start();
ClipboardCleanOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardCleanOutline.svelte";
var root_1152 = add_locations(ns_template(`<title> </title>`), ClipboardCleanOutline[FILENAME], [[41, 4]]);
var root_2152 = add_locations(ns_template(`<desc> </desc>`), ClipboardCleanOutline[FILENAME], [[44, 4]]);
var root152 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 4h3a1 1 0 0 1 1 1v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3m0 3h6m-5-4v4h4V3h-4Z"></path></svg>`), ClipboardCleanOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ClipboardCleanOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClipboardCleanOutline);
  validate_prop_bindings($$props, [], [], ClipboardCleanOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "clipboard clean outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root152();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1152();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2152();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClipboardCleanOutline = hmr(ClipboardCleanOutline, () => ClipboardCleanOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardCleanOutline[HMR].source;
    set(ClipboardCleanOutline[HMR].source, module.default[HMR].original);
  });
}
var ClipboardCleanOutline_default = ClipboardCleanOutline;
mark_module_end(ClipboardCleanOutline);

// node_modules/flowbite-svelte-icons/dist/ClipboardCleanSolid.svelte
mark_module_start();
ClipboardCleanSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardCleanSolid.svelte";
var root_1153 = add_locations(ns_template(`<title> </title>`), ClipboardCleanSolid[FILENAME], [[39, 4]]);
var root_2153 = add_locations(ns_template(`<desc> </desc>`), ClipboardCleanSolid[FILENAME], [[42, 4]]);
var root153 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1h2a2 2 0 0 1 2 2v15a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h2Zm6 1h-4v2H9a1 1 0 0 0 0 2h6a1 1 0 1 0 0-2h-1V4Z" clip-rule="evenodd"></path></svg>`), ClipboardCleanSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ClipboardCleanSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClipboardCleanSolid);
  validate_prop_bindings($$props, [], [], ClipboardCleanSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "clipboard clean solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root153();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1153();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2153();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClipboardCleanSolid = hmr(ClipboardCleanSolid, () => ClipboardCleanSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardCleanSolid[HMR].source;
    set(ClipboardCleanSolid[HMR].source, module.default[HMR].original);
  });
}
var ClipboardCleanSolid_default = ClipboardCleanSolid;
mark_module_end(ClipboardCleanSolid);

// node_modules/flowbite-svelte-icons/dist/ClipboardListOutline.svelte
mark_module_start();
ClipboardListOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardListOutline.svelte";
var root_1154 = add_locations(ns_template(`<title> </title>`), ClipboardListOutline[FILENAME], [[41, 4]]);
var root_2154 = add_locations(ns_template(`<desc> </desc>`), ClipboardListOutline[FILENAME], [[44, 4]]);
var root154 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 4h3a1 1 0 0 1 1 1v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3m0 3h6m-3 5h3m-6 0h.01M12 16h3m-6 0h.01M10 3v4h4V3h-4Z"></path></svg>`), ClipboardListOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ClipboardListOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClipboardListOutline);
  validate_prop_bindings($$props, [], [], ClipboardListOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "clipboard list outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root154();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1154();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2154();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClipboardListOutline = hmr(ClipboardListOutline, () => ClipboardListOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardListOutline[HMR].source;
    set(ClipboardListOutline[HMR].source, module.default[HMR].original);
  });
}
var ClipboardListOutline_default = ClipboardListOutline;
mark_module_end(ClipboardListOutline);

// node_modules/flowbite-svelte-icons/dist/ClipboardListSolid.svelte
mark_module_start();
ClipboardListSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardListSolid.svelte";
var root_1155 = add_locations(ns_template(`<title> </title>`), ClipboardListSolid[FILENAME], [[39, 4]]);
var root_2155 = add_locations(ns_template(`<desc> </desc>`), ClipboardListSolid[FILENAME], [[42, 4]]);
var root155 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1h2a2 2 0 0 1 2 2v15a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h2Zm6 1h-4v2H9a1 1 0 0 0 0 2h6a1 1 0 1 0 0-2h-1V4Zm-3 8a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm-2-1a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H9Zm2 5a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm-2-1a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H9Z" clip-rule="evenodd"></path></svg>`), ClipboardListSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ClipboardListSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClipboardListSolid);
  validate_prop_bindings($$props, [], [], ClipboardListSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "clipboard list solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root155();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1155();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2155();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClipboardListSolid = hmr(ClipboardListSolid, () => ClipboardListSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardListSolid[HMR].source;
    set(ClipboardListSolid[HMR].source, module.default[HMR].original);
  });
}
var ClipboardListSolid_default = ClipboardListSolid;
mark_module_end(ClipboardListSolid);

// node_modules/flowbite-svelte-icons/dist/ClipboardOutline.svelte
mark_module_start();
ClipboardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardOutline.svelte";
var root_1156 = add_locations(ns_template(`<title> </title>`), ClipboardOutline[FILENAME], [[41, 4]]);
var root_2156 = add_locations(ns_template(`<desc> </desc>`), ClipboardOutline[FILENAME], [[44, 4]]);
var root156 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 4h3a1 1 0 0 1 1 1v15a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h3m0 3h6m-6 5h6m-6 4h6M10 3v4h4V3h-4Z"></path></svg>`), ClipboardOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ClipboardOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClipboardOutline);
  validate_prop_bindings($$props, [], [], ClipboardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "clipboard outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root156();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1156();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2156();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClipboardOutline = hmr(ClipboardOutline, () => ClipboardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardOutline[HMR].source;
    set(ClipboardOutline[HMR].source, module.default[HMR].original);
  });
}
var ClipboardOutline_default = ClipboardOutline;
mark_module_end(ClipboardOutline);

// node_modules/flowbite-svelte-icons/dist/ClipboardSolid.svelte
mark_module_start();
ClipboardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClipboardSolid.svelte";
var root_1157 = add_locations(ns_template(`<title> </title>`), ClipboardSolid[FILENAME], [[39, 4]]);
var root_2157 = add_locations(ns_template(`<desc> </desc>`), ClipboardSolid[FILENAME], [[42, 4]]);
var root157 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1h2a2 2 0 0 1 2 2v15a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h2Zm6 1h-4v2H9a1 1 0 0 0 0 2h6a1 1 0 1 0 0-2h-1V4Zm-6 8a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm1 3a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Z" clip-rule="evenodd"></path></svg>`), ClipboardSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ClipboardSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClipboardSolid);
  validate_prop_bindings($$props, [], [], ClipboardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "clipboard solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root157();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1157();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2157();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClipboardSolid = hmr(ClipboardSolid, () => ClipboardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClipboardSolid[HMR].source;
    set(ClipboardSolid[HMR].source, module.default[HMR].original);
  });
}
var ClipboardSolid_default = ClipboardSolid;
mark_module_end(ClipboardSolid);

// node_modules/flowbite-svelte-icons/dist/ClockOutline.svelte
mark_module_start();
ClockOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClockOutline.svelte";
var root_1158 = add_locations(ns_template(`<title> </title>`), ClockOutline[FILENAME], [[41, 4]]);
var root_2158 = add_locations(ns_template(`<desc> </desc>`), ClockOutline[FILENAME], [[44, 4]]);
var root158 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), ClockOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ClockOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClockOutline);
  validate_prop_bindings($$props, [], [], ClockOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "clock outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root158();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1158();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2158();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClockOutline = hmr(ClockOutline, () => ClockOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClockOutline[HMR].source;
    set(ClockOutline[HMR].source, module.default[HMR].original);
  });
}
var ClockOutline_default = ClockOutline;
mark_module_end(ClockOutline);

// node_modules/flowbite-svelte-icons/dist/ClockSolid.svelte
mark_module_start();
ClockSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ClockSolid.svelte";
var root_1159 = add_locations(ns_template(`<title> </title>`), ClockSolid[FILENAME], [[39, 4]]);
var root_2159 = add_locations(ns_template(`<desc> </desc>`), ClockSolid[FILENAME], [[42, 4]]);
var root159 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm11-4a1 1 0 1 0-2 0v4a1 1 0 0 0 .293.707l3 3a1 1 0 0 0 1.414-1.414L13 11.586V8Z" clip-rule="evenodd"></path></svg>`), ClockSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ClockSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ClockSolid);
  validate_prop_bindings($$props, [], [], ClockSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "clock solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root159();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1159();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2159();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ClockSolid = hmr(ClockSolid, () => ClockSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ClockSolid[HMR].source;
    set(ClockSolid[HMR].source, module.default[HMR].original);
  });
}
var ClockSolid_default = ClockSolid;
mark_module_end(ClockSolid);

// node_modules/flowbite-svelte-icons/dist/CloseCircleOutline.svelte
mark_module_start();
CloseCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseCircleOutline.svelte";
var root_1160 = add_locations(ns_template(`<title> </title>`), CloseCircleOutline[FILENAME], [[41, 4]]);
var root_2160 = add_locations(ns_template(`<desc> </desc>`), CloseCircleOutline[FILENAME], [[44, 4]]);
var root160 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m15 9-6 6m0-6 6 6m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), CloseCircleOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CloseCircleOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CloseCircleOutline);
  validate_prop_bindings($$props, [], [], CloseCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "close circle outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root160();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1160();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2160();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CloseCircleOutline = hmr(CloseCircleOutline, () => CloseCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseCircleOutline[HMR].source;
    set(CloseCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var CloseCircleOutline_default = CloseCircleOutline;
mark_module_end(CloseCircleOutline);

// node_modules/flowbite-svelte-icons/dist/CloseCircleSolid.svelte
mark_module_start();
CloseCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseCircleSolid.svelte";
var root_1161 = add_locations(ns_template(`<title> </title>`), CloseCircleSolid[FILENAME], [[39, 4]]);
var root_2161 = add_locations(ns_template(`<desc> </desc>`), CloseCircleSolid[FILENAME], [[42, 4]]);
var root161 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm7.707-3.707a1 1 0 0 0-1.414 1.414L10.586 12l-2.293 2.293a1 1 0 1 0 1.414 1.414L12 13.414l2.293 2.293a1 1 0 0 0 1.414-1.414L13.414 12l2.293-2.293a1 1 0 0 0-1.414-1.414L12 10.586 9.707 8.293Z" clip-rule="evenodd"></path></svg>`), CloseCircleSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CloseCircleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CloseCircleSolid);
  validate_prop_bindings($$props, [], [], CloseCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "close circle solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root161();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1161();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2161();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CloseCircleSolid = hmr(CloseCircleSolid, () => CloseCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseCircleSolid[HMR].source;
    set(CloseCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var CloseCircleSolid_default = CloseCircleSolid;
mark_module_end(CloseCircleSolid);

// node_modules/flowbite-svelte-icons/dist/CloseOutline.svelte
mark_module_start();
CloseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloseOutline.svelte";
var root_1162 = add_locations(ns_template(`<title> </title>`), CloseOutline[FILENAME], [[41, 4]]);
var root_2162 = add_locations(ns_template(`<desc> </desc>`), CloseOutline[FILENAME], [[44, 4]]);
var root162 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 18 17.94 6M18 18 6.06 6"></path></svg>`), CloseOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CloseOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CloseOutline);
  validate_prop_bindings($$props, [], [], CloseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "close outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root162();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1162();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2162();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CloseOutline = hmr(CloseOutline, () => CloseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloseOutline[HMR].source;
    set(CloseOutline[HMR].source, module.default[HMR].original);
  });
}
var CloseOutline_default = CloseOutline;
mark_module_end(CloseOutline);

// node_modules/flowbite-svelte-icons/dist/CloudArrowUpOutline.svelte
mark_module_start();
CloudArrowUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloudArrowUpOutline.svelte";
var root_1163 = add_locations(ns_template(`<title> </title>`), CloudArrowUpOutline[FILENAME], [[41, 4]]);
var root_2163 = add_locations(ns_template(`<desc> </desc>`), CloudArrowUpOutline[FILENAME], [[44, 4]]);
var root163 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 17h3a3 3 0 0 0 0-6h-.025a5.56 5.56 0 0 0 .025-.5A5.5 5.5 0 0 0 7.207 9.021C7.137 9.017 7.071 9 7 9a4 4 0 1 0 0 8h2.167M12 19v-9m0 0-2 2m2-2 2 2"></path></svg>`), CloudArrowUpOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CloudArrowUpOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CloudArrowUpOutline);
  validate_prop_bindings($$props, [], [], CloudArrowUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "cloud arrow up outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root163();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1163();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2163();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CloudArrowUpOutline = hmr(CloudArrowUpOutline, () => CloudArrowUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloudArrowUpOutline[HMR].source;
    set(CloudArrowUpOutline[HMR].source, module.default[HMR].original);
  });
}
var CloudArrowUpOutline_default = CloudArrowUpOutline;
mark_module_end(CloudArrowUpOutline);

// node_modules/flowbite-svelte-icons/dist/CloudArrowUpSolid.svelte
mark_module_start();
CloudArrowUpSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CloudArrowUpSolid.svelte";
var root_1164 = add_locations(ns_template(`<title> </title>`), CloudArrowUpSolid[FILENAME], [[39, 4]]);
var root_2164 = add_locations(ns_template(`<desc> </desc>`), CloudArrowUpSolid[FILENAME], [[42, 4]]);
var root164 = add_locations(ns_template(`<svg><!><!><path d="M13.383 4.076a6.5 6.5 0 0 0-6.887 3.95A5 5 0 0 0 7 18h3v-4a2 2 0 0 1-1.414-3.414l2-2a2 2 0 0 1 2.828 0l2 2A2 2 0 0 1 14 14v4h4a4 4 0 0 0 .988-7.876 6.5 6.5 0 0 0-5.605-6.048Z"></path><path d="M12.707 9.293a1 1 0 0 0-1.414 0l-2 2a1 1 0 1 0 1.414 1.414l.293-.293V19a1 1 0 1 0 2 0v-6.586l.293.293a1 1 0 0 0 1.414-1.414l-2-2Z"></path></svg>`), CloudArrowUpSolid[FILENAME], [
  [29, 0, [[44, 2], [47, 2]]]
]);
function CloudArrowUpSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CloudArrowUpSolid);
  validate_prop_bindings($$props, [], [], CloudArrowUpSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "cloud arrow up solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root164();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1164();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2164();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CloudArrowUpSolid = hmr(CloudArrowUpSolid, () => CloudArrowUpSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CloudArrowUpSolid[HMR].source;
    set(CloudArrowUpSolid[HMR].source, module.default[HMR].original);
  });
}
var CloudArrowUpSolid_default = CloudArrowUpSolid;
mark_module_end(CloudArrowUpSolid);

// node_modules/flowbite-svelte-icons/dist/CodeBranchOutline.svelte
mark_module_start();
CodeBranchOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeBranchOutline.svelte";
var root_1165 = add_locations(ns_template(`<title> </title>`), CodeBranchOutline[FILENAME], [[41, 4]]);
var root_2165 = add_locations(ns_template(`<desc> </desc>`), CodeBranchOutline[FILENAME], [[44, 4]]);
var root165 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 8v8m0-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm8-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 0a4 4 0 0 1-4 4h-1a3 3 0 0 0-3 3"></path></svg>`), CodeBranchOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CodeBranchOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CodeBranchOutline);
  validate_prop_bindings($$props, [], [], CodeBranchOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "code branch outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root165();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1165();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2165();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodeBranchOutline = hmr(CodeBranchOutline, () => CodeBranchOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeBranchOutline[HMR].source;
    set(CodeBranchOutline[HMR].source, module.default[HMR].original);
  });
}
var CodeBranchOutline_default = CodeBranchOutline;
mark_module_end(CodeBranchOutline);

// node_modules/flowbite-svelte-icons/dist/CodeBranchSolid.svelte
mark_module_start();
CodeBranchSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeBranchSolid.svelte";
var root_1166 = add_locations(ns_template(`<title> </title>`), CodeBranchSolid[FILENAME], [[39, 4]]);
var root_2166 = add_locations(ns_template(`<desc> </desc>`), CodeBranchSolid[FILENAME], [[42, 4]]);
var root166 = add_locations(ns_template(`<svg><!><!><path d="M8 3a3 3 0 0 0-1 5.83v6.34a3.001 3.001 0 1 0 2 0V15a2 2 0 0 1 2-2h1a5.002 5.002 0 0 0 4.927-4.146A3.001 3.001 0 0 0 16 3a3 3 0 0 0-1.105 5.79A3.001 3.001 0 0 1 12 11h-1c-.729 0-1.412.195-2 .535V8.83A3.001 3.001 0 0 0 8 3Z"></path></svg>`), CodeBranchSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CodeBranchSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CodeBranchSolid);
  validate_prop_bindings($$props, [], [], CodeBranchSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "code branch solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root166();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1166();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2166();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodeBranchSolid = hmr(CodeBranchSolid, () => CodeBranchSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeBranchSolid[HMR].source;
    set(CodeBranchSolid[HMR].source, module.default[HMR].original);
  });
}
var CodeBranchSolid_default = CodeBranchSolid;
mark_module_end(CodeBranchSolid);

// node_modules/flowbite-svelte-icons/dist/CodeForkOutline.svelte
mark_module_start();
CodeForkOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeForkOutline.svelte";
var root_1167 = add_locations(ns_template(`<title> </title>`), CodeForkOutline[FILENAME], [[41, 4]]);
var root_2167 = add_locations(ns_template(`<desc> </desc>`), CodeForkOutline[FILENAME], [[44, 4]]);
var root167 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 12v4m0 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4ZM8 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 0v2a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V8m0 0a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z"></path></svg>`), CodeForkOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CodeForkOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CodeForkOutline);
  validate_prop_bindings($$props, [], [], CodeForkOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "code fork outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root167();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1167();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2167();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodeForkOutline = hmr(CodeForkOutline, () => CodeForkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeForkOutline[HMR].source;
    set(CodeForkOutline[HMR].source, module.default[HMR].original);
  });
}
var CodeForkOutline_default = CodeForkOutline;
mark_module_end(CodeForkOutline);

// node_modules/flowbite-svelte-icons/dist/CodeForkSolid.svelte
mark_module_start();
CodeForkSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeForkSolid.svelte";
var root_1168 = add_locations(ns_template(`<title> </title>`), CodeForkSolid[FILENAME], [[39, 4]]);
var root_2168 = add_locations(ns_template(`<desc> </desc>`), CodeForkSolid[FILENAME], [[42, 4]]);
var root168 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 6a3 3 0 1 1 4 2.83V10a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1V8.83a3.001 3.001 0 1 1 2 0V10a3 3 0 0 1-3 3h-1v2.17a3.001 3.001 0 1 1-2 0V13h-1a3 3 0 0 1-3-3V8.83A3.001 3.001 0 0 1 5 6Z" clip-rule="evenodd"></path></svg>`), CodeForkSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CodeForkSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CodeForkSolid);
  validate_prop_bindings($$props, [], [], CodeForkSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "code fork solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root168();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1168();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2168();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodeForkSolid = hmr(CodeForkSolid, () => CodeForkSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeForkSolid[HMR].source;
    set(CodeForkSolid[HMR].source, module.default[HMR].original);
  });
}
var CodeForkSolid_default = CodeForkSolid;
mark_module_end(CodeForkSolid);

// node_modules/flowbite-svelte-icons/dist/CodeMergeOutline.svelte
mark_module_start();
CodeMergeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeMergeOutline.svelte";
var root_1169 = add_locations(ns_template(`<title> </title>`), CodeMergeOutline[FILENAME], [[41, 4]]);
var root_2169 = add_locations(ns_template(`<desc> </desc>`), CodeMergeOutline[FILENAME], [[44, 4]]);
var root169 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 8v8m0-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm6-2a2 2 0 1 1 4 0 2 2 0 0 1-4 0Zm0 0h-1a5 5 0 0 1-5-5v-.5"></path></svg>`), CodeMergeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CodeMergeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CodeMergeOutline);
  validate_prop_bindings($$props, [], [], CodeMergeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "code merge outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root169();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1169();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2169();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodeMergeOutline = hmr(CodeMergeOutline, () => CodeMergeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeMergeOutline[HMR].source;
    set(CodeMergeOutline[HMR].source, module.default[HMR].original);
  });
}
var CodeMergeOutline_default = CodeMergeOutline;
mark_module_end(CodeMergeOutline);

// node_modules/flowbite-svelte-icons/dist/CodeMergeSolid.svelte
mark_module_start();
CodeMergeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeMergeSolid.svelte";
var root_1170 = add_locations(ns_template(`<title> </title>`), CodeMergeSolid[FILENAME], [[39, 4]]);
var root_2170 = add_locations(ns_template(`<desc> </desc>`), CodeMergeSolid[FILENAME], [[42, 4]]);
var root170 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 6a3 3 0 1 1 4 2.83V9a4 4 0 0 0 4 4h.17a3.001 3.001 0 1 1 0 2H13a5.978 5.978 0 0 1-4-1.528v1.699a3.001 3.001 0 1 1-2 0V8.829A3.001 3.001 0 0 1 5 6Z" clip-rule="evenodd"></path></svg>`), CodeMergeSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CodeMergeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CodeMergeSolid);
  validate_prop_bindings($$props, [], [], CodeMergeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "code merge solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root170();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1170();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2170();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodeMergeSolid = hmr(CodeMergeSolid, () => CodeMergeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeMergeSolid[HMR].source;
    set(CodeMergeSolid[HMR].source, module.default[HMR].original);
  });
}
var CodeMergeSolid_default = CodeMergeSolid;
mark_module_end(CodeMergeSolid);

// node_modules/flowbite-svelte-icons/dist/CodeOutline.svelte
mark_module_start();
CodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodeOutline.svelte";
var root_1171 = add_locations(ns_template(`<title> </title>`), CodeOutline[FILENAME], [[41, 4]]);
var root_2171 = add_locations(ns_template(`<desc> </desc>`), CodeOutline[FILENAME], [[44, 4]]);
var root171 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 8-4 4 4 4m8 0 4-4-4-4m-2-3-4 14"></path></svg>`), CodeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CodeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CodeOutline);
  validate_prop_bindings($$props, [], [], CodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "code outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root171();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1171();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2171();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodeOutline = hmr(CodeOutline, () => CodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodeOutline[HMR].source;
    set(CodeOutline[HMR].source, module.default[HMR].original);
  });
}
var CodeOutline_default = CodeOutline;
mark_module_end(CodeOutline);

// node_modules/flowbite-svelte-icons/dist/CodePullRequestOutline.svelte
mark_module_start();
CodePullRequestOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodePullRequestOutline.svelte";
var root_1172 = add_locations(ns_template(`<title> </title>`), CodePullRequestOutline[FILENAME], [[41, 4]]);
var root_2172 = add_locations(ns_template(`<desc> </desc>`), CodePullRequestOutline[FILENAME], [[44, 4]]);
var root172 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 8v8m0-8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm12 0a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm0 0V9a3 3 0 0 0-3-3h-3m1.5-2-2 2 2 2"></path></svg>`), CodePullRequestOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CodePullRequestOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CodePullRequestOutline);
  validate_prop_bindings($$props, [], [], CodePullRequestOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "code pull request outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root172();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1172();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2172();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodePullRequestOutline = hmr(CodePullRequestOutline, () => CodePullRequestOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodePullRequestOutline[HMR].source;
    set(CodePullRequestOutline[HMR].source, module.default[HMR].original);
  });
}
var CodePullRequestOutline_default = CodePullRequestOutline;
mark_module_end(CodePullRequestOutline);

// node_modules/flowbite-svelte-icons/dist/CodePullRequestSolid.svelte
mark_module_start();
CodePullRequestSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CodePullRequestSolid.svelte";
var root_1173 = add_locations(ns_template(`<title> </title>`), CodePullRequestSolid[FILENAME], [[39, 4]]);
var root_2173 = add_locations(ns_template(`<desc> </desc>`), CodePullRequestSolid[FILENAME], [[42, 4]]);
var root173 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M3 6a3 3 0 1 1 4 2.83v6.34a3.001 3.001 0 1 1-2 0V8.83A3.001 3.001 0 0 1 3 6Zm11.207-2.707a1 1 0 0 1 0 1.414L13.914 5H15a4 4 0 0 1 4 4v6.17a3.001 3.001 0 1 1-2 0V9a2 2 0 0 0-2-2h-1.086l.293.293a1 1 0 0 1-1.414 1.414l-2-2a1 1 0 0 1 0-1.414l2-2a1 1 0 0 1 1.414 0Z" clip-rule="evenodd"></path></svg>`), CodePullRequestSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CodePullRequestSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CodePullRequestSolid);
  validate_prop_bindings($$props, [], [], CodePullRequestSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "code pull request solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root173();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1173();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2173();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CodePullRequestSolid = hmr(CodePullRequestSolid, () => CodePullRequestSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CodePullRequestSolid[HMR].source;
    set(CodePullRequestSolid[HMR].source, module.default[HMR].original);
  });
}
var CodePullRequestSolid_default = CodePullRequestSolid;
mark_module_end(CodePullRequestSolid);

// node_modules/flowbite-svelte-icons/dist/CogOutline.svelte
mark_module_start();
CogOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CogOutline.svelte";
var root_1174 = add_locations(ns_template(`<title> </title>`), CogOutline[FILENAME], [[41, 4]]);
var root_2174 = add_locations(ns_template(`<desc> </desc>`), CogOutline[FILENAME], [[44, 4]]);
var root174 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M21 13v-2a1 1 0 0 0-1-1h-.757l-.707-1.707.535-.536a1 1 0 0 0 0-1.414l-1.414-1.414a1 1 0 0 0-1.414 0l-.536.535L14 4.757V4a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v.757l-1.707.707-.536-.535a1 1 0 0 0-1.414 0L4.929 6.343a1 1 0 0 0 0 1.414l.536.536L4.757 10H4a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h.757l.707 1.707-.535.536a1 1 0 0 0 0 1.414l1.414 1.414a1 1 0 0 0 1.414 0l.536-.535 1.707.707V20a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-.757l1.707-.708.536.536a1 1 0 0 0 1.414 0l1.414-1.414a1 1 0 0 0 0-1.414l-.535-.536.707-1.707H20a1 1 0 0 0 1-1Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"></path></svg>`), CogOutline[FILENAME], [
  [30, 0, [[46, 2], [53, 2]]]
]);
function CogOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CogOutline);
  validate_prop_bindings($$props, [], [], CogOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "cog outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root174();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1174();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2174();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CogOutline = hmr(CogOutline, () => CogOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CogOutline[HMR].source;
    set(CogOutline[HMR].source, module.default[HMR].original);
  });
}
var CogOutline_default = CogOutline;
mark_module_end(CogOutline);

// node_modules/flowbite-svelte-icons/dist/CogSolid.svelte
mark_module_start();
CogSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CogSolid.svelte";
var root_1175 = add_locations(ns_template(`<title> </title>`), CogSolid[FILENAME], [[39, 4]]);
var root_2175 = add_locations(ns_template(`<desc> </desc>`), CogSolid[FILENAME], [[42, 4]]);
var root175 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9.586 2.586A2 2 0 0 1 11 2h2a2 2 0 0 1 2 2v.089l.473.196.063-.063a2.002 2.002 0 0 1 2.828 0l1.414 1.414a2 2 0 0 1 0 2.827l-.063.064.196.473H20a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-.089l-.196.473.063.063a2.002 2.002 0 0 1 0 2.828l-1.414 1.414a2 2 0 0 1-2.828 0l-.063-.063-.473.196V20a2 2 0 0 1-2 2h-2a2 2 0 0 1-2-2v-.089l-.473-.196-.063.063a2.002 2.002 0 0 1-2.828 0l-1.414-1.414a2 2 0 0 1 0-2.827l.063-.064L4.089 15H4a2 2 0 0 1-2-2v-2a2 2 0 0 1 2-2h.09l.195-.473-.063-.063a2 2 0 0 1 0-2.828l1.414-1.414a2 2 0 0 1 2.827 0l.064.063L9 4.089V4a2 2 0 0 1 .586-1.414ZM8 12a4 4 0 1 1 8 0 4 4 0 0 1-8 0Z" clip-rule="evenodd"></path></svg>`), CogSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CogSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CogSolid);
  validate_prop_bindings($$props, [], [], CogSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "cog solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root175();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1175();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2175();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CogSolid = hmr(CogSolid, () => CogSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CogSolid[HMR].source;
    set(CogSolid[HMR].source, module.default[HMR].original);
  });
}
var CogSolid_default = CogSolid;
mark_module_end(CogSolid);

// node_modules/flowbite-svelte-icons/dist/ColumnOutline.svelte
mark_module_start();
ColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ColumnOutline.svelte";
var root_1176 = add_locations(ns_template(`<title> </title>`), ColumnOutline[FILENAME], [[41, 4]]);
var root_2176 = add_locations(ns_template(`<desc> </desc>`), ColumnOutline[FILENAME], [[44, 4]]);
var root176 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 5v14M9 5v14M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), ColumnOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ColumnOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ColumnOutline);
  validate_prop_bindings($$props, [], [], ColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "column outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root176();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1176();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2176();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ColumnOutline = hmr(ColumnOutline, () => ColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ColumnOutline[HMR].source;
    set(ColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var ColumnOutline_default = ColumnOutline;
mark_module_end(ColumnOutline);

// node_modules/flowbite-svelte-icons/dist/ColumnSolid.svelte
mark_module_start();
ColumnSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ColumnSolid.svelte";
var root_1177 = add_locations(ns_template(`<title> </title>`), ColumnSolid[FILENAME], [[39, 4]]);
var root_2177 = add_locations(ns_template(`<desc> </desc>`), ColumnSolid[FILENAME], [[42, 4]]);
var root177 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M15 4H9v16h6V4Zm2 16h3a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-3v16ZM4 4h3v16H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2Z" clip-rule="evenodd"></path></svg>`), ColumnSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ColumnSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ColumnSolid);
  validate_prop_bindings($$props, [], [], ColumnSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "column solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root177();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1177();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2177();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ColumnSolid = hmr(ColumnSolid, () => ColumnSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ColumnSolid[HMR].source;
    set(ColumnSolid[HMR].source, module.default[HMR].original);
  });
}
var ColumnSolid_default = ColumnSolid;
mark_module_end(ColumnSolid);

// node_modules/flowbite-svelte-icons/dist/CommandOutline.svelte
mark_module_start();
CommandOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CommandOutline.svelte";
var root_1178 = add_locations(ns_template(`<title> </title>`), CommandOutline[FILENAME], [[41, 4]]);
var root_2178 = add_locations(ns_template(`<desc> </desc>`), CommandOutline[FILENAME], [[44, 4]]);
var root178 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 8v8m0-8h8M8 8H6a2 2 0 1 1 2-2v2Zm0 8h8m-8 0H6a2 2 0 1 0 2 2v-2Zm8 0V8m0 8h2a2 2 0 1 1-2 2v-2Zm0-8h2a2 2 0 1 0-2-2v2Z"></path></svg>`), CommandOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CommandOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CommandOutline);
  validate_prop_bindings($$props, [], [], CommandOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "command outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root178();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1178();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2178();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CommandOutline = hmr(CommandOutline, () => CommandOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CommandOutline[HMR].source;
    set(CommandOutline[HMR].source, module.default[HMR].original);
  });
}
var CommandOutline_default = CommandOutline;
mark_module_end(CommandOutline);

// node_modules/flowbite-svelte-icons/dist/CompressOutline.svelte
mark_module_start();
CompressOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CompressOutline.svelte";
var root_1179 = add_locations(ns_template(`<title> </title>`), CompressOutline[FILENAME], [[41, 4]]);
var root_2179 = add_locations(ns_template(`<desc> </desc>`), CompressOutline[FILENAME], [[44, 4]]);
var root179 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 8h4V4m12 4h-4V4M4 16h4v4m12-4h-4v4"></path></svg>`), CompressOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CompressOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CompressOutline);
  validate_prop_bindings($$props, [], [], CompressOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "compress outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root179();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1179();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2179();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CompressOutline = hmr(CompressOutline, () => CompressOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CompressOutline[HMR].source;
    set(CompressOutline[HMR].source, module.default[HMR].original);
  });
}
var CompressOutline_default = CompressOutline;
mark_module_end(CompressOutline);

// node_modules/flowbite-svelte-icons/dist/ComputerSpeakerOutline.svelte
mark_module_start();
ComputerSpeakerOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ComputerSpeakerOutline.svelte";
var root_1180 = add_locations(ns_template(`<title> </title>`), ComputerSpeakerOutline[FILENAME], [[41, 4]]);
var root_2180 = add_locations(ns_template(`<desc> </desc>`), ComputerSpeakerOutline[FILENAME], [[44, 4]]);
var root180 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 16H5a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v1M9 12H4m8 8V9h8v11h-8Zm0 0H9m8-4a1 1 0 1 0-2 0 1 1 0 0 0 2 0Z"></path></svg>`), ComputerSpeakerOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ComputerSpeakerOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ComputerSpeakerOutline);
  validate_prop_bindings($$props, [], [], ComputerSpeakerOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "computer speaker outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root180();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1180();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2180();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ComputerSpeakerOutline = hmr(ComputerSpeakerOutline, () => ComputerSpeakerOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ComputerSpeakerOutline[HMR].source;
    set(ComputerSpeakerOutline[HMR].source, module.default[HMR].original);
  });
}
var ComputerSpeakerOutline_default = ComputerSpeakerOutline;
mark_module_end(ComputerSpeakerOutline);

// node_modules/flowbite-svelte-icons/dist/ComputerSpeakerSolid.svelte
mark_module_start();
ComputerSpeakerSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ComputerSpeakerSolid.svelte";
var root_1181 = add_locations(ns_template(`<title> </title>`), ComputerSpeakerSolid[FILENAME], [[39, 4]]);
var root_2181 = add_locations(ns_template(`<desc> </desc>`), ComputerSpeakerSolid[FILENAME], [[42, 4]]);
var root181 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 8a1 1 0 0 0-1 1v10H9a1 1 0 1 0 0 2h11a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-8Zm4 10a2 2 0 1 1 0-4 2 2 0 0 1 0 4Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v6h6V9a3 3 0 0 1 3-3h8c.35 0 .687.06 1 .17V5a2 2 0 0 0-2-2H5Zm4 10H3v2a2 2 0 0 0 2 2h4v-4Z" clip-rule="evenodd"></path></svg>`), ComputerSpeakerSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function ComputerSpeakerSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ComputerSpeakerSolid);
  validate_prop_bindings($$props, [], [], ComputerSpeakerSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "computer speaker solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root181();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1181();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2181();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ComputerSpeakerSolid = hmr(ComputerSpeakerSolid, () => ComputerSpeakerSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ComputerSpeakerSolid[HMR].source;
    set(ComputerSpeakerSolid[HMR].source, module.default[HMR].original);
  });
}
var ComputerSpeakerSolid_default = ComputerSpeakerSolid;
mark_module_end(ComputerSpeakerSolid);

// node_modules/flowbite-svelte-icons/dist/CreditCardOutline.svelte
mark_module_start();
CreditCardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardOutline.svelte";
var root_1182 = add_locations(ns_template(`<title> </title>`), CreditCardOutline[FILENAME], [[41, 4]]);
var root_2182 = add_locations(ns_template(`<desc> </desc>`), CreditCardOutline[FILENAME], [[44, 4]]);
var root182 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 10h18M6 14h2m3 0h5M3 7v10a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1Z"></path></svg>`), CreditCardOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CreditCardOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CreditCardOutline);
  validate_prop_bindings($$props, [], [], CreditCardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "credit card outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root182();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1182();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2182();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CreditCardOutline = hmr(CreditCardOutline, () => CreditCardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardOutline[HMR].source;
    set(CreditCardOutline[HMR].source, module.default[HMR].original);
  });
}
var CreditCardOutline_default = CreditCardOutline;
mark_module_end(CreditCardOutline);

// node_modules/flowbite-svelte-icons/dist/CreditCardPlusAltOutline.svelte
mark_module_start();
CreditCardPlusAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardPlusAltOutline.svelte";
var root_1183 = add_locations(ns_template(`<title> </title>`), CreditCardPlusAltOutline[FILENAME], [[41, 4]]);
var root_2183 = add_locations(ns_template(`<desc> </desc>`), CreditCardPlusAltOutline[FILENAME], [[44, 4]]);
var root183 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 14h2m3 0h4m2 2h2m0 0h2m-2 0v2m0-2v-2m-5 4H4c-.55228 0-1-.4477-1-1V7c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v4M3 10h18"></path></svg>`), CreditCardPlusAltOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CreditCardPlusAltOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CreditCardPlusAltOutline);
  validate_prop_bindings($$props, [], [], CreditCardPlusAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "credit card plus alt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root183();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1183();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2183();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CreditCardPlusAltOutline = hmr(CreditCardPlusAltOutline, () => CreditCardPlusAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardPlusAltOutline[HMR].source;
    set(CreditCardPlusAltOutline[HMR].source, module.default[HMR].original);
  });
}
var CreditCardPlusAltOutline_default = CreditCardPlusAltOutline;
mark_module_end(CreditCardPlusAltOutline);

// node_modules/flowbite-svelte-icons/dist/CreditCardPlusAltSolid.svelte
mark_module_start();
CreditCardPlusAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardPlusAltSolid.svelte";
var root_1184 = add_locations(ns_template(`<title> </title>`), CreditCardPlusAltSolid[FILENAME], [[39, 4]]);
var root_2184 = add_locations(ns_template(`<desc> </desc>`), CreditCardPlusAltSolid[FILENAME], [[42, 4]]);
var root184 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M2 7c0-1.10457.89543-2 2-2h16c1.1046 0 2 .89543 2 2v4c0 .5523-.4477 1-1 1s-1-.4477-1-1v-1H4v7h10c.5523 0 1 .4477 1 1s-.4477 1-1 1H4c-1.10457 0-2-.8954-2-2V7Z"></path><path fill="currentColor" d="M5 14c0-.5523.44772-1 1-1h2c.55228 0 1 .4477 1 1s-.44772 1-1 1H6c-.55228 0-1-.4477-1-1Zm5 0c0-.5523.4477-1 1-1h4c.5523 0 1 .4477 1 1s-.4477 1-1 1h-4c-.5523 0-1-.4477-1-1Zm9-1c.5523 0 1 .4477 1 1v1h1c.5523 0 1 .4477 1 1s-.4477 1-1 1h-1v1c0 .5523-.4477 1-1 1s-1-.4477-1-1v-1h-1c-.5523 0-1-.4477-1-1s.4477-1 1-1h1v-1c0-.5523.4477-1 1-1Z"></path></svg>`), CreditCardPlusAltSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 2]]]
]);
function CreditCardPlusAltSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CreditCardPlusAltSolid);
  validate_prop_bindings($$props, [], [], CreditCardPlusAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "credit card plus alt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root184();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1184();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2184();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CreditCardPlusAltSolid = hmr(CreditCardPlusAltSolid, () => CreditCardPlusAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardPlusAltSolid[HMR].source;
    set(CreditCardPlusAltSolid[HMR].source, module.default[HMR].original);
  });
}
var CreditCardPlusAltSolid_default = CreditCardPlusAltSolid;
mark_module_end(CreditCardPlusAltSolid);

// node_modules/flowbite-svelte-icons/dist/CreditCardPlusOutline.svelte
mark_module_start();
CreditCardPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardPlusOutline.svelte";
var root_1185 = add_locations(ns_template(`<title> </title>`), CreditCardPlusOutline[FILENAME], [[41, 4]]);
var root_2185 = add_locations(ns_template(`<desc> </desc>`), CreditCardPlusOutline[FILENAME], [[44, 4]]);
var root185 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="square" stroke-linejoin="round" d="M16.5 15v1.5m0 0V18m0-1.5H15m1.5 0H18M3 9V6a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v3M3 9v6a1 1 0 0 0 1 1h5M3 9h16m0 0v1M6 12h3m12 4.5a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0Z"></path></svg>`), CreditCardPlusOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function CreditCardPlusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CreditCardPlusOutline);
  validate_prop_bindings($$props, [], [], CreditCardPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "credit card plus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root185();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1185();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2185();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CreditCardPlusOutline = hmr(CreditCardPlusOutline, () => CreditCardPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardPlusOutline[HMR].source;
    set(CreditCardPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var CreditCardPlusOutline_default = CreditCardPlusOutline;
mark_module_end(CreditCardPlusOutline);

// node_modules/flowbite-svelte-icons/dist/CreditCardPlusSolid.svelte
mark_module_start();
CreditCardPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardPlusSolid.svelte";
var root_1186 = add_locations(ns_template(`<title> </title>`), CreditCardPlusSolid[FILENAME], [[39, 4]]);
var root_2186 = add_locations(ns_template(`<desc> </desc>`), CreditCardPlusSolid[FILENAME], [[42, 4]]);
var root186 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M11 16.5a5.5 5.5 0 1 1 11 0 5.5 5.5 0 0 1-11 0Zm4.5 2.5v-1.5H14v-2h1.5V14h2v1.5H19v2h-1.5V19h-2Z" clip-rule="evenodd"></path><path d="M3.987 4A2 2 0 0 0 2 6v9a2 2 0 0 0 2 2h5v-2H4v-5h16V6a2 2 0 0 0-2-2H3.987Z"></path><path fill-rule="evenodd" d="M5 12a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), CreditCardPlusSolid[FILENAME], [
  [
    29,
    0,
    [[44, 2], [48, 5], [49, 2]]
  ]
]);
function CreditCardPlusSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CreditCardPlusSolid);
  validate_prop_bindings($$props, [], [], CreditCardPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "credit card plus solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root186();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1186();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2186();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(3);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CreditCardPlusSolid = hmr(CreditCardPlusSolid, () => CreditCardPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardPlusSolid[HMR].source;
    set(CreditCardPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var CreditCardPlusSolid_default = CreditCardPlusSolid;
mark_module_end(CreditCardPlusSolid);

// node_modules/flowbite-svelte-icons/dist/CreditCardSolid.svelte
mark_module_start();
CreditCardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CreditCardSolid.svelte";
var root_1187 = add_locations(ns_template(`<title> </title>`), CreditCardSolid[FILENAME], [[39, 4]]);
var root_2187 = add_locations(ns_template(`<desc> </desc>`), CreditCardSolid[FILENAME], [[42, 4]]);
var root187 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2H4Zm0 6h16v6H4v-6Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M5 14a1 1 0 0 1 1-1h2a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm5 0a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), CreditCardSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function CreditCardSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CreditCardSolid);
  validate_prop_bindings($$props, [], [], CreditCardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "credit card solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root187();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1187();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2187();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CreditCardSolid = hmr(CreditCardSolid, () => CreditCardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CreditCardSolid[HMR].source;
    set(CreditCardSolid[HMR].source, module.default[HMR].original);
  });
}
var CreditCardSolid_default = CreditCardSolid;
mark_module_end(CreditCardSolid);

// node_modules/flowbite-svelte-icons/dist/CssSolid.svelte
mark_module_start();
CssSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/CssSolid.svelte";
var root_1188 = add_locations(ns_template(`<title> </title>`), CssSolid[FILENAME], [[39, 4]]);
var root_2188 = add_locations(ns_template(`<desc> </desc>`), CssSolid[FILENAME], [[42, 4]]);
var root188 = add_locations(ns_template(`<svg><!><!><path d="m3 2 1.578 17.834L12 22l7.468-2.165L21 2H3Zm13.3 14.722-4.293 1.204H12l-4.297-1.204-.297-3.167h2.108l.15 1.526 2.335.639 2.34-.64.245-3.05h-7.27l-.187-2.006h7.64l.174-2.006H6.924l-.176-2.006h10.506l-.954 10.71Z"></path></svg>`), CssSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function CssSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, CssSolid);
  validate_prop_bindings($$props, [], [], CssSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "css solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root188();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1188();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2188();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  CssSolid = hmr(CssSolid, () => CssSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = CssSolid[HMR].source;
    set(CssSolid[HMR].source, module.default[HMR].original);
  });
}
var CssSolid_default = CssSolid;
mark_module_end(CssSolid);

// node_modules/flowbite-svelte-icons/dist/DatabaseOutline.svelte
mark_module_start();
DatabaseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DatabaseOutline.svelte";
var root_1189 = add_locations(ns_template(`<title> </title>`), DatabaseOutline[FILENAME], [[41, 4]]);
var root_2189 = add_locations(ns_template(`<desc> </desc>`), DatabaseOutline[FILENAME], [[44, 4]]);
var root189 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 6c0 1.657-3.134 3-7 3S5 7.657 5 6m14 0c0-1.657-3.134-3-7-3S5 4.343 5 6m14 0v6M5 6v6m0 0c0 1.657 3.134 3 7 3s7-1.343 7-3M5 12v6c0 1.657 3.134 3 7 3s7-1.343 7-3v-6"></path></svg>`), DatabaseOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function DatabaseOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DatabaseOutline);
  validate_prop_bindings($$props, [], [], DatabaseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "database outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root189();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1189();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2189();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DatabaseOutline = hmr(DatabaseOutline, () => DatabaseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DatabaseOutline[HMR].source;
    set(DatabaseOutline[HMR].source, module.default[HMR].original);
  });
}
var DatabaseOutline_default = DatabaseOutline;
mark_module_end(DatabaseOutline);

// node_modules/flowbite-svelte-icons/dist/DatabaseSolid.svelte
mark_module_start();
DatabaseSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DatabaseSolid.svelte";
var root_1190 = add_locations(ns_template(`<title> </title>`), DatabaseSolid[FILENAME], [[39, 4]]);
var root_2190 = add_locations(ns_template(`<desc> </desc>`), DatabaseSolid[FILENAME], [[42, 4]]);
var root190 = add_locations(ns_template(`<svg><!><!><path d="M12 7.205c4.418 0 8-1.165 8-2.602C20 3.165 16.418 2 12 2S4 3.165 4 4.603c0 1.437 3.582 2.602 8 2.602ZM12 22c4.963 0 8-1.686 8-2.603v-4.404c-.052.032-.112.06-.165.09a7.75 7.75 0 0 1-.745.387c-.193.088-.394.173-.6.253-.063.024-.124.05-.189.073a18.934 18.934 0 0 1-6.3.998c-2.135.027-4.26-.31-6.3-.998-.065-.024-.126-.05-.189-.073a10.143 10.143 0 0 1-.852-.373 7.75 7.75 0 0 1-.493-.267c-.053-.03-.113-.058-.165-.09v4.404C4 20.315 7.037 22 12 22Zm7.09-13.928a9.91 9.91 0 0 1-.6.253c-.063.025-.124.05-.189.074a18.935 18.935 0 0 1-6.3.998c-2.135.027-4.26-.31-6.3-.998-.065-.024-.126-.05-.189-.074a10.163 10.163 0 0 1-.852-.372 7.816 7.816 0 0 1-.493-.268c-.055-.03-.115-.058-.167-.09V12c0 .917 3.037 2.603 8 2.603s8-1.686 8-2.603V7.596c-.052.031-.112.059-.165.09a7.816 7.816 0 0 1-.745.386Z"></path></svg>`), DatabaseSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function DatabaseSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DatabaseSolid);
  validate_prop_bindings($$props, [], [], DatabaseSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "database solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root190();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1190();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2190();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DatabaseSolid = hmr(DatabaseSolid, () => DatabaseSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DatabaseSolid[HMR].source;
    set(DatabaseSolid[HMR].source, module.default[HMR].original);
  });
}
var DatabaseSolid_default = DatabaseSolid;
mark_module_end(DatabaseSolid);

// node_modules/flowbite-svelte-icons/dist/DeleteColumnOutline.svelte
mark_module_start();
DeleteColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DeleteColumnOutline.svelte";
var root_1191 = add_locations(ns_template(`<title> </title>`), DeleteColumnOutline[FILENAME], [[41, 4]]);
var root_2191 = add_locations(ns_template(`<desc> </desc>`), DeleteColumnOutline[FILENAME], [[44, 4]]);
var root191 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 5v14m-6-8h6m-6 4h6m4.506-1.494L15.012 12m0 0 1.506-1.506M15.012 12l1.506 1.506M15.012 12l-1.506-1.506M20 19H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1Z"></path></svg>`), DeleteColumnOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function DeleteColumnOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DeleteColumnOutline);
  validate_prop_bindings($$props, [], [], DeleteColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "delete column outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root191();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1191();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2191();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DeleteColumnOutline = hmr(DeleteColumnOutline, () => DeleteColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DeleteColumnOutline[HMR].source;
    set(DeleteColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var DeleteColumnOutline_default = DeleteColumnOutline;
mark_module_end(DeleteColumnOutline);

// node_modules/flowbite-svelte-icons/dist/DeleteRowOutline.svelte
mark_module_start();
DeleteRowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DeleteRowOutline.svelte";
var root_1192 = add_locations(ns_template(`<title> </title>`), DeleteRowOutline[FILENAME], [[41, 4]]);
var root_2192 = add_locations(ns_template(`<desc> </desc>`), DeleteRowOutline[FILENAME], [[44, 4]]);
var root192 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1v-3M3 15V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v9M3 15h18M8 15v4m4-4v4m4-4v4m-5.5061-7.4939L12 10m0 0 1.5061-1.50614M12 10l1.5061 1.5061M12 10l-1.5061-1.50614"></path></svg>`), DeleteRowOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function DeleteRowOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DeleteRowOutline);
  validate_prop_bindings($$props, [], [], DeleteRowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "delete row outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root192();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1192();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2192();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DeleteRowOutline = hmr(DeleteRowOutline, () => DeleteRowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DeleteRowOutline[HMR].source;
    set(DeleteRowOutline[HMR].source, module.default[HMR].original);
  });
}
var DeleteRowOutline_default = DeleteRowOutline;
mark_module_end(DeleteRowOutline);

// node_modules/flowbite-svelte-icons/dist/DeleteTableOutline.svelte
mark_module_start();
DeleteTableOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DeleteTableOutline.svelte";
var root_1193 = add_locations(ns_template(`<title> </title>`), DeleteTableOutline[FILENAME], [[41, 4]]);
var root_2193 = add_locations(ns_template(`<desc> </desc>`), DeleteTableOutline[FILENAME], [[44, 4]]);
var root193 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h10.5M3 15v-4m0 4h11M3 11V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v5M3 11h18m0 0v1M8 11v8m4-8v8m4-8v2m1.8956 5.9528 1.5047-1.5047m0 0 1.5048-1.5048m-1.5048 1.5048 1.4605 1.4604m-1.4605-1.4604-1.4604-1.4605"></path></svg>`), DeleteTableOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function DeleteTableOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DeleteTableOutline);
  validate_prop_bindings($$props, [], [], DeleteTableOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "delete table outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root193();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1193();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2193();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DeleteTableOutline = hmr(DeleteTableOutline, () => DeleteTableOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DeleteTableOutline[HMR].source;
    set(DeleteTableOutline[HMR].source, module.default[HMR].original);
  });
}
var DeleteTableOutline_default = DeleteTableOutline;
mark_module_end(DeleteTableOutline);

// node_modules/flowbite-svelte-icons/dist/DesktopPcOutline.svelte
mark_module_start();
DesktopPcOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DesktopPcOutline.svelte";
var root_1194 = add_locations(ns_template(`<title> </title>`), DesktopPcOutline[FILENAME], [[41, 4]]);
var root_2194 = add_locations(ns_template(`<desc> </desc>`), DesktopPcOutline[FILENAME], [[44, 4]]);
var root194 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 15v5m-3 0h6M4 11h16M5 15h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1Z"></path></svg>`), DesktopPcOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function DesktopPcOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DesktopPcOutline);
  validate_prop_bindings($$props, [], [], DesktopPcOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "desktop pc outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root194();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1194();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2194();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DesktopPcOutline = hmr(DesktopPcOutline, () => DesktopPcOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DesktopPcOutline[HMR].source;
    set(DesktopPcOutline[HMR].source, module.default[HMR].original);
  });
}
var DesktopPcOutline_default = DesktopPcOutline;
mark_module_end(DesktopPcOutline);

// node_modules/flowbite-svelte-icons/dist/DesktopPcSolid.svelte
mark_module_start();
DesktopPcSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DesktopPcSolid.svelte";
var root_1195 = add_locations(ns_template(`<title> </title>`), DesktopPcSolid[FILENAME], [[39, 4]]);
var root_2195 = add_locations(ns_template(`<desc> </desc>`), DesktopPcSolid[FILENAME], [[42, 4]]);
var root195 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v5h18V5a2 2 0 0 0-2-2H5ZM3 14v-2h18v2a2 2 0 0 1-2 2h-6v3h2a1 1 0 1 1 0 2H9a1 1 0 1 1 0-2h2v-3H5a2 2 0 0 1-2-2Z" clip-rule="evenodd"></path></svg>`), DesktopPcSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function DesktopPcSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DesktopPcSolid);
  validate_prop_bindings($$props, [], [], DesktopPcSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "desktop pc solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root195();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1195();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2195();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DesktopPcSolid = hmr(DesktopPcSolid, () => DesktopPcSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DesktopPcSolid[HMR].source;
    set(DesktopPcSolid[HMR].source, module.default[HMR].original);
  });
}
var DesktopPcSolid_default = DesktopPcSolid;
mark_module_end(DesktopPcSolid);

// node_modules/flowbite-svelte-icons/dist/DiscordSolid.svelte
mark_module_start();
DiscordSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DiscordSolid.svelte";
var root_1196 = add_locations(ns_template(`<title> </title>`), DiscordSolid[FILENAME], [[39, 4]]);
var root_2196 = add_locations(ns_template(`<desc> </desc>`), DiscordSolid[FILENAME], [[42, 4]]);
var root196 = add_locations(ns_template(`<svg><!><!><path d="M18.942 5.556a16.3 16.3 0 0 0-4.126-1.3 12.04 12.04 0 0 0-.529 1.1 15.175 15.175 0 0 0-4.573 0 11.586 11.586 0 0 0-.535-1.1 16.274 16.274 0 0 0-4.129 1.3 17.392 17.392 0 0 0-2.868 11.662 15.785 15.785 0 0 0 4.963 2.521c.41-.564.773-1.16 1.084-1.785a10.638 10.638 0 0 1-1.706-.83c.143-.106.283-.217.418-.331a11.664 11.664 0 0 0 10.118 0c.137.114.277.225.418.331-.544.328-1.116.606-1.71.832a12.58 12.58 0 0 0 1.084 1.785 16.46 16.46 0 0 0 5.064-2.595 17.286 17.286 0 0 0-2.973-11.59ZM8.678 14.813a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.918 1.918 0 0 1 1.8 2.047 1.929 1.929 0 0 1-1.8 2.045Zm6.644 0a1.94 1.94 0 0 1-1.8-2.045 1.93 1.93 0 0 1 1.8-2.047 1.919 1.919 0 0 1 1.8 2.047 1.93 1.93 0 0 1-1.8 2.045Z"></path></svg>`), DiscordSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function DiscordSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DiscordSolid);
  validate_prop_bindings($$props, [], [], DiscordSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "discord solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root196();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1196();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2196();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DiscordSolid = hmr(DiscordSolid, () => DiscordSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DiscordSolid[HMR].source;
    set(DiscordSolid[HMR].source, module.default[HMR].original);
  });
}
var DiscordSolid_default = DiscordSolid;
mark_module_end(DiscordSolid);

// node_modules/flowbite-svelte-icons/dist/DnaOutline.svelte
mark_module_start();
DnaOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DnaOutline.svelte";
var root_1197 = add_locations(ns_template(`<title> </title>`), DnaOutline[FILENAME], [[41, 4]]);
var root_2197 = add_locations(ns_template(`<desc> </desc>`), DnaOutline[FILENAME], [[44, 4]]);
var root197 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.041 13.862A4.999 4.999 0 0 1 17 17.831V21M7 3v3.169a5 5 0 0 0 1.891 3.916M17 3v3.169a5 5 0 0 1-2.428 4.288l-5.144 3.086A5 5 0 0 0 7 17.831V21M7 5h10M7.399 8h9.252M8 16h8.652M7 19h10"></path></svg>`), DnaOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function DnaOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DnaOutline);
  validate_prop_bindings($$props, [], [], DnaOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "dna outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root197();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1197();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2197();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DnaOutline = hmr(DnaOutline, () => DnaOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DnaOutline[HMR].source;
    set(DnaOutline[HMR].source, module.default[HMR].original);
  });
}
var DnaOutline_default = DnaOutline;
mark_module_end(DnaOutline);

// node_modules/flowbite-svelte-icons/dist/DollarOutline.svelte
mark_module_start();
DollarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DollarOutline.svelte";
var root_1198 = add_locations(ns_template(`<title> </title>`), DollarOutline[FILENAME], [[41, 4]]);
var root_2198 = add_locations(ns_template(`<desc> </desc>`), DollarOutline[FILENAME], [[44, 4]]);
var root198 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 17.345a4.76 4.76 0 0 0 2.558 1.618c2.274.589 4.512-.446 4.999-2.31.487-1.866-1.273-3.9-3.546-4.49-2.273-.59-4.034-2.623-3.547-4.488.486-1.865 2.724-2.899 4.998-2.31.982.236 1.87.793 2.538 1.592m-3.879 12.171V21m0-18v2.2"></path></svg>`), DollarOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function DollarOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DollarOutline);
  validate_prop_bindings($$props, [], [], DollarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "dollar outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root198();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1198();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2198();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DollarOutline = hmr(DollarOutline, () => DollarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DollarOutline[HMR].source;
    set(DollarOutline[HMR].source, module.default[HMR].original);
  });
}
var DollarOutline_default = DollarOutline;
mark_module_end(DollarOutline);

// node_modules/flowbite-svelte-icons/dist/DotsHorizontalOutline.svelte
mark_module_start();
DotsHorizontalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DotsHorizontalOutline.svelte";
var root_1199 = add_locations(ns_template(`<title> </title>`), DotsHorizontalOutline[FILENAME], [[40, 4]]);
var root_2199 = add_locations(ns_template(`<desc> </desc>`), DotsHorizontalOutline[FILENAME], [[43, 4]]);
var root199 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-width="3" d="M6 12h.01m6 0h.01m5.99 0h.01"></path></svg>`), DotsHorizontalOutline[FILENAME], [[29, 0, [[45, 2]]]]);
function DotsHorizontalOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DotsHorizontalOutline);
  validate_prop_bindings($$props, [], [], DotsHorizontalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "dots horizontal outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root199();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1199();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2199();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DotsHorizontalOutline = hmr(DotsHorizontalOutline, () => DotsHorizontalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DotsHorizontalOutline[HMR].source;
    set(DotsHorizontalOutline[HMR].source, module.default[HMR].original);
  });
}
var DotsHorizontalOutline_default = DotsHorizontalOutline;
mark_module_end(DotsHorizontalOutline);

// node_modules/flowbite-svelte-icons/dist/DotsVerticalOutline.svelte
mark_module_start();
DotsVerticalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DotsVerticalOutline.svelte";
var root_1200 = add_locations(ns_template(`<title> </title>`), DotsVerticalOutline[FILENAME], [[40, 4]]);
var root_2200 = add_locations(ns_template(`<desc> </desc>`), DotsVerticalOutline[FILENAME], [[43, 4]]);
var root200 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-width="3" d="M12 6h.01M12 12h.01M12 18h.01"></path></svg>`), DotsVerticalOutline[FILENAME], [[29, 0, [[45, 2]]]]);
function DotsVerticalOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DotsVerticalOutline);
  validate_prop_bindings($$props, [], [], DotsVerticalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "dots vertical outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root200();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1200();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2200();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DotsVerticalOutline = hmr(DotsVerticalOutline, () => DotsVerticalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DotsVerticalOutline[HMR].source;
    set(DotsVerticalOutline[HMR].source, module.default[HMR].original);
  });
}
var DotsVerticalOutline_default = DotsVerticalOutline;
mark_module_end(DotsVerticalOutline);

// node_modules/flowbite-svelte-icons/dist/DownloadOutline.svelte
mark_module_start();
DownloadOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DownloadOutline.svelte";
var root_1201 = add_locations(ns_template(`<title> </title>`), DownloadOutline[FILENAME], [[41, 4]]);
var root_2201 = add_locations(ns_template(`<desc> </desc>`), DownloadOutline[FILENAME], [[44, 4]]);
var root201 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 13V4M7 14H5a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1h-2m-1-5-4 5-4-5m9 8h.01"></path></svg>`), DownloadOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function DownloadOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DownloadOutline);
  validate_prop_bindings($$props, [], [], DownloadOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "download outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root201();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1201();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2201();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DownloadOutline = hmr(DownloadOutline, () => DownloadOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DownloadOutline[HMR].source;
    set(DownloadOutline[HMR].source, module.default[HMR].original);
  });
}
var DownloadOutline_default = DownloadOutline;
mark_module_end(DownloadOutline);

// node_modules/flowbite-svelte-icons/dist/DownloadSolid.svelte
mark_module_start();
DownloadSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DownloadSolid.svelte";
var root_1202 = add_locations(ns_template(`<title> </title>`), DownloadSolid[FILENAME], [[39, 4]]);
var root_2202 = add_locations(ns_template(`<desc> </desc>`), DownloadSolid[FILENAME], [[42, 4]]);
var root202 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M13 11.15V4a1 1 0 1 0-2 0v7.15L8.78 8.374a1 1 0 1 0-1.56 1.25l4 5a1 1 0 0 0 1.56 0l4-5a1 1 0 1 0-1.56-1.25L13 11.15Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M9.657 15.874 7.358 13H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2h-2.358l-2.3 2.874a3 3 0 0 1-4.685 0ZM17 16a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H17Z" clip-rule="evenodd"></path></svg>`), DownloadSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function DownloadSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DownloadSolid);
  validate_prop_bindings($$props, [], [], DownloadSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "download solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root202();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1202();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2202();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DownloadSolid = hmr(DownloadSolid, () => DownloadSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DownloadSolid[HMR].source;
    set(DownloadSolid[HMR].source, module.default[HMR].original);
  });
}
var DownloadSolid_default = DownloadSolid;
mark_module_end(DownloadSolid);

// node_modules/flowbite-svelte-icons/dist/DrawSquareOutline.svelte
mark_module_start();
DrawSquareOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DrawSquareOutline.svelte";
var root_1203 = add_locations(ns_template(`<title> </title>`), DrawSquareOutline[FILENAME], [[41, 4]]);
var root_2203 = add_locations(ns_template(`<desc> </desc>`), DrawSquareOutline[FILENAME], [[44, 4]]);
var root203 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 6.5h2M11 18h2m-7-5v-2m12 2v-2M5 8h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1Zm0 12h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1Zm12 0h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1Zm0-12h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-2a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1Z"></path></svg>`), DrawSquareOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function DrawSquareOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DrawSquareOutline);
  validate_prop_bindings($$props, [], [], DrawSquareOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "draw square outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root203();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1203();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2203();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DrawSquareOutline = hmr(DrawSquareOutline, () => DrawSquareOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DrawSquareOutline[HMR].source;
    set(DrawSquareOutline[HMR].source, module.default[HMR].original);
  });
}
var DrawSquareOutline_default = DrawSquareOutline;
mark_module_end(DrawSquareOutline);

// node_modules/flowbite-svelte-icons/dist/DrawSquareSolid.svelte
mark_module_start();
DrawSquareSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DrawSquareSolid.svelte";
var root_1204 = add_locations(ns_template(`<title> </title>`), DrawSquareSolid[FILENAME], [[39, 4]]);
var root_2204 = add_locations(ns_template(`<desc> </desc>`), DrawSquareSolid[FILENAME], [[42, 4]]);
var root204 = add_locations(ns_template(`<svg><!><!><path d="M5 3a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2H5Zm0 12a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2H5Zm12 0a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2h-2Zm0-12a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-2Z"></path><path fill-rule="evenodd" d="M10 6.5a1 1 0 0 1 1-1h2a1 1 0 1 1 0 2h-2a1 1 0 0 1-1-1ZM10 18a1 1 0 0 1 1-1h2a1 1 0 1 1 0 2h-2a1 1 0 0 1-1-1Zm-4-4a1 1 0 0 1-1-1v-2a1 1 0 1 1 2 0v2a1 1 0 0 1-1 1Zm12 0a1 1 0 0 1-1-1v-2a1 1 0 1 1 2 0v2a1 1 0 0 1-1 1Z" clip-rule="evenodd"></path></svg>`), DrawSquareSolid[FILENAME], [
  [29, 0, [[44, 2], [47, 2]]]
]);
function DrawSquareSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DrawSquareSolid);
  validate_prop_bindings($$props, [], [], DrawSquareSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "draw square solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root204();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1204();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2204();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DrawSquareSolid = hmr(DrawSquareSolid, () => DrawSquareSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DrawSquareSolid[HMR].source;
    set(DrawSquareSolid[HMR].source, module.default[HMR].original);
  });
}
var DrawSquareSolid_default = DrawSquareSolid;
mark_module_end(DrawSquareSolid);

// node_modules/flowbite-svelte-icons/dist/DribbbleSolid.svelte
mark_module_start();
DribbbleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DribbbleSolid.svelte";
var root_1205 = add_locations(ns_template(`<title> </title>`), DribbbleSolid[FILENAME], [[39, 4]]);
var root_2205 = add_locations(ns_template(`<desc> </desc>`), DribbbleSolid[FILENAME], [[42, 4]]);
var root205 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 2a10 10 0 1 0 10 10A10.009 10.009 0 0 0 12 2Zm6.613 4.614a8.523 8.523 0 0 1 1.93 5.32 20.093 20.093 0 0 0-5.949-.274c-.059-.149-.122-.292-.184-.441a23.879 23.879 0 0 0-.566-1.239 11.41 11.41 0 0 0 4.769-3.366ZM10 3.707a8.82 8.82 0 0 1 2-.238 8.5 8.5 0 0 1 5.664 2.152 9.608 9.608 0 0 1-4.476 3.087A45.755 45.755 0 0 0 10 3.707Zm-6.358 6.555a8.57 8.57 0 0 1 4.73-5.981 53.99 53.99 0 0 1 3.168 4.941 32.078 32.078 0 0 1-7.9 1.04h.002Zm2.01 7.46a8.51 8.51 0 0 1-2.2-5.707v-.262a31.641 31.641 0 0 0 8.777-1.219c.243.477.477.964.692 1.449-.114.032-.227.067-.336.1a13.569 13.569 0 0 0-6.942 5.636l.009.003ZM12 20.556a8.508 8.508 0 0 1-5.243-1.8 11.717 11.717 0 0 1 6.7-5.332.509.509 0 0 1 .055-.02 35.65 35.65 0 0 1 1.819 6.476 8.476 8.476 0 0 1-3.331.676Zm4.772-1.462A37.232 37.232 0 0 0 15.113 13a12.513 12.513 0 0 1 5.321.364 8.56 8.56 0 0 1-3.66 5.73h-.002Z" clip-rule="evenodd"></path></svg>`), DribbbleSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function DribbbleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DribbbleSolid);
  validate_prop_bindings($$props, [], [], DribbbleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "dribbble solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root205();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1205();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2205();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DribbbleSolid = hmr(DribbbleSolid, () => DribbbleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DribbbleSolid[HMR].source;
    set(DribbbleSolid[HMR].source, module.default[HMR].original);
  });
}
var DribbbleSolid_default = DribbbleSolid;
mark_module_end(DribbbleSolid);

// node_modules/flowbite-svelte-icons/dist/DropboxSolid.svelte
mark_module_start();
DropboxSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/DropboxSolid.svelte";
var root_1206 = add_locations(ns_template(`<title> </title>`), DropboxSolid[FILENAME], [[39, 4]]);
var root_2206 = add_locations(ns_template(`<desc> </desc>`), DropboxSolid[FILENAME], [[42, 4]]);
var root206 = add_locations(ns_template(`<svg><!><!><path d="M12.013 6.175 7.006 9.369l5.007 3.194-5.007 3.193L2 12.545l5.006-3.193L2 6.175l5.006-3.194 5.007 3.194ZM6.981 17.806l5.006-3.193 5.006 3.193L11.987 21l-5.006-3.194Z"></path><path d="m12.013 12.545 5.006-3.194-5.006-3.176 4.98-3.194L22 6.175l-5.007 3.194L22 12.562l-5.007 3.194-4.98-3.211Z"></path></svg>`), DropboxSolid[FILENAME], [
  [29, 0, [[44, 2], [47, 2]]]
]);
function DropboxSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, DropboxSolid);
  validate_prop_bindings($$props, [], [], DropboxSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "dropbox solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root206();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1206();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2206();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  DropboxSolid = hmr(DropboxSolid, () => DropboxSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = DropboxSolid[HMR].source;
    set(DropboxSolid[HMR].source, module.default[HMR].original);
  });
}
var DropboxSolid_default = DropboxSolid;
mark_module_end(DropboxSolid);

// node_modules/flowbite-svelte-icons/dist/EditOutline.svelte
mark_module_start();
EditOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EditOutline.svelte";
var root_1207 = add_locations(ns_template(`<title> </title>`), EditOutline[FILENAME], [[41, 4]]);
var root_2207 = add_locations(ns_template(`<desc> </desc>`), EditOutline[FILENAME], [[44, 4]]);
var root207 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m14.304 4.844 2.852 2.852M7 7H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-4.5m2.409-9.91a2.017 2.017 0 0 1 0 2.853l-6.844 6.844L8 14l.713-3.565 6.844-6.844a2.015 2.015 0 0 1 2.852 0Z"></path></svg>`), EditOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function EditOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EditOutline);
  validate_prop_bindings($$props, [], [], EditOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "edit outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root207();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1207();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2207();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EditOutline = hmr(EditOutline, () => EditOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EditOutline[HMR].source;
    set(EditOutline[HMR].source, module.default[HMR].original);
  });
}
var EditOutline_default = EditOutline;
mark_module_end(EditOutline);

// node_modules/flowbite-svelte-icons/dist/EditSolid.svelte
mark_module_start();
EditSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EditSolid.svelte";
var root_1208 = add_locations(ns_template(`<title> </title>`), EditSolid[FILENAME], [[39, 4]]);
var root_2208 = add_locations(ns_template(`<desc> </desc>`), EditSolid[FILENAME], [[42, 4]]);
var root208 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M11.32 6.176H5c-1.105 0-2 .949-2 2.118v10.588C3 20.052 3.895 21 5 21h11c1.105 0 2-.948 2-2.118v-7.75l-3.914 4.144A2.46 2.46 0 0 1 12.81 16l-2.681.568c-1.75.37-3.292-1.263-2.942-3.115l.536-2.839c.097-.512.335-.983.684-1.352l2.914-3.086Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M19.846 4.318a2.148 2.148 0 0 0-.437-.692 2.014 2.014 0 0 0-.654-.463 1.92 1.92 0 0 0-1.544 0 2.014 2.014 0 0 0-.654.463l-.546.578 2.852 3.02.546-.579a2.14 2.14 0 0 0 .437-.692 2.244 2.244 0 0 0 0-1.635ZM17.45 8.721 14.597 5.7 9.82 10.76a.54.54 0 0 0-.137.27l-.536 2.84c-.07.37.239.696.588.622l2.682-.567a.492.492 0 0 0 .255-.145l4.778-5.06Z" clip-rule="evenodd"></path></svg>`), EditSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function EditSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EditSolid);
  validate_prop_bindings($$props, [], [], EditSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "edit solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root208();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1208();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2208();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EditSolid = hmr(EditSolid, () => EditSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EditSolid[HMR].source;
    set(EditSolid[HMR].source, module.default[HMR].original);
  });
}
var EditSolid_default = EditSolid;
mark_module_end(EditSolid);

// node_modules/flowbite-svelte-icons/dist/EnvelopeOpenOutline.svelte
mark_module_start();
EnvelopeOpenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EnvelopeOpenOutline.svelte";
var root_1209 = add_locations(ns_template(`<title> </title>`), EnvelopeOpenOutline[FILENAME], [[41, 4]]);
var root_2209 = add_locations(ns_template(`<desc> </desc>`), EnvelopeOpenOutline[FILENAME], [[44, 4]]);
var root209 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M21 8v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8m18 0-8.029-4.46a2 2 0 0 0-1.942 0L3 8m18 0-9 6.5L3 8"></path></svg>`), EnvelopeOpenOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function EnvelopeOpenOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EnvelopeOpenOutline);
  validate_prop_bindings($$props, [], [], EnvelopeOpenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "envelope open outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root209();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1209();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2209();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EnvelopeOpenOutline = hmr(EnvelopeOpenOutline, () => EnvelopeOpenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EnvelopeOpenOutline[HMR].source;
    set(EnvelopeOpenOutline[HMR].source, module.default[HMR].original);
  });
}
var EnvelopeOpenOutline_default = EnvelopeOpenOutline;
mark_module_end(EnvelopeOpenOutline);

// node_modules/flowbite-svelte-icons/dist/EnvelopeOpenSolid.svelte
mark_module_start();
EnvelopeOpenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EnvelopeOpenSolid.svelte";
var root_1210 = add_locations(ns_template(`<title> </title>`), EnvelopeOpenSolid[FILENAME], [[39, 4]]);
var root_2210 = add_locations(ns_template(`<desc> </desc>`), EnvelopeOpenSolid[FILENAME], [[42, 4]]);
var root210 = add_locations(ns_template(`<svg><!><!><path d="m3.62 6.389 8.396 6.724 8.638-6.572-7.69-4.29a1.975 1.975 0 0 0-1.928 0L3.62 6.39Z"></path><path d="m22 8.053-8.784 6.683a1.978 1.978 0 0 1-2.44-.031L2.02 7.693a1.091 1.091 0 0 0-.019.199v11.065C2 20.637 3.343 22 5 22h14c1.657 0 3-1.362 3-3.043V8.053Z"></path></svg>`), EnvelopeOpenSolid[FILENAME], [
  [29, 0, [[44, 2], [45, 2]]]
]);
function EnvelopeOpenSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EnvelopeOpenSolid);
  validate_prop_bindings($$props, [], [], EnvelopeOpenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "envelope open solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root210();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1210();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2210();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EnvelopeOpenSolid = hmr(EnvelopeOpenSolid, () => EnvelopeOpenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EnvelopeOpenSolid[HMR].source;
    set(EnvelopeOpenSolid[HMR].source, module.default[HMR].original);
  });
}
var EnvelopeOpenSolid_default = EnvelopeOpenSolid;
mark_module_end(EnvelopeOpenSolid);

// node_modules/flowbite-svelte-icons/dist/EnvelopeOutline.svelte
mark_module_start();
EnvelopeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EnvelopeOutline.svelte";
var root_1211 = add_locations(ns_template(`<title> </title>`), EnvelopeOutline[FILENAME], [[41, 4]]);
var root_2211 = add_locations(ns_template(`<desc> </desc>`), EnvelopeOutline[FILENAME], [[44, 4]]);
var root211 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m3.5 5.5 7.893 6.036a1 1 0 0 0 1.214 0L20.5 5.5M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), EnvelopeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function EnvelopeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EnvelopeOutline);
  validate_prop_bindings($$props, [], [], EnvelopeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "envelope outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root211();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1211();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2211();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EnvelopeOutline = hmr(EnvelopeOutline, () => EnvelopeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EnvelopeOutline[HMR].source;
    set(EnvelopeOutline[HMR].source, module.default[HMR].original);
  });
}
var EnvelopeOutline_default = EnvelopeOutline;
mark_module_end(EnvelopeOutline);

// node_modules/flowbite-svelte-icons/dist/EnvelopeSolid.svelte
mark_module_start();
EnvelopeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EnvelopeSolid.svelte";
var root_1212 = add_locations(ns_template(`<title> </title>`), EnvelopeSolid[FILENAME], [[39, 4]]);
var root_2212 = add_locations(ns_template(`<desc> </desc>`), EnvelopeSolid[FILENAME], [[42, 4]]);
var root212 = add_locations(ns_template(`<svg><!><!><path d="M2.038 5.61A2.01 2.01 0 0 0 2 6v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6c0-.12-.01-.238-.03-.352l-.866.65-7.89 6.032a2 2 0 0 1-2.429 0L2.884 6.288l-.846-.677Z"></path><path d="M20.677 4.117A1.996 1.996 0 0 0 20 4H4c-.225 0-.44.037-.642.105l.758.607L12 10.742 19.9 4.7l.777-.583Z"></path></svg>`), EnvelopeSolid[FILENAME], [
  [29, 0, [[44, 2], [47, 2]]]
]);
function EnvelopeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EnvelopeSolid);
  validate_prop_bindings($$props, [], [], EnvelopeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "envelope solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root212();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1212();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2212();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EnvelopeSolid = hmr(EnvelopeSolid, () => EnvelopeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EnvelopeSolid[HMR].source;
    set(EnvelopeSolid[HMR].source, module.default[HMR].original);
  });
}
var EnvelopeSolid_default = EnvelopeSolid;
mark_module_end(EnvelopeSolid);

// node_modules/flowbite-svelte-icons/dist/EuroOutline.svelte
mark_module_start();
EuroOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EuroOutline.svelte";
var root_1213 = add_locations(ns_template(`<title> </title>`), EuroOutline[FILENAME], [[41, 4]]);
var root_2213 = add_locations(ns_template(`<desc> </desc>`), EuroOutline[FILENAME], [[44, 4]]);
var root213 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 10h9.231M6 14h9.231M18 5.086A5.95 5.95 0 0 0 14.615 4c-3.738 0-6.769 3.582-6.769 8s3.031 8 6.769 8A5.94 5.94 0 0 0 18 18.916"></path></svg>`), EuroOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function EuroOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EuroOutline);
  validate_prop_bindings($$props, [], [], EuroOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "euro outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root213();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1213();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2213();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EuroOutline = hmr(EuroOutline, () => EuroOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EuroOutline[HMR].source;
    set(EuroOutline[HMR].source, module.default[HMR].original);
  });
}
var EuroOutline_default = EuroOutline;
mark_module_end(EuroOutline);

// node_modules/flowbite-svelte-icons/dist/ExclamationCircleOutline.svelte
mark_module_start();
ExclamationCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ExclamationCircleOutline.svelte";
var root_1214 = add_locations(ns_template(`<title> </title>`), ExclamationCircleOutline[FILENAME], [[41, 4]]);
var root_2214 = add_locations(ns_template(`<desc> </desc>`), ExclamationCircleOutline[FILENAME], [[44, 4]]);
var root214 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 13V8m0 8h.01M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), ExclamationCircleOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ExclamationCircleOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ExclamationCircleOutline);
  validate_prop_bindings($$props, [], [], ExclamationCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "exclamation circle outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root214();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1214();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2214();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ExclamationCircleOutline = hmr(ExclamationCircleOutline, () => ExclamationCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ExclamationCircleOutline[HMR].source;
    set(ExclamationCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var ExclamationCircleOutline_default = ExclamationCircleOutline;
mark_module_end(ExclamationCircleOutline);

// node_modules/flowbite-svelte-icons/dist/ExclamationCircleSolid.svelte
mark_module_start();
ExclamationCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ExclamationCircleSolid.svelte";
var root_1215 = add_locations(ns_template(`<title> </title>`), ExclamationCircleSolid[FILENAME], [[39, 4]]);
var root_2215 = add_locations(ns_template(`<desc> </desc>`), ExclamationCircleSolid[FILENAME], [[42, 4]]);
var root215 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm11-4a1 1 0 1 0-2 0v5a1 1 0 1 0 2 0V8Zm-1 7a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z" clip-rule="evenodd"></path></svg>`), ExclamationCircleSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ExclamationCircleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ExclamationCircleSolid);
  validate_prop_bindings($$props, [], [], ExclamationCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "exclamation circle solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root215();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1215();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2215();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ExclamationCircleSolid = hmr(ExclamationCircleSolid, () => ExclamationCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ExclamationCircleSolid[HMR].source;
    set(ExclamationCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var ExclamationCircleSolid_default = ExclamationCircleSolid;
mark_module_end(ExclamationCircleSolid);

// node_modules/flowbite-svelte-icons/dist/ExpandOutline.svelte
mark_module_start();
ExpandOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ExpandOutline.svelte";
var root_1216 = add_locations(ns_template(`<title> </title>`), ExpandOutline[FILENAME], [[41, 4]]);
var root_2216 = add_locations(ns_template(`<desc> </desc>`), ExpandOutline[FILENAME], [[44, 4]]);
var root216 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 4H4m0 0v4m0-4 5 5m7-5h4m0 0v4m0-4-5 5M8 20H4m0 0v-4m0 4 5-5m7 5h4m0 0v-4m0 4-5-5"></path></svg>`), ExpandOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ExpandOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ExpandOutline);
  validate_prop_bindings($$props, [], [], ExpandOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "expand outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root216();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1216();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2216();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ExpandOutline = hmr(ExpandOutline, () => ExpandOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ExpandOutline[HMR].source;
    set(ExpandOutline[HMR].source, module.default[HMR].original);
  });
}
var ExpandOutline_default = ExpandOutline;
mark_module_end(ExpandOutline);

// node_modules/flowbite-svelte-icons/dist/EyeOutline.svelte
mark_module_start();
EyeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EyeOutline.svelte";
var root_1217 = add_locations(ns_template(`<title> </title>`), EyeOutline[FILENAME], [[41, 4]]);
var root_2217 = add_locations(ns_template(`<desc> </desc>`), EyeOutline[FILENAME], [[44, 4]]);
var root217 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" d="M21 12c0 1.2-4.03 6-9 6s-9-4.8-9-6c0-1.2 4.03-6 9-6s9 4.8 9 6Z"></path><path stroke="currentColor" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), EyeOutline[FILENAME], [
  [30, 0, [[46, 2], [51, 2]]]
]);
function EyeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EyeOutline);
  validate_prop_bindings($$props, [], [], EyeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "eye outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root217();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1217();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2217();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EyeOutline = hmr(EyeOutline, () => EyeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EyeOutline[HMR].source;
    set(EyeOutline[HMR].source, module.default[HMR].original);
  });
}
var EyeOutline_default = EyeOutline;
mark_module_end(EyeOutline);

// node_modules/flowbite-svelte-icons/dist/EyeSlashOutline.svelte
mark_module_start();
EyeSlashOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EyeSlashOutline.svelte";
var root_1218 = add_locations(ns_template(`<title> </title>`), EyeSlashOutline[FILENAME], [[41, 4]]);
var root_2218 = add_locations(ns_template(`<desc> </desc>`), EyeSlashOutline[FILENAME], [[44, 4]]);
var root218 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3.933 13.909A4.357 4.357 0 0 1 3 12c0-1 4-6 9-6m7.6 3.8A5.068 5.068 0 0 1 21 12c0 1-3 6-9 6-.314 0-.62-.014-.918-.04M5 19 19 5m-4 7a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), EyeSlashOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function EyeSlashOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EyeSlashOutline);
  validate_prop_bindings($$props, [], [], EyeSlashOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "eye slash outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root218();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1218();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2218();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EyeSlashOutline = hmr(EyeSlashOutline, () => EyeSlashOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EyeSlashOutline[HMR].source;
    set(EyeSlashOutline[HMR].source, module.default[HMR].original);
  });
}
var EyeSlashOutline_default = EyeSlashOutline;
mark_module_end(EyeSlashOutline);

// node_modules/flowbite-svelte-icons/dist/EyeSlashSolid.svelte
mark_module_start();
EyeSlashSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EyeSlashSolid.svelte";
var root_1219 = add_locations(ns_template(`<title> </title>`), EyeSlashSolid[FILENAME], [[39, 4]]);
var root_2219 = add_locations(ns_template(`<desc> </desc>`), EyeSlashSolid[FILENAME], [[42, 4]]);
var root219 = add_locations(ns_template(`<svg><!><!><path d="m4 15.6 3.055-3.056A4.913 4.913 0 0 1 7 12.012a5.006 5.006 0 0 1 5-5c.178.009.356.027.532.054l1.744-1.744A8.973 8.973 0 0 0 12 5.012c-5.388 0-10 5.336-10 7A6.49 6.49 0 0 0 4 15.6Z"></path><path d="m14.7 10.726 4.995-5.007A.998.998 0 0 0 18.99 4a1 1 0 0 0-.71.305l-4.995 5.007a2.98 2.98 0 0 0-.588-.21l-.035-.01a2.981 2.981 0 0 0-3.584 3.583c0 .012.008.022.01.033.05.204.12.402.211.59l-4.995 4.983a1 1 0 1 0 1.414 1.414l4.995-4.983c.189.091.386.162.59.211.011 0 .021.007.033.01a2.982 2.982 0 0 0 3.584-3.584c0-.012-.008-.023-.011-.035a3.05 3.05 0 0 0-.21-.588Z"></path><path d="m19.821 8.605-2.857 2.857a4.952 4.952 0 0 1-5.514 5.514l-1.785 1.785c.767.166 1.55.25 2.335.251 6.453 0 10-5.258 10-7 0-1.166-1.637-2.874-2.179-3.407Z"></path></svg>`), EyeSlashSolid[FILENAME], [
  [
    29,
    0,
    [[44, 2], [47, 2], [50, 2]]
  ]
]);
function EyeSlashSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EyeSlashSolid);
  validate_prop_bindings($$props, [], [], EyeSlashSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "eye slash solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root219();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1219();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2219();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(3);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EyeSlashSolid = hmr(EyeSlashSolid, () => EyeSlashSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EyeSlashSolid[HMR].source;
    set(EyeSlashSolid[HMR].source, module.default[HMR].original);
  });
}
var EyeSlashSolid_default = EyeSlashSolid;
mark_module_end(EyeSlashSolid);

// node_modules/flowbite-svelte-icons/dist/EyeSolid.svelte
mark_module_start();
EyeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/EyeSolid.svelte";
var root_1220 = add_locations(ns_template(`<title> </title>`), EyeSolid[FILENAME], [[39, 4]]);
var root_2220 = add_locations(ns_template(`<desc> </desc>`), EyeSolid[FILENAME], [[42, 4]]);
var root220 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4.998 7.78C6.729 6.345 9.198 5 12 5c2.802 0 5.27 1.345 7.002 2.78a12.713 12.713 0 0 1 2.096 2.183c.253.344.465.682.618.997.14.286.284.658.284 1.04s-.145.754-.284 1.04a6.6 6.6 0 0 1-.618.997 12.712 12.712 0 0 1-2.096 2.183C17.271 17.655 14.802 19 12 19c-2.802 0-5.27-1.345-7.002-2.78a12.712 12.712 0 0 1-2.096-2.183 6.6 6.6 0 0 1-.618-.997C2.144 12.754 2 12.382 2 12s.145-.754.284-1.04c.153-.315.365-.653.618-.997A12.714 12.714 0 0 1 4.998 7.78ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" clip-rule="evenodd"></path></svg>`), EyeSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function EyeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, EyeSolid);
  validate_prop_bindings($$props, [], [], EyeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "eye solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root220();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1220();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2220();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  EyeSolid = hmr(EyeSolid, () => EyeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = EyeSolid[HMR].source;
    set(EyeSolid[HMR].source, module.default[HMR].original);
  });
}
var EyeSolid_default = EyeSolid;
mark_module_end(EyeSolid);

// node_modules/flowbite-svelte-icons/dist/FaceExplodeOutline.svelte
mark_module_start();
FaceExplodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceExplodeOutline.svelte";
var root_1221 = add_locations(ns_template(`<title> </title>`), FaceExplodeOutline[FILENAME], [[41, 4]]);
var root_2221 = add_locations(ns_template(`<desc> </desc>`), FaceExplodeOutline[FILENAME], [[44, 4]]);
var root221 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M12 17a2 2 0 0 1 2 2h-4a2 2 0 0 1 2-2Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.815 9H16.5a2 2 0 1 0-1.03-3.707A1.87 1.87 0 0 0 15.5 5 1.992 1.992 0 0 0 12 3.69 1.992 1.992 0 0 0 8.5 5c.002.098.012.196.03.293A2 2 0 1 0 7.5 9h3.388m2.927-.985v3.604M10.228 9v2.574M15 16h.01M9 16h.01m11.962-4.426a1.805 1.805 0 0 1-1.74 1.326 1.893 1.893 0 0 1-1.811-1.326 1.9 1.9 0 0 1-3.621 0 1.8 1.8 0 0 1-1.749 1.326 1.98 1.98 0 0 1-1.87-1.326A1.763 1.763 0 0 1 8.46 12.9a2.035 2.035 0 0 1-1.905-1.326A1.9 1.9 0 0 1 4.74 12.9 1.805 1.805 0 0 1 3 11.574V12a9 9 0 0 0 18 0l-.028-.426Z"></path></svg>`), FaceExplodeOutline[FILENAME], [
  [30, 0, [[46, 2], [47, 2]]]
]);
function FaceExplodeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FaceExplodeOutline);
  validate_prop_bindings($$props, [], [], FaceExplodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "face explode outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root221();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1221();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2221();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1, 2);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FaceExplodeOutline = hmr(FaceExplodeOutline, () => FaceExplodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceExplodeOutline[HMR].source;
    set(FaceExplodeOutline[HMR].source, module.default[HMR].original);
  });
}
var FaceExplodeOutline_default = FaceExplodeOutline;
mark_module_end(FaceExplodeOutline);

// node_modules/flowbite-svelte-icons/dist/FaceExplodeSolid.svelte
mark_module_start();
FaceExplodeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceExplodeSolid.svelte";
var root_1222 = add_locations(ns_template(`<title> </title>`), FaceExplodeSolid[FILENAME], [[39, 4]]);
var root_2222 = add_locations(ns_template(`<desc> </desc>`), FaceExplodeSolid[FILENAME], [[42, 4]]);
var root222 = add_locations(ns_template(`<svg><!><!><path d="M21.972 11.517a.527.527 0 0 0-1.034-.105 1.377 1.377 0 0 1-1.324 1.01 1.467 1.467 0 0 1-1.4-1.009.526.526 0 0 0-1.015 0 1.467 1.467 0 0 1-2.737.143l-.049-.204.021-.146V9.369h2.304a2.632 2.632 0 0 0 2.631-2.632 2.678 2.678 0 0 0-2.654-2.632l-.526.022-.13-.369A2.632 2.632 0 0 0 13.579 2c-.461 0-.915.124-1.313.358L12 2.513l-.266-.155A2.603 2.603 0 0 0 10.422 2a2.632 2.632 0 0 0-2.483 1.759l-.13.37-.518-.024a2.681 2.681 0 0 0-2.66 2.632A2.632 2.632 0 0 0 7.264 9.37H9.61v1.887l-.007.09-.028.08a1.328 1.328 0 0 1-1.301.996 1.632 1.632 0 0 1-1.502-1.024.526.526 0 0 0-1.01.013 1.474 1.474 0 0 1-1.404 1.01 1.381 1.381 0 0 1-1.325-1.01.547.547 0 0 0-.569-.382h-.008a.526.526 0 0 0-.456.526v.446a10.012 10.012 0 0 0 10 10 9.904 9.904 0 0 0 7.067-2.94A10.019 10.019 0 0 0 22 11.966l-.028-.449ZM8.316 15.685a1.053 1.053 0 1 1 2.105 0 1.053 1.053 0 0 1-2.105 0Zm1.58 3.684a2.105 2.105 0 0 1 4.21 0h-4.21Zm4.736-2.631a1.052 1.052 0 1 1 0-2.105 1.052 1.052 0 0 1 0 2.105Z"></path></svg>`), FaceExplodeSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FaceExplodeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FaceExplodeSolid);
  validate_prop_bindings($$props, [], [], FaceExplodeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "face explode solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root222();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1222();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2222();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FaceExplodeSolid = hmr(FaceExplodeSolid, () => FaceExplodeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceExplodeSolid[HMR].source;
    set(FaceExplodeSolid[HMR].source, module.default[HMR].original);
  });
}
var FaceExplodeSolid_default = FaceExplodeSolid;
mark_module_end(FaceExplodeSolid);

// node_modules/flowbite-svelte-icons/dist/FaceGrinOutline.svelte
mark_module_start();
FaceGrinOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceGrinOutline.svelte";
var root_1223 = add_locations(ns_template(`<title> </title>`), FaceGrinOutline[FILENAME], [[41, 4]]);
var root_2223 = add_locations(ns_template(`<desc> </desc>`), FaceGrinOutline[FILENAME], [[44, 4]]);
var root223 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14.99 9H15M8.99 9H9m12 3a9 9 0 1 1-18 0 9 9 0 0 1 18 0ZM7 13c0 1 .507 2.397 1.494 3.216a5.5 5.5 0 0 0 7.022 0C16.503 15.397 17 14 17 13c0 0-1.99 1-4.995 1S7 13 7 13Z"></path></svg>`), FaceGrinOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FaceGrinOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FaceGrinOutline);
  validate_prop_bindings($$props, [], [], FaceGrinOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "face grin outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root223();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1223();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2223();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FaceGrinOutline = hmr(FaceGrinOutline, () => FaceGrinOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceGrinOutline[HMR].source;
    set(FaceGrinOutline[HMR].source, module.default[HMR].original);
  });
}
var FaceGrinOutline_default = FaceGrinOutline;
mark_module_end(FaceGrinOutline);

// node_modules/flowbite-svelte-icons/dist/FaceGrinSolid.svelte
mark_module_start();
FaceGrinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceGrinSolid.svelte";
var root_1224 = add_locations(ns_template(`<title> </title>`), FaceGrinSolid[FILENAME], [[39, 4]]);
var root_2224 = add_locations(ns_template(`<desc> </desc>`), FaceGrinSolid[FILENAME], [[42, 4]]);
var root224 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm5.495.93A.5.5 0 0 0 6.5 13c0 1.19.644 2.438 1.618 3.375C9.099 17.319 10.469 18 12 18c1.531 0 2.9-.681 3.882-1.625.974-.937 1.618-2.184 1.618-3.375a.5.5 0 0 0-.995-.07.764.764 0 0 1-.156.096c-.214.106-.554.208-1.006.295-.896.173-2.111.262-3.343.262-1.232 0-2.447-.09-3.343-.262-.452-.087-.792-.19-1.005-.295a.762.762 0 0 1-.157-.096ZM8.99 8a1 1 0 0 0 0 2H9a1 1 0 1 0 0-2h-.01Zm6 0a1 1 0 1 0 0 2H15a1 1 0 1 0 0-2h-.01Z" clip-rule="evenodd"></path></svg>`), FaceGrinSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FaceGrinSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FaceGrinSolid);
  validate_prop_bindings($$props, [], [], FaceGrinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "face grin solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root224();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1224();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2224();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FaceGrinSolid = hmr(FaceGrinSolid, () => FaceGrinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceGrinSolid[HMR].source;
    set(FaceGrinSolid[HMR].source, module.default[HMR].original);
  });
}
var FaceGrinSolid_default = FaceGrinSolid;
mark_module_end(FaceGrinSolid);

// node_modules/flowbite-svelte-icons/dist/FaceGrinStarsOutline.svelte
mark_module_start();
FaceGrinStarsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceGrinStarsOutline.svelte";
var root_1225 = add_locations(ns_template(`<title> </title>`), FaceGrinStarsOutline[FILENAME], [[41, 4]]);
var root_2225 = add_locations(ns_template(`<desc> </desc>`), FaceGrinStarsOutline[FILENAME], [[44, 4]]);
var root225 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 21a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 13c0 2.038-2.239 4.5-5 4.5S7 15.038 7 13c0 1.444 10 1.444 10 0Z"></path><path fill="currentColor" d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m9 6.811.618 1.253 1.382.2-1 .975.236 1.377L9 9.966l-1.236.65L8 9.239l-1-.975 1.382-.2L9 6.811Zm6 0 .618 1.253 1.382.2-1 .975.236 1.377L15 9.966l-1.236.65L14 9.239l-1-.975 1.382-.2L15 6.811Z"></path></svg>`), FaceGrinStarsOutline[FILENAME], [
  [
    30,
    0,
    [
      [46, 2],
      [53, 2],
      [60, 2],
      [64, 2]
    ]
  ]
]);
function FaceGrinStarsOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FaceGrinStarsOutline);
  validate_prop_bindings($$props, [], [], FaceGrinStarsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "face grin stars outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root225();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1225();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2225();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  next(2);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FaceGrinStarsOutline = hmr(FaceGrinStarsOutline, () => FaceGrinStarsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceGrinStarsOutline[HMR].source;
    set(FaceGrinStarsOutline[HMR].source, module.default[HMR].original);
  });
}
var FaceGrinStarsOutline_default = FaceGrinStarsOutline;
mark_module_end(FaceGrinStarsOutline);

// node_modules/flowbite-svelte-icons/dist/FaceGrinStarsSolid.svelte
mark_module_start();
FaceGrinStarsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceGrinStarsSolid.svelte";
var root_1226 = add_locations(ns_template(`<title> </title>`), FaceGrinStarsSolid[FILENAME], [[39, 4]]);
var root_2226 = add_locations(ns_template(`<desc> </desc>`), FaceGrinStarsSolid[FILENAME], [[42, 4]]);
var root226 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2ZM7 12.5a.5.5 0 0 1 .495.43.762.762 0 0 0 .157.096c.213.106.553.208 1.005.295.896.173 2.111.262 3.343.262 1.232 0 2.447-.09 3.343-.262.452-.087.792-.19 1.006-.295a.764.764 0 0 0 .156-.096.5.5 0 0 1 .995.07c0 1.19-.644 2.438-1.618 3.375C14.9 17.319 13.531 18 12 18c-1.531 0-2.9-.681-3.882-1.625C7.144 15.438 6.5 14.19 6.5 13a.5.5 0 0 1 .5-.5Zm9.519.417.003-.004-.003.004Zm-9.038 0a.017.017 0 0 1-.003-.004l.003.004Zm.901-4.853L9 6.81l.619 1.253 1.381.2-1 .976.236 1.376-1.237-.65-1.235.65L8 9.239l-1-.975 1.382-.2Zm6 0L15 6.81l.619 1.253 1.381.2-1 .976.236 1.376-1.237-.65-1.235.65L14 9.239l-1-.975 1.382-.2Z" clip-rule="evenodd"></path></svg>`), FaceGrinStarsSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FaceGrinStarsSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FaceGrinStarsSolid);
  validate_prop_bindings($$props, [], [], FaceGrinStarsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "face grin stars solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root226();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1226();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2226();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FaceGrinStarsSolid = hmr(FaceGrinStarsSolid, () => FaceGrinStarsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceGrinStarsSolid[HMR].source;
    set(FaceGrinStarsSolid[HMR].source, module.default[HMR].original);
  });
}
var FaceGrinStarsSolid_default = FaceGrinStarsSolid;
mark_module_end(FaceGrinStarsSolid);

// node_modules/flowbite-svelte-icons/dist/FaceLaughOutline.svelte
mark_module_start();
FaceLaughOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceLaughOutline.svelte";
var root_1227 = add_locations(ns_template(`<title> </title>`), FaceLaughOutline[FILENAME], [[41, 4]]);
var root_2227 = add_locations(ns_template(`<desc> </desc>`), FaceLaughOutline[FILENAME], [[44, 4]]);
var root227 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 9h.01M8.99 9H9m12 3a9 9 0 1 1-18 0 9 9 0 0 1 18 0ZM6.6 13a5.5 5.5 0 0 0 10.81 0H6.6Z"></path></svg>`), FaceLaughOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FaceLaughOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FaceLaughOutline);
  validate_prop_bindings($$props, [], [], FaceLaughOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "face laugh outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root227();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1227();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2227();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FaceLaughOutline = hmr(FaceLaughOutline, () => FaceLaughOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceLaughOutline[HMR].source;
    set(FaceLaughOutline[HMR].source, module.default[HMR].original);
  });
}
var FaceLaughOutline_default = FaceLaughOutline;
mark_module_end(FaceLaughOutline);

// node_modules/flowbite-svelte-icons/dist/FaceLaughSolid.svelte
mark_module_start();
FaceLaughSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FaceLaughSolid.svelte";
var root_1228 = add_locations(ns_template(`<title> </title>`), FaceLaughSolid[FILENAME], [[39, 4]]);
var root_2228 = add_locations(ns_template(`<desc> </desc>`), FaceLaughSolid[FILENAME], [[42, 4]]);
var root228 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2ZM7.99 9a1 1 0 0 1 1-1H9a1 1 0 0 1 0 2h-.01a1 1 0 0 1-1-1ZM14 9a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H15a1 1 0 0 1-1-1Zm-5.506 7.216A5.5 5.5 0 0 1 6.6 13h10.81a5.5 5.5 0 0 1-8.916 3.216Z" clip-rule="evenodd"></path></svg>`), FaceLaughSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FaceLaughSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FaceLaughSolid);
  validate_prop_bindings($$props, [], [], FaceLaughSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "face laugh solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root228();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1228();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2228();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FaceLaughSolid = hmr(FaceLaughSolid, () => FaceLaughSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FaceLaughSolid[HMR].source;
    set(FaceLaughSolid[HMR].source, module.default[HMR].original);
  });
}
var FaceLaughSolid_default = FaceLaughSolid;
mark_module_end(FaceLaughSolid);

// node_modules/flowbite-svelte-icons/dist/FacebookSolid.svelte
mark_module_start();
FacebookSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FacebookSolid.svelte";
var root_1229 = add_locations(ns_template(`<title> </title>`), FacebookSolid[FILENAME], [[39, 4]]);
var root_2229 = add_locations(ns_template(`<desc> </desc>`), FacebookSolid[FILENAME], [[42, 4]]);
var root229 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M13.135 6H15V3h-1.865a4.147 4.147 0 0 0-4.142 4.142V9H7v3h2v9.938h3V12h2.021l.592-3H12V6.591A.6.6 0 0 1 12.592 6h.543Z" clip-rule="evenodd"></path></svg>`), FacebookSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FacebookSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FacebookSolid);
  validate_prop_bindings($$props, [], [], FacebookSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "facebook solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root229();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1229();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2229();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FacebookSolid = hmr(FacebookSolid, () => FacebookSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FacebookSolid[HMR].source;
    set(FacebookSolid[HMR].source, module.default[HMR].original);
  });
}
var FacebookSolid_default = FacebookSolid;
mark_module_end(FacebookSolid);

// node_modules/flowbite-svelte-icons/dist/FileChartBarOutline.svelte
mark_module_start();
FileChartBarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileChartBarOutline.svelte";
var root_1230 = add_locations(ns_template(`<title> </title>`), FileChartBarOutline[FILENAME], [[41, 4]]);
var root_2230 = add_locations(ns_template(`<desc> </desc>`), FileChartBarOutline[FILENAME], [[44, 4]]);
var root230 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m4 10v-2m3 2v-6m3 6v-3m4-11v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileChartBarOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileChartBarOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileChartBarOutline);
  validate_prop_bindings($$props, [], [], FileChartBarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file chart bar outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root230();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1230();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2230();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileChartBarOutline = hmr(FileChartBarOutline, () => FileChartBarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileChartBarOutline[HMR].source;
    set(FileChartBarOutline[HMR].source, module.default[HMR].original);
  });
}
var FileChartBarOutline_default = FileChartBarOutline;
mark_module_end(FileChartBarOutline);

// node_modules/flowbite-svelte-icons/dist/FileChartBarSolid.svelte
mark_module_start();
FileChartBarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileChartBarSolid.svelte";
var root_1231 = add_locations(ns_template(`<title> </title>`), FileChartBarSolid[FILENAME], [[39, 4]]);
var root_2231 = add_locations(ns_template(`<desc> </desc>`), FileChartBarSolid[FILENAME], [[42, 4]]);
var root231 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm-1 9a1 1 0 1 0-2 0v2a1 1 0 1 0 2 0v-2Zm2-5a1 1 0 0 1 1 1v6a1 1 0 1 1-2 0v-6a1 1 0 0 1 1-1Zm4 4a1 1 0 1 0-2 0v3a1 1 0 1 0 2 0v-3Z" clip-rule="evenodd"></path></svg>`), FileChartBarSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileChartBarSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileChartBarSolid);
  validate_prop_bindings($$props, [], [], FileChartBarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file chart bar solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root231();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1231();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2231();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileChartBarSolid = hmr(FileChartBarSolid, () => FileChartBarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileChartBarSolid[HMR].source;
    set(FileChartBarSolid[HMR].source, module.default[HMR].original);
  });
}
var FileChartBarSolid_default = FileChartBarSolid;
mark_module_end(FileChartBarSolid);

// node_modules/flowbite-svelte-icons/dist/FileCheckOutline.svelte
mark_module_start();
FileCheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCheckOutline.svelte";
var root_1232 = add_locations(ns_template(`<title> </title>`), FileCheckOutline[FILENAME], [[41, 4]]);
var root_2232 = add_locations(ns_template(`<desc> </desc>`), FileCheckOutline[FILENAME], [[44, 4]]);
var root232 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m4 6 2 2 4-4m4-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileCheckOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileCheckOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCheckOutline);
  validate_prop_bindings($$props, [], [], FileCheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file check outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root232();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1232();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2232();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCheckOutline = hmr(FileCheckOutline, () => FileCheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCheckOutline[HMR].source;
    set(FileCheckOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCheckOutline_default = FileCheckOutline;
mark_module_end(FileCheckOutline);

// node_modules/flowbite-svelte-icons/dist/FileCheckSolid.svelte
mark_module_start();
FileCheckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCheckSolid.svelte";
var root_1233 = add_locations(ns_template(`<title> </title>`), FileCheckSolid[FILENAME], [[39, 4]]);
var root_2233 = add_locations(ns_template(`<desc> </desc>`), FileCheckSolid[FILENAME], [[42, 4]]);
var root233 = add_locations(ns_template(`<svg><!><!><path d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Z"></path><path fill-rule="evenodd" d="M11 7V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm4.707 5.707a1 1 0 0 0-1.414-1.414L11 14.586l-1.293-1.293a1 1 0 0 0-1.414 1.414l2 2a1 1 0 0 0 1.414 0l4-4Z" clip-rule="evenodd"></path></svg>`), FileCheckSolid[FILENAME], [
  [29, 0, [[44, 2], [45, 2]]]
]);
function FileCheckSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCheckSolid);
  validate_prop_bindings($$props, [], [], FileCheckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file check solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root233();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1233();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2233();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCheckSolid = hmr(FileCheckSolid, () => FileCheckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCheckSolid[HMR].source;
    set(FileCheckSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCheckSolid_default = FileCheckSolid;
mark_module_end(FileCheckSolid);

// node_modules/flowbite-svelte-icons/dist/FileCirclePlusOutline.svelte
mark_module_start();
FileCirclePlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCirclePlusOutline.svelte";
var root_1234 = add_locations(ns_template(`<title> </title>`), FileCirclePlusOutline[FILENAME], [[41, 4]]);
var root_2234 = add_locations(ns_template(`<desc> </desc>`), FileCirclePlusOutline[FILENAME], [[44, 4]]);
var root234 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 9V4a1 1 0 0 0-1-1H8.914a1 1 0 0 0-.707.293L4.293 7.207A1 1 0 0 0 4 7.914V20a1 1 0 0 0 1 1h4M9 3v4a1 1 0 0 1-1 1H4m11 6v4m-2-2h4m3 0a5 5 0 1 1-10 0 5 5 0 0 1 10 0Z"></path></svg>`), FileCirclePlusOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileCirclePlusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCirclePlusOutline);
  validate_prop_bindings($$props, [], [], FileCirclePlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file circle plus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root234();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1234();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2234();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCirclePlusOutline = hmr(FileCirclePlusOutline, () => FileCirclePlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCirclePlusOutline[HMR].source;
    set(FileCirclePlusOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCirclePlusOutline_default = FileCirclePlusOutline;
mark_module_end(FileCirclePlusOutline);

// node_modules/flowbite-svelte-icons/dist/FileCirclePlusSolid.svelte
mark_module_start();
FileCirclePlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCirclePlusSolid.svelte";
var root_1235 = add_locations(ns_template(`<title> </title>`), FileCirclePlusSolid[FILENAME], [[39, 4]]);
var root_2235 = add_locations(ns_template(`<desc> </desc>`), FileCirclePlusSolid[FILENAME], [[42, 4]]);
var root235 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v6.41A7.5 7.5 0 1 0 10.5 22H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M9 16a6 6 0 1 1 12 0 6 6 0 0 1-12 0Zm6-3a1 1 0 0 1 1 1v1h1a1 1 0 1 1 0 2h-1v1a1 1 0 1 1-2 0v-1h-1a1 1 0 1 1 0-2h1v-1a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), FileCirclePlusSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function FileCirclePlusSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCirclePlusSolid);
  validate_prop_bindings($$props, [], [], FileCirclePlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file circle plus solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root235();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1235();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2235();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCirclePlusSolid = hmr(FileCirclePlusSolid, () => FileCirclePlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCirclePlusSolid[HMR].source;
    set(FileCirclePlusSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCirclePlusSolid_default = FileCirclePlusSolid;
mark_module_end(FileCirclePlusSolid);

// node_modules/flowbite-svelte-icons/dist/FileCloneOutline.svelte
mark_module_start();
FileCloneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCloneOutline.svelte";
var root_1236 = add_locations(ns_template(`<title> </title>`), FileCloneOutline[FILENAME], [[41, 4]]);
var root_2236 = add_locations(ns_template(`<desc> </desc>`), FileCloneOutline[FILENAME], [[44, 4]]);
var root236 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M15 4v3a1 1 0 0 1-1 1h-3m2 10v1a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-7.13a1 1 0 0 1 .24-.65L6.7 8.35A1 1 0 0 1 7.46 8H9m-1 4H4m16-7v10a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1V7.87a1 1 0 0 1 .24-.65l2.46-2.87a1 1 0 0 1 .76-.35H19a1 1 0 0 1 1 1Z"></path></svg>`), FileCloneOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileCloneOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCloneOutline);
  validate_prop_bindings($$props, [], [], FileCloneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file clone outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root236();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1236();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2236();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCloneOutline = hmr(FileCloneOutline, () => FileCloneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCloneOutline[HMR].source;
    set(FileCloneOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCloneOutline_default = FileCloneOutline;
mark_module_end(FileCloneOutline);

// node_modules/flowbite-svelte-icons/dist/FileCloneSolid.svelte
mark_module_start();
FileCloneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCloneSolid.svelte";
var root_1237 = add_locations(ns_template(`<title> </title>`), FileCloneSolid[FILENAME], [[39, 4]]);
var root_2237 = add_locations(ns_template(`<desc> </desc>`), FileCloneSolid[FILENAME], [[42, 4]]);
var root237 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 12.732A1.99 1.99 0 0 1 7 13H3v6a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2h-2a4 4 0 0 1-4-4v-2.268ZM7 11V7.054a2 2 0 0 0-1.059.644l-2.46 2.87A2 2 0 0 0 3.2 11H7Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M14 3.054V7h-3.8c.074-.154.168-.3.282-.432l2.46-2.87A2 2 0 0 1 14 3.054ZM16 3v4a2 2 0 0 1-2 2h-4v6a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), FileCloneSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function FileCloneSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCloneSolid);
  validate_prop_bindings($$props, [], [], FileCloneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file clone solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root237();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1237();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2237();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCloneSolid = hmr(FileCloneSolid, () => FileCloneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCloneSolid[HMR].source;
    set(FileCloneSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCloneSolid_default = FileCloneSolid;
mark_module_end(FileCloneSolid);

// node_modules/flowbite-svelte-icons/dist/FileCodeOutline.svelte
mark_module_start();
FileCodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCodeOutline.svelte";
var root_1238 = add_locations(ns_template(`<title> </title>`), FileCodeOutline[FILENAME], [[41, 4]]);
var root_2238 = add_locations(ns_template(`<desc> </desc>`), FileCodeOutline[FILENAME], [[44, 4]]);
var root238 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m5 4-2 2 2 2m4-4 2 2-2 2m5-12v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileCodeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileCodeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCodeOutline);
  validate_prop_bindings($$props, [], [], FileCodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file code outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root238();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1238();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2238();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCodeOutline = hmr(FileCodeOutline, () => FileCodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCodeOutline[HMR].source;
    set(FileCodeOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCodeOutline_default = FileCodeOutline;
mark_module_end(FileCodeOutline);

// node_modules/flowbite-svelte-icons/dist/FileCodeSolid.svelte
mark_module_start();
FileCodeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCodeSolid.svelte";
var root_1239 = add_locations(ns_template(`<title> </title>`), FileCodeSolid[FILENAME], [[39, 4]]);
var root_2239 = add_locations(ns_template(`<desc> </desc>`), FileCodeSolid[FILENAME], [[42, 4]]);
var root239 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7Zm-.293 9.293a1 1 0 0 1 0 1.414L9.414 14l1.293 1.293a1 1 0 0 1-1.414 1.414l-2-2a1 1 0 0 1 0-1.414l2-2a1 1 0 0 1 1.414 0Zm2.586 1.414a1 1 0 0 1 1.414-1.414l2 2a1 1 0 0 1 0 1.414l-2 2a1 1 0 0 1-1.414-1.414L14.586 14l-1.293-1.293Z" clip-rule="evenodd"></path></svg>`), FileCodeSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileCodeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCodeSolid);
  validate_prop_bindings($$props, [], [], FileCodeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file code solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root239();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1239();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2239();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCodeSolid = hmr(FileCodeSolid, () => FileCodeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCodeSolid[HMR].source;
    set(FileCodeSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCodeSolid_default = FileCodeSolid;
mark_module_end(FileCodeSolid);

// node_modules/flowbite-svelte-icons/dist/FileCopyAltOutline.svelte
mark_module_start();
FileCopyAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCopyAltOutline.svelte";
var root_1240 = add_locations(ns_template(`<title> </title>`), FileCopyAltOutline[FILENAME], [[41, 4]]);
var root_2240 = add_locations(ns_template(`<desc> </desc>`), FileCopyAltOutline[FILENAME], [[44, 4]]);
var root240 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M14 4v3a1 1 0 0 1-1 1h-3m4 10v1a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h2m11-3v10a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1V7.87a1 1 0 0 1 .24-.65l2.46-2.87a1 1 0 0 1 .76-.35H18a1 1 0 0 1 1 1Z"></path></svg>`), FileCopyAltOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileCopyAltOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCopyAltOutline);
  validate_prop_bindings($$props, [], [], FileCopyAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file copy alt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root240();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1240();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2240();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCopyAltOutline = hmr(FileCopyAltOutline, () => FileCopyAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCopyAltOutline[HMR].source;
    set(FileCopyAltOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCopyAltOutline_default = FileCopyAltOutline;
mark_module_end(FileCopyAltOutline);

// node_modules/flowbite-svelte-icons/dist/FileCopyAltSolid.svelte
mark_module_start();
FileCopyAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCopyAltSolid.svelte";
var root_1241 = add_locations(ns_template(`<title> </title>`), FileCopyAltSolid[FILENAME], [[39, 4]]);
var root_2241 = add_locations(ns_template(`<desc> </desc>`), FileCopyAltSolid[FILENAME], [[42, 4]]);
var root241 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M7 9v6a4 4 0 0 0 4 4h4a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h1v2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M13 3.054V7H9.2a2 2 0 0 1 .281-.432l2.46-2.87A2 2 0 0 1 13 3.054ZM15 3v4a2 2 0 0 1-2 2H9v6a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), FileCopyAltSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function FileCopyAltSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCopyAltSolid);
  validate_prop_bindings($$props, [], [], FileCopyAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file copy alt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root241();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1241();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2241();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCopyAltSolid = hmr(FileCopyAltSolid, () => FileCopyAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCopyAltSolid[HMR].source;
    set(FileCopyAltSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCopyAltSolid_default = FileCopyAltSolid;
mark_module_end(FileCopyAltSolid);

// node_modules/flowbite-svelte-icons/dist/FileCopyOutline.svelte
mark_module_start();
FileCopyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCopyOutline.svelte";
var root_1242 = add_locations(ns_template(`<title> </title>`), FileCopyOutline[FILENAME], [[41, 4]]);
var root_2242 = add_locations(ns_template(`<desc> </desc>`), FileCopyOutline[FILENAME], [[44, 4]]);
var root242 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M9 8v3a1 1 0 0 1-1 1H5m11 4h2a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-7a1 1 0 0 0-1 1v1m4 3v10a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-7.13a1 1 0 0 1 .24-.65L7.7 8.35A1 1 0 0 1 8.46 8H13a1 1 0 0 1 1 1Z"></path></svg>`), FileCopyOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileCopyOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCopyOutline);
  validate_prop_bindings($$props, [], [], FileCopyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file copy outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root242();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1242();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2242();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCopyOutline = hmr(FileCopyOutline, () => FileCopyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCopyOutline[HMR].source;
    set(FileCopyOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCopyOutline_default = FileCopyOutline;
mark_module_end(FileCopyOutline);

// node_modules/flowbite-svelte-icons/dist/FileCopySolid.svelte
mark_module_start();
FileCopySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCopySolid.svelte";
var root_1243 = add_locations(ns_template(`<title> </title>`), FileCopySolid[FILENAME], [[39, 4]]);
var root_2243 = add_locations(ns_template(`<desc> </desc>`), FileCopySolid[FILENAME], [[42, 4]]);
var root243 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M18 3a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1V9a4 4 0 0 0-4-4h-3a1.99 1.99 0 0 0-1 .267V5a2 2 0 0 1 2-2h7Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M8 7.054V11H4.2a2 2 0 0 1 .281-.432l2.46-2.87A2 2 0 0 1 8 7.054ZM10 7v4a2 2 0 0 1-2 2H4v6a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), FileCopySolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function FileCopySolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCopySolid);
  validate_prop_bindings($$props, [], [], FileCopySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file copy solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root243();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1243();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2243();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCopySolid = hmr(FileCopySolid, () => FileCopySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCopySolid[HMR].source;
    set(FileCopySolid[HMR].source, module.default[HMR].original);
  });
}
var FileCopySolid_default = FileCopySolid;
mark_module_end(FileCopySolid);

// node_modules/flowbite-svelte-icons/dist/FileCsvOutline.svelte
mark_module_start();
FileCsvOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCsvOutline.svelte";
var root_1244 = add_locations(ns_template(`<title> </title>`), FileCsvOutline[FILENAME], [[41, 4]]);
var root_2244 = add_locations(ns_template(`<desc> </desc>`), FileCsvOutline[FILENAME], [[44, 4]]);
var root244 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 10V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v6M5 19v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1M10 3v4a1 1 0 0 1-1 1H5m2.665 9H6.647A1.647 1.647 0 0 1 5 15.353v-1.706A1.647 1.647 0 0 1 6.647 12h1.018M16 12l1.443 4.773L19 12m-6.057-.152-.943-.02a1.34 1.34 0 0 0-1.359 1.22 1.32 1.32 0 0 0 1.172 1.421l.536.059a1.273 1.273 0 0 1 1.226 1.718c-.2.571-.636.754-1.337.754h-1.13"></path></svg>`), FileCsvOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileCsvOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCsvOutline);
  validate_prop_bindings($$props, [], [], FileCsvOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file csv outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root244();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1244();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2244();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCsvOutline = hmr(FileCsvOutline, () => FileCsvOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCsvOutline[HMR].source;
    set(FileCsvOutline[HMR].source, module.default[HMR].original);
  });
}
var FileCsvOutline_default = FileCsvOutline;
mark_module_end(FileCsvOutline);

// node_modules/flowbite-svelte-icons/dist/FileCsvSolid.svelte
mark_module_start();
FileCsvSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileCsvSolid.svelte";
var root_1245 = add_locations(ns_template(`<title> </title>`), FileCsvSolid[FILENAME], [[39, 4]]);
var root_2245 = add_locations(ns_template(`<desc> </desc>`), FileCsvSolid[FILENAME], [[42, 4]]);
var root245 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2 2 2 0 0 0 2 2h12a2 2 0 0 0 2-2 2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2V4a2 2 0 0 0-2-2h-7Zm1.018 8.828a2.34 2.34 0 0 0-2.373 2.13v.008a2.32 2.32 0 0 0 2.06 2.497l.535.059a.993.993 0 0 0 .136.006.272.272 0 0 1 .263.367l-.008.02a.377.377 0 0 1-.018.044.49.49 0 0 1-.078.02 1.689 1.689 0 0 1-.297.021h-1.13a1 1 0 1 0 0 2h1.13c.417 0 .892-.05 1.324-.279.47-.248.78-.648.953-1.134a2.272 2.272 0 0 0-2.115-3.06l-.478-.052a.32.32 0 0 1-.285-.341.34.34 0 0 1 .344-.306l.94.02a1 1 0 1 0 .043-2l-.943-.02h-.003Zm7.933 1.482a1 1 0 1 0-1.902-.62l-.57 1.747-.522-1.726a1 1 0 0 0-1.914.578l1.443 4.773a1 1 0 0 0 1.908.021l1.557-4.773Zm-13.762.88a.647.647 0 0 1 .458-.19h1.018a1 1 0 1 0 0-2H6.647A2.647 2.647 0 0 0 4 13.647v1.706A2.647 2.647 0 0 0 6.647 18h1.018a1 1 0 1 0 0-2H6.647A.647.647 0 0 1 6 15.353v-1.706c0-.172.068-.336.19-.457Z" clip-rule="evenodd"></path></svg>`), FileCsvSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileCsvSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileCsvSolid);
  validate_prop_bindings($$props, [], [], FileCsvSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file csv solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root245();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1245();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2245();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileCsvSolid = hmr(FileCsvSolid, () => FileCsvSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileCsvSolid[HMR].source;
    set(FileCsvSolid[HMR].source, module.default[HMR].original);
  });
}
var FileCsvSolid_default = FileCsvSolid;
mark_module_end(FileCsvSolid);

// node_modules/flowbite-svelte-icons/dist/FileDocOutline.svelte
mark_module_start();
FileDocOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileDocOutline.svelte";
var root_1246 = add_locations(ns_template(`<title> </title>`), FileDocOutline[FILENAME], [[41, 4]]);
var root_2246 = add_locations(ns_template(`<desc> </desc>`), FileDocOutline[FILENAME], [[44, 4]]);
var root246 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 10V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v6M5 19v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1M10 3v4a1 1 0 0 1-1 1H5m14 9.006h-.335a1.647 1.647 0 0 1-1.647-1.647v-1.706a1.647 1.647 0 0 1 1.647-1.647L19 12M5 12v5h1.375A1.626 1.626 0 0 0 8 15.375v-1.75A1.626 1.626 0 0 0 6.375 12H5Zm9 1.5v2a1.5 1.5 0 0 1-1.5 1.5v0a1.5 1.5 0 0 1-1.5-1.5v-2a1.5 1.5 0 0 1 1.5-1.5v0a1.5 1.5 0 0 1 1.5 1.5Z"></path></svg>`), FileDocOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileDocOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileDocOutline);
  validate_prop_bindings($$props, [], [], FileDocOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file doc outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root246();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1246();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2246();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileDocOutline = hmr(FileDocOutline, () => FileDocOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileDocOutline[HMR].source;
    set(FileDocOutline[HMR].source, module.default[HMR].original);
  });
}
var FileDocOutline_default = FileDocOutline;
mark_module_end(FileDocOutline);

// node_modules/flowbite-svelte-icons/dist/FileDocSolid.svelte
mark_module_start();
FileDocSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileDocSolid.svelte";
var root_1247 = add_locations(ns_template(`<title> </title>`), FileDocSolid[FILENAME], [[39, 4]]);
var root_2247 = add_locations(ns_template(`<desc> </desc>`), FileDocSolid[FILENAME], [[42, 4]]);
var root247 = add_locations(ns_template(`<svg><!><!><path d="M6 16v-3h.375a.626.626 0 0 1 .625.626v1.749a.626.626 0 0 1-.626.625H6Zm6-2.5a.5.5 0 1 1 1 0v2a.5.5 0 0 1-1 0v-2Z"></path><path fill-rule="evenodd" d="M11 7V2h7a2 2 0 0 1 2 2v5h1a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-1a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2H3a1 1 0 0 1-1-1v-9a1 1 0 0 1 1-1h6a2 2 0 0 0 2-2Zm7.683 6.006 1.335-.024-.037-2-1.327.024a2.647 2.647 0 0 0-2.636 2.647v1.706a2.647 2.647 0 0 0 2.647 2.647H20v-2h-1.335a.647.647 0 0 1-.647-.647v-1.706a.647.647 0 0 1 .647-.647h.018ZM5 11a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h1.376A2.626 2.626 0 0 0 9 15.375v-1.75A2.626 2.626 0 0 0 6.375 11H5Zm7.5 0a2.5 2.5 0 0 0-2.5 2.5v2a2.5 2.5 0 0 0 5 0v-2a2.5 2.5 0 0 0-2.5-2.5Z" clip-rule="evenodd"></path><path d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Z"></path></svg>`), FileDocSolid[FILENAME], [
  [
    29,
    0,
    [[44, 2], [47, 2], [51, 5]]
  ]
]);
function FileDocSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileDocSolid);
  validate_prop_bindings($$props, [], [], FileDocSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file doc solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root247();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1247();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2247();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(3);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileDocSolid = hmr(FileDocSolid, () => FileDocSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileDocSolid[HMR].source;
    set(FileDocSolid[HMR].source, module.default[HMR].original);
  });
}
var FileDocSolid_default = FileDocSolid;
mark_module_end(FileDocSolid);

// node_modules/flowbite-svelte-icons/dist/FileExportOutline.svelte
mark_module_start();
FileExportOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileExportOutline.svelte";
var root_1248 = add_locations(ns_template(`<title> </title>`), FileExportOutline[FILENAME], [[41, 4]]);
var root_2248 = add_locations(ns_template(`<desc> </desc>`), FileExportOutline[FILENAME], [[44, 4]]);
var root248 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 10V4a1 1 0 0 0-1-1H9.914a1 1 0 0 0-.707.293L5.293 7.207A1 1 0 0 0 5 7.914V20a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2M10 3v4a1 1 0 0 1-1 1H5m5 6h9m0 0-2-2m2 2-2 2"></path></svg>`), FileExportOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileExportOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileExportOutline);
  validate_prop_bindings($$props, [], [], FileExportOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file export outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root248();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1248();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2248();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileExportOutline = hmr(FileExportOutline, () => FileExportOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileExportOutline[HMR].source;
    set(FileExportOutline[HMR].source, module.default[HMR].original);
  });
}
var FileExportOutline_default = FileExportOutline;
mark_module_end(FileExportOutline);

// node_modules/flowbite-svelte-icons/dist/FileExportSolid.svelte
mark_module_start();
FileExportSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileExportSolid.svelte";
var root_1249 = add_locations(ns_template(`<title> </title>`), FileExportSolid[FILENAME], [[39, 4]]);
var root_2249 = add_locations(ns_template(`<desc> </desc>`), FileExportSolid[FILENAME], [[42, 4]]);
var root249 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v9.293l-2-2a1 1 0 0 0-1.414 1.414l.293.293h-6.586a1 1 0 1 0 0 2h6.586l-.293.293A1 1 0 0 0 18 16.707l2-2V20a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path></svg>`), FileExportSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileExportSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileExportSolid);
  validate_prop_bindings($$props, [], [], FileExportSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file export solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root249();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1249();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2249();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileExportSolid = hmr(FileExportSolid, () => FileExportSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileExportSolid[HMR].source;
    set(FileExportSolid[HMR].source, module.default[HMR].original);
  });
}
var FileExportSolid_default = FileExportSolid;
mark_module_end(FileExportSolid);

// node_modules/flowbite-svelte-icons/dist/FileImageOutline.svelte
mark_module_start();
FileImageOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileImageOutline.svelte";
var root_1250 = add_locations(ns_template(`<title> </title>`), FileImageOutline[FILENAME], [[41, 4]]);
var root_2250 = add_locations(ns_template(`<desc> </desc>`), FileImageOutline[FILENAME], [[44, 4]]);
var root250 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M16 18H8l2.5-6 2 4 1.5-2 2 4Zm-1-8.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1ZM8 18h8l-2-4-1.5 2-2-4L8 18Zm7-8.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0Z"></path></svg>`), FileImageOutline[FILENAME], [
  [30, 0, [[46, 2], [50, 2]]]
]);
function FileImageOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileImageOutline);
  validate_prop_bindings($$props, [], [], FileImageOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file image outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root250();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1250();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2250();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1, 2);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileImageOutline = hmr(FileImageOutline, () => FileImageOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileImageOutline[HMR].source;
    set(FileImageOutline[HMR].source, module.default[HMR].original);
  });
}
var FileImageOutline_default = FileImageOutline;
mark_module_end(FileImageOutline);

// node_modules/flowbite-svelte-icons/dist/FileImageSolid.svelte
mark_module_start();
FileImageSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileImageSolid.svelte";
var root_1251 = add_locations(ns_template(`<title> </title>`), FileImageSolid[FILENAME], [[39, 4]]);
var root_2251 = add_locations(ns_template(`<desc> </desc>`), FileImageSolid[FILENAME], [[42, 4]]);
var root251 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7Zm.394 9.553a1 1 0 0 0-1.817.062l-2.5 6A1 1 0 0 0 8 19h8a1 1 0 0 0 .894-1.447l-2-4A1 1 0 0 0 13.2 13.4l-.53.706-1.276-2.553ZM13 9.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z" clip-rule="evenodd"></path></svg>`), FileImageSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileImageSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileImageSolid);
  validate_prop_bindings($$props, [], [], FileImageSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file image solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root251();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1251();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2251();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileImageSolid = hmr(FileImageSolid, () => FileImageSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileImageSolid[HMR].source;
    set(FileImageSolid[HMR].source, module.default[HMR].original);
  });
}
var FileImageSolid_default = FileImageSolid;
mark_module_end(FileImageSolid);

// node_modules/flowbite-svelte-icons/dist/FileImportOutline.svelte
mark_module_start();
FileImportOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileImportOutline.svelte";
var root_1252 = add_locations(ns_template(`<title> </title>`), FileImportOutline[FILENAME], [[41, 4]]);
var root_2252 = add_locations(ns_template(`<desc> </desc>`), FileImportOutline[FILENAME], [[44, 4]]);
var root252 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-4m5-13v4a1 1 0 0 1-1 1H5m0 6h9m0 0-2-2m2 2-2 2"></path></svg>`), FileImportOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileImportOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileImportOutline);
  validate_prop_bindings($$props, [], [], FileImportOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file import outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root252();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1252();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2252();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileImportOutline = hmr(FileImportOutline, () => FileImportOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileImportOutline[HMR].source;
    set(FileImportOutline[HMR].source, module.default[HMR].original);
  });
}
var FileImportOutline_default = FileImportOutline;
mark_module_end(FileImportOutline);

// node_modules/flowbite-svelte-icons/dist/FileImportSolid.svelte
mark_module_start();
FileImportSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileImportSolid.svelte";
var root_1253 = add_locations(ns_template(`<title> </title>`), FileImportSolid[FILENAME], [[39, 4]]);
var root_2253 = add_locations(ns_template(`<desc> </desc>`), FileImportSolid[FILENAME], [[42, 4]]);
var root253 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-5h7.586l-.293.293a1 1 0 0 0 1.414 1.414l2-2a1 1 0 0 0 0-1.414l-2-2a1 1 0 0 0-1.414 1.414l.293.293H4V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path></svg>`), FileImportSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileImportSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileImportSolid);
  validate_prop_bindings($$props, [], [], FileImportSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file import solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root253();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1253();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2253();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileImportSolid = hmr(FileImportSolid, () => FileImportSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileImportSolid[HMR].source;
    set(FileImportSolid[HMR].source, module.default[HMR].original);
  });
}
var FileImportSolid_default = FileImportSolid;
mark_module_end(FileImportSolid);

// node_modules/flowbite-svelte-icons/dist/FileInvoiceOutline.svelte
mark_module_start();
FileInvoiceOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileInvoiceOutline.svelte";
var root_1254 = add_locations(ns_template(`<title> </title>`), FileInvoiceOutline[FILENAME], [[41, 4]]);
var root_2254 = add_locations(ns_template(`<desc> </desc>`), FileInvoiceOutline[FILENAME], [[44, 4]]);
var root254 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m8-2h3m-3 3h3m-4 3v6m4-3H8M19 4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1ZM8 12v6h8v-6H8Z"></path></svg>`), FileInvoiceOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileInvoiceOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileInvoiceOutline);
  validate_prop_bindings($$props, [], [], FileInvoiceOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file invoice outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root254();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1254();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2254();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileInvoiceOutline = hmr(FileInvoiceOutline, () => FileInvoiceOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileInvoiceOutline[HMR].source;
    set(FileInvoiceOutline[HMR].source, module.default[HMR].original);
  });
}
var FileInvoiceOutline_default = FileInvoiceOutline;
mark_module_end(FileInvoiceOutline);

// node_modules/flowbite-svelte-icons/dist/FileInvoiceSolid.svelte
mark_module_start();
FileInvoiceSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileInvoiceSolid.svelte";
var root_1255 = add_locations(ns_template(`<title> </title>`), FileInvoiceSolid[FILENAME], [[39, 4]]);
var root_2255 = add_locations(ns_template(`<desc> </desc>`), FileInvoiceSolid[FILENAME], [[42, 4]]);
var root255 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm2-2a1 1 0 1 0 0 2h3a1 1 0 1 0 0-2h-3Zm0 3a1 1 0 1 0 0 2h3a1 1 0 1 0 0-2h-3Zm-6 4a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1v-6Zm8 1v1h-2v-1h2Zm0 3h-2v1h2v-1Zm-4-3v1H9v-1h2Zm0 3H9v1h2v-1Z" clip-rule="evenodd"></path></svg>`), FileInvoiceSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileInvoiceSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileInvoiceSolid);
  validate_prop_bindings($$props, [], [], FileInvoiceSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file invoice solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root255();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1255();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2255();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileInvoiceSolid = hmr(FileInvoiceSolid, () => FileInvoiceSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileInvoiceSolid[HMR].source;
    set(FileInvoiceSolid[HMR].source, module.default[HMR].original);
  });
}
var FileInvoiceSolid_default = FileInvoiceSolid;
mark_module_end(FileInvoiceSolid);

// node_modules/flowbite-svelte-icons/dist/FileLinesOutline.svelte
mark_module_start();
FileLinesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileLinesOutline.svelte";
var root_1256 = add_locations(ns_template(`<title> </title>`), FileLinesOutline[FILENAME], [[41, 4]]);
var root_2256 = add_locations(ns_template(`<desc> </desc>`), FileLinesOutline[FILENAME], [[44, 4]]);
var root256 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m4 8h6m-6-4h6m4-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileLinesOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileLinesOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileLinesOutline);
  validate_prop_bindings($$props, [], [], FileLinesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file lines outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root256();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1256();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2256();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileLinesOutline = hmr(FileLinesOutline, () => FileLinesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileLinesOutline[HMR].source;
    set(FileLinesOutline[HMR].source, module.default[HMR].original);
  });
}
var FileLinesOutline_default = FileLinesOutline;
mark_module_end(FileLinesOutline);

// node_modules/flowbite-svelte-icons/dist/FileLinesSolid.svelte
mark_module_start();
FileLinesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileLinesSolid.svelte";
var root_1257 = add_locations(ns_template(`<title> </title>`), FileLinesSolid[FILENAME], [[39, 4]]);
var root_2257 = add_locations(ns_template(`<desc> </desc>`), FileLinesSolid[FILENAME], [[42, 4]]);
var root257 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7ZM8 16a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm1-5a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Z" clip-rule="evenodd"></path></svg>`), FileLinesSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileLinesSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileLinesSolid);
  validate_prop_bindings($$props, [], [], FileLinesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file lines solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root257();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1257();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2257();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileLinesSolid = hmr(FileLinesSolid, () => FileLinesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileLinesSolid[HMR].source;
    set(FileLinesSolid[HMR].source, module.default[HMR].original);
  });
}
var FileLinesSolid_default = FileLinesSolid;
mark_module_end(FileLinesSolid);

// node_modules/flowbite-svelte-icons/dist/FileMusicOutline.svelte
mark_module_start();
FileMusicOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileMusicOutline.svelte";
var root_1258 = add_locations(ns_template(`<title> </title>`), FileMusicOutline[FILENAME], [[41, 4]]);
var root_2258 = add_locations(ns_template(`<desc> </desc>`), FileMusicOutline[FILENAME], [[44, 4]]);
var root258 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m8 7.5V8s3 1 3 4m3-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Zm-6 12c0 1.105-1.12 2-2.5 2S8 17.105 8 16s1.12-2 2.5-2 2.5.895 2.5 2Z"></path></svg>`), FileMusicOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileMusicOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileMusicOutline);
  validate_prop_bindings($$props, [], [], FileMusicOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file music outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root258();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1258();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2258();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileMusicOutline = hmr(FileMusicOutline, () => FileMusicOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileMusicOutline[HMR].source;
    set(FileMusicOutline[HMR].source, module.default[HMR].original);
  });
}
var FileMusicOutline_default = FileMusicOutline;
mark_module_end(FileMusicOutline);

// node_modules/flowbite-svelte-icons/dist/FileMusicSolid.svelte
mark_module_start();
FileMusicSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileMusicSolid.svelte";
var root_1259 = add_locations(ns_template(`<title> </title>`), FileMusicSolid[FILENAME], [[39, 4]]);
var root_2259 = add_locations(ns_template(`<desc> </desc>`), FileMusicSolid[FILENAME], [[42, 4]]);
var root259 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm2.318.052h-.002A1 1 0 0 0 12 8v5.293A4.033 4.033 0 0 0 10.5 13C8.787 13 7 14.146 7 16s1.787 3 3.5 3 3.5-1.146 3.5-3c0-.107-.006-.211-.017-.313A1.04 1.04 0 0 0 14 15.5V9.766c.538.493 1 1.204 1 2.234a1 1 0 1 0 2 0c0-1.881-.956-3.14-1.86-3.893a6.4 6.4 0 0 0-1.636-.985 4.009 4.009 0 0 0-.165-.063l-.014-.005-.005-.001-.002-.001ZM9 16c0-.356.452-1 1.5-1s1.5.644 1.5 1-.452 1-1.5 1S9 16.356 9 16Z" clip-rule="evenodd"></path></svg>`), FileMusicSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileMusicSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileMusicSolid);
  validate_prop_bindings($$props, [], [], FileMusicSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file music solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root259();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1259();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2259();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileMusicSolid = hmr(FileMusicSolid, () => FileMusicSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileMusicSolid[HMR].source;
    set(FileMusicSolid[HMR].source, module.default[HMR].original);
  });
}
var FileMusicSolid_default = FileMusicSolid;
mark_module_end(FileMusicSolid);

// node_modules/flowbite-svelte-icons/dist/FileOutline.svelte
mark_module_start();
FileOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileOutline.svelte";
var root_1260 = add_locations(ns_template(`<title> </title>`), FileOutline[FILENAME], [[41, 4]]);
var root_2260 = add_locations(ns_template(`<desc> </desc>`), FileOutline[FILENAME], [[44, 4]]);
var root260 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileOutline);
  validate_prop_bindings($$props, [], [], FileOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root260();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1260();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2260();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileOutline = hmr(FileOutline, () => FileOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileOutline[HMR].source;
    set(FileOutline[HMR].source, module.default[HMR].original);
  });
}
var FileOutline_default = FileOutline;
mark_module_end(FileOutline);

// node_modules/flowbite-svelte-icons/dist/FilePasteOutline.svelte
mark_module_start();
FilePasteOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePasteOutline.svelte";
var root_1261 = add_locations(ns_template(`<title> </title>`), FilePasteOutline[FILENAME], [[41, 4]]);
var root_2261 = add_locations(ns_template(`<desc> </desc>`), FilePasteOutline[FILENAME], [[44, 4]]);
var root261 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 20H5a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h2.429M7 8h3M8 8V4h4v2m4 0V5h-4m3 4v3a1 1 0 0 1-1 1h-3m9-3v9a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-6.397a1 1 0 0 1 .27-.683l2.434-2.603a1 1 0 0 1 .73-.317H19a1 1 0 0 1 1 1Z"></path></svg>`), FilePasteOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FilePasteOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilePasteOutline);
  validate_prop_bindings($$props, [], [], FilePasteOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file paste outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root261();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1261();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2261();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilePasteOutline = hmr(FilePasteOutline, () => FilePasteOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePasteOutline[HMR].source;
    set(FilePasteOutline[HMR].source, module.default[HMR].original);
  });
}
var FilePasteOutline_default = FilePasteOutline;
mark_module_end(FilePasteOutline);

// node_modules/flowbite-svelte-icons/dist/FilePasteSolid.svelte
mark_module_start();
FilePasteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePasteSolid.svelte";
var root_1262 = add_locations(ns_template(`<title> </title>`), FilePasteSolid[FILENAME], [[39, 4]]);
var root_2262 = add_locations(ns_template(`<desc> </desc>`), FilePasteSolid[FILENAME], [[42, 4]]);
var root262 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M6.5 3.85c0-.47.392-.85.875-.85h5.25c.483 0 .875.38.875.85h1.75c.966 0 1.75.761 1.75 1.7V6h-1c-.728 0-1.732-.06-2.434.095a4.01 4.01 0 0 0-.88.307.91.91 0 0 0-.061-.002h-.875V4.7h-3.5v1.7h-.875a.863.863 0 0 0-.875.85c0 .47.392.85.875.85h3.36L9.077 9.871a4 4 0 0 0-.892 1.526C7.97 12.083 8 13.268 8 14v5c0 .729.195 1.412.535 2H4.75C3.784 21 3 20.239 3 19.3V5.55c0-.939.784-1.7 1.75-1.7H6.5Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M14 8.048V12h-3.907a2 2 0 0 1 .446-.763l2.434-2.603A2 2 0 0 1 14 8.048ZM16 8v4a2 2 0 0 1-2 2h-4v5a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2v-9a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), FilePasteSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function FilePasteSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilePasteSolid);
  validate_prop_bindings($$props, [], [], FilePasteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file paste solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root262();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1262();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2262();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilePasteSolid = hmr(FilePasteSolid, () => FilePasteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePasteSolid[HMR].source;
    set(FilePasteSolid[HMR].source, module.default[HMR].original);
  });
}
var FilePasteSolid_default = FilePasteSolid;
mark_module_end(FilePasteSolid);

// node_modules/flowbite-svelte-icons/dist/FilePdfOutline.svelte
mark_module_start();
FilePdfOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePdfOutline.svelte";
var root_1263 = add_locations(ns_template(`<title> </title>`), FilePdfOutline[FILENAME], [[41, 4]]);
var root_2263 = add_locations(ns_template(`<desc> </desc>`), FilePdfOutline[FILENAME], [[44, 4]]);
var root263 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 17v-5h1.5a1.5 1.5 0 1 1 0 3H5m12 2v-5h2m-2 3h2M5 10V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v6M5 19v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1M10 3v4a1 1 0 0 1-1 1H5m6 4v5h1.375A1.627 1.627 0 0 0 14 15.375v-1.75A1.627 1.627 0 0 0 12.375 12H11Z"></path></svg>`), FilePdfOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FilePdfOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilePdfOutline);
  validate_prop_bindings($$props, [], [], FilePdfOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file pdf outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root263();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1263();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2263();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilePdfOutline = hmr(FilePdfOutline, () => FilePdfOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePdfOutline[HMR].source;
    set(FilePdfOutline[HMR].source, module.default[HMR].original);
  });
}
var FilePdfOutline_default = FilePdfOutline;
mark_module_end(FilePdfOutline);

// node_modules/flowbite-svelte-icons/dist/FilePdfSolid.svelte
mark_module_start();
FilePdfSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePdfSolid.svelte";
var root_1264 = add_locations(ns_template(`<title> </title>`), FilePdfSolid[FILENAME], [[39, 4]]);
var root_2264 = add_locations(ns_template(`<desc> </desc>`), FilePdfSolid[FILENAME], [[42, 4]]);
var root264 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2 2 2 0 0 0 2 2h12a2 2 0 0 0 2-2 2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2V4a2 2 0 0 0-2-2h-7Zm-6 9a1 1 0 0 0-1 1v5a1 1 0 1 0 2 0v-1h.5a2.5 2.5 0 0 0 0-5H5Zm1.5 3H6v-1h.5a.5.5 0 0 1 0 1Zm4.5-3a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h1.376A2.626 2.626 0 0 0 15 15.375v-1.75A2.626 2.626 0 0 0 12.375 11H11Zm1 5v-3h.375a.626.626 0 0 1 .625.626v1.748a.625.625 0 0 1-.626.626H12Zm5-5a1 1 0 0 0-1 1v5a1 1 0 1 0 2 0v-1h1a1 1 0 1 0 0-2h-1v-1h1a1 1 0 1 0 0-2h-2Z" clip-rule="evenodd"></path></svg>`), FilePdfSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FilePdfSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilePdfSolid);
  validate_prop_bindings($$props, [], [], FilePdfSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file pdf solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root264();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1264();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2264();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilePdfSolid = hmr(FilePdfSolid, () => FilePdfSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePdfSolid[HMR].source;
    set(FilePdfSolid[HMR].source, module.default[HMR].original);
  });
}
var FilePdfSolid_default = FilePdfSolid;
mark_module_end(FilePdfSolid);

// node_modules/flowbite-svelte-icons/dist/FilePenOutline.svelte
mark_module_start();
FilePenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePenOutline.svelte";
var root_1265 = add_locations(ns_template(`<title> </title>`), FilePenOutline[FILENAME], [[41, 4]]);
var root_2265 = add_locations(ns_template(`<desc> </desc>`), FilePenOutline[FILENAME], [[44, 4]]);
var root265 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 5V4a1 1 0 0 0-1-1H8.914a1 1 0 0 0-.707.293L4.293 7.207A1 1 0 0 0 4 7.914V20a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-5M9 3v4a1 1 0 0 1-1 1H4m11.383.772 2.745 2.746m1.215-3.906a2.089 2.089 0 0 1 0 2.953l-6.65 6.646L9 17.95l.739-3.692 6.646-6.646a2.087 2.087 0 0 1 2.958 0Z"></path></svg>`), FilePenOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FilePenOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilePenOutline);
  validate_prop_bindings($$props, [], [], FilePenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file pen outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root265();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1265();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2265();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilePenOutline = hmr(FilePenOutline, () => FilePenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePenOutline[HMR].source;
    set(FilePenOutline[HMR].source, module.default[HMR].original);
  });
}
var FilePenOutline_default = FilePenOutline;
mark_module_end(FilePenOutline);

// node_modules/flowbite-svelte-icons/dist/FilePenSolid.svelte
mark_module_start();
FilePenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePenSolid.svelte";
var root_1266 = add_locations(ns_template(`<title> </title>`), FilePenSolid[FILENAME], [[39, 4]]);
var root_2266 = add_locations(ns_template(`<desc> </desc>`), FilePenSolid[FILENAME], [[42, 4]]);
var root266 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 7V2.221a2 2 0 0 0-.5.365L3.586 6.5a2 2 0 0 0-.365.5H8Zm2 0V2h7a2 2 0 0 1 2 2v.126a5.087 5.087 0 0 0-4.74 1.368v.001l-6.642 6.642a3 3 0 0 0-.82 1.532l-.74 3.692a3 3 0 0 0 3.53 3.53l3.694-.738a3 3 0 0 0 1.532-.82L19 15.149V20a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M17.447 8.08a1.087 1.087 0 0 1 1.187.238l.002.001a1.088 1.088 0 0 1 0 1.539l-.377.377-1.54-1.542.373-.374.002-.001c.1-.102.22-.182.353-.237Zm-2.143 2.027-4.644 4.644-.385 1.924 1.925-.385 4.644-4.642-1.54-1.54Zm2.56-4.11a3.087 3.087 0 0 0-2.187.909l-6.645 6.645a1 1 0 0 0-.274.51l-.739 3.693a1 1 0 0 0 1.177 1.176l3.693-.738a1 1 0 0 0 .51-.274l6.65-6.646a3.088 3.088 0 0 0-2.185-5.275Z" clip-rule="evenodd"></path></svg>`), FilePenSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function FilePenSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilePenSolid);
  validate_prop_bindings($$props, [], [], FilePenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file pen solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root266();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1266();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2266();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilePenSolid = hmr(FilePenSolid, () => FilePenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePenSolid[HMR].source;
    set(FilePenSolid[HMR].source, module.default[HMR].original);
  });
}
var FilePenSolid_default = FilePenSolid;
mark_module_end(FilePenSolid);

// node_modules/flowbite-svelte-icons/dist/FilePptOutline.svelte
mark_module_start();
FilePptOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePptOutline.svelte";
var root_1267 = add_locations(ns_template(`<title> </title>`), FilePptOutline[FILENAME], [[41, 4]]);
var root_2267 = add_locations(ns_template(`<desc> </desc>`), FilePptOutline[FILENAME], [[44, 4]]);
var root267 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 17v-5h1.5a1.5 1.5 0 1 1 0 3H5m6 2v-5h1.5a1.5 1.5 0 1 1 0 3H11m7-3v5m-1-5h2M5 10V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1v6M5 19v1a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1M10 3v4a1 1 0 0 1-1 1H5"></path></svg>`), FilePptOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FilePptOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilePptOutline);
  validate_prop_bindings($$props, [], [], FilePptOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file ppt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root267();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1267();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2267();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilePptOutline = hmr(FilePptOutline, () => FilePptOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePptOutline[HMR].source;
    set(FilePptOutline[HMR].source, module.default[HMR].original);
  });
}
var FilePptOutline_default = FilePptOutline;
mark_module_end(FilePptOutline);

// node_modules/flowbite-svelte-icons/dist/FilePptSolid.svelte
mark_module_start();
FilePptSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilePptSolid.svelte";
var root_1268 = add_locations(ns_template(`<title> </title>`), FilePptSolid[FILENAME], [[39, 4]]);
var root_2268 = add_locations(ns_template(`<desc> </desc>`), FilePptSolid[FILENAME], [[42, 4]]);
var root268 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2 2 2 0 0 0 2 2h12a2 2 0 0 0 2-2 2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2V4a2 2 0 0 0-2-2h-7Zm-6 9a1 1 0 0 0-1 1v5a1 1 0 1 0 2 0v-1h.5a2.5 2.5 0 0 0 0-5H5Zm1.5 3H6v-1h.5a.5.5 0 0 1 0 1Zm4.5-3a1 1 0 0 0-1 1v5a1 1 0 1 0 2 0v-1h.5a2.5 2.5 0 0 0 0-5H11Zm1.5 3H12v-1h.5a.5.5 0 0 1 0 1Zm4.5-3a1 1 0 1 0 0 2v4a1 1 0 1 0 2 0v-4a1 1 0 1 0 0-2h-2Z" clip-rule="evenodd"></path></svg>`), FilePptSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FilePptSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilePptSolid);
  validate_prop_bindings($$props, [], [], FilePptSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file ppt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root268();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1268();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2268();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilePptSolid = hmr(FilePptSolid, () => FilePptSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilePptSolid[HMR].source;
    set(FilePptSolid[HMR].source, module.default[HMR].original);
  });
}
var FilePptSolid_default = FilePptSolid;
mark_module_end(FilePptSolid);

// node_modules/flowbite-svelte-icons/dist/FileSearchOutline.svelte
mark_module_start();
FileSearchOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileSearchOutline.svelte";
var root_1269 = add_locations(ns_template(`<title> </title>`), FileSearchOutline[FILENAME], [[41, 4]]);
var root_2269 = add_locations(ns_template(`<desc> </desc>`), FileSearchOutline[FILENAME], [[44, 4]]);
var root269 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m8 7.5 2.5 2.5M19 4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Zm-5 9.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Z"></path></svg>`), FileSearchOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileSearchOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileSearchOutline);
  validate_prop_bindings($$props, [], [], FileSearchOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file search outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root269();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1269();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2269();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileSearchOutline = hmr(FileSearchOutline, () => FileSearchOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileSearchOutline[HMR].source;
    set(FileSearchOutline[HMR].source, module.default[HMR].original);
  });
}
var FileSearchOutline_default = FileSearchOutline;
mark_module_end(FileSearchOutline);

// node_modules/flowbite-svelte-icons/dist/FileSearchSolid.svelte
mark_module_start();
FileSearchSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileSearchSolid.svelte";
var root_1270 = add_locations(ns_template(`<title> </title>`), FileSearchSolid[FILENAME], [[39, 4]]);
var root_2270 = add_locations(ns_template(`<desc> </desc>`), FileSearchSolid[FILENAME], [[42, 4]]);
var root270 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm.5 5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm0 5c.47 0 .917-.092 1.326-.26l1.967 1.967a1 1 0 0 0 1.414-1.414l-1.817-1.818A3.5 3.5 0 1 0 11.5 17Z" clip-rule="evenodd"></path></svg>`), FileSearchSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileSearchSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileSearchSolid);
  validate_prop_bindings($$props, [], [], FileSearchSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file search solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root270();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1270();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2270();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileSearchSolid = hmr(FileSearchSolid, () => FileSearchSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileSearchSolid[HMR].source;
    set(FileSearchSolid[HMR].source, module.default[HMR].original);
  });
}
var FileSearchSolid_default = FileSearchSolid;
mark_module_end(FileSearchSolid);

// node_modules/flowbite-svelte-icons/dist/FileShieldOutline.svelte
mark_module_start();
FileShieldOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileShieldOutline.svelte";
var root_1271 = add_locations(ns_template(`<title> </title>`), FileShieldOutline[FILENAME], [[41, 4]]);
var root_2271 = add_locations(ns_template(`<desc> </desc>`), FileShieldOutline[FILENAME], [[44, 4]]);
var root271 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 9V4a1 1 0 0 0-1-1H8.914a1 1 0 0 0-.707.293L4.293 7.207A1 1 0 0 0 4 7.914V20a1 1 0 0 0 1 1h6M9 3v4a1 1 0 0 1-1 1H4m11 13a11.426 11.426 0 0 1-3.637-3.99A11.139 11.139 0 0 1 10 11.833L15 10l5 1.833a11.137 11.137 0 0 1-1.363 5.176A11.425 11.425 0 0 1 15.001 21Z"></path></svg>`), FileShieldOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileShieldOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileShieldOutline);
  validate_prop_bindings($$props, [], [], FileShieldOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file shield outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root271();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1271();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2271();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileShieldOutline = hmr(FileShieldOutline, () => FileShieldOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileShieldOutline[HMR].source;
    set(FileShieldOutline[HMR].source, module.default[HMR].original);
  });
}
var FileShieldOutline_default = FileShieldOutline;
mark_module_end(FileShieldOutline);

// node_modules/flowbite-svelte-icons/dist/FileShieldSolid.svelte
mark_module_start();
FileShieldSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileShieldSolid.svelte";
var root_1272 = add_locations(ns_template(`<title> </title>`), FileShieldSolid[FILENAME], [[39, 4]]);
var root_2272 = add_locations(ns_template(`<desc> </desc>`), FileShieldSolid[FILENAME], [[42, 4]]);
var root272 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v5.703l-4.311-1.58a2 2 0 0 0-1.377 0l-5 1.832A2 2 0 0 0 8 11.861c.03 2.134.582 4.228 1.607 6.106.848 1.555 2 2.924 3.382 4.033H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M15.345 9.061a1 1 0 0 0-.689 0l-5 1.833a1 1 0 0 0-.656.953c.028 1.97.538 3.905 1.485 5.641a12.425 12.425 0 0 0 3.956 4.34 1 1 0 0 0 1.12 0 12.426 12.426 0 0 0 3.954-4.34A12.14 12.14 0 0 0 21 11.848a1 1 0 0 0-.656-.954l-5-1.833ZM15 19.765a10.401 10.401 0 0 0 2.76-3.235 10.15 10.15 0 0 0 1.206-4.011L15 11.065v8.7Z" clip-rule="evenodd"></path></svg>`), FileShieldSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function FileShieldSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileShieldSolid);
  validate_prop_bindings($$props, [], [], FileShieldSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file shield solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root272();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1272();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2272();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileShieldSolid = hmr(FileShieldSolid, () => FileShieldSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileShieldSolid[HMR].source;
    set(FileShieldSolid[HMR].source, module.default[HMR].original);
  });
}
var FileShieldSolid_default = FileShieldSolid;
mark_module_end(FileShieldSolid);

// node_modules/flowbite-svelte-icons/dist/FileSolid.svelte
mark_module_start();
FileSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileSolid.svelte";
var root_1273 = add_locations(ns_template(`<title> </title>`), FileSolid[FILENAME], [[39, 4]]);
var root_2273 = add_locations(ns_template(`<desc> </desc>`), FileSolid[FILENAME], [[42, 4]]);
var root273 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7Z" clip-rule="evenodd"></path></svg>`), FileSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileSolid);
  validate_prop_bindings($$props, [], [], FileSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root273();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1273();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2273();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileSolid = hmr(FileSolid, () => FileSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileSolid[HMR].source;
    set(FileSolid[HMR].source, module.default[HMR].original);
  });
}
var FileSolid_default = FileSolid;
mark_module_end(FileSolid);

// node_modules/flowbite-svelte-icons/dist/FileVideoOutline.svelte
mark_module_start();
FileVideoOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileVideoOutline.svelte";
var root_1274 = add_locations(ns_template(`<title> </title>`), FileVideoOutline[FILENAME], [[41, 4]]);
var root_2274 = add_locations(ns_template(`<desc> </desc>`), FileVideoOutline[FILENAME], [[44, 4]]);
var root274 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1ZM9 12h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1Zm5.697 2.395v-.733l1.269-1.219v2.984l-1.268-1.032Z"></path></svg>`), FileVideoOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileVideoOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileVideoOutline);
  validate_prop_bindings($$props, [], [], FileVideoOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file video outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root274();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1274();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2274();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileVideoOutline = hmr(FileVideoOutline, () => FileVideoOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileVideoOutline[HMR].source;
    set(FileVideoOutline[HMR].source, module.default[HMR].original);
  });
}
var FileVideoOutline_default = FileVideoOutline;
mark_module_end(FileVideoOutline);

// node_modules/flowbite-svelte-icons/dist/FileVideoSolid.svelte
mark_module_start();
FileVideoSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileVideoSolid.svelte";
var root_1275 = add_locations(ns_template(`<title> </title>`), FileVideoSolid[FILENAME], [[39, 4]]);
var root_2275 = add_locations(ns_template(`<desc> </desc>`), FileVideoSolid[FILENAME], [[42, 4]]);
var root275 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm-2 4a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2H9Zm0 2h2v2H9v-2Zm7.965-.557a1 1 0 0 0-1.692-.72l-1.268 1.218a1 1 0 0 0-.308.721v.733a1 1 0 0 0 .37.776l1.267 1.032a1 1 0 0 0 1.631-.776v-2.984Z" clip-rule="evenodd"></path></svg>`), FileVideoSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileVideoSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileVideoSolid);
  validate_prop_bindings($$props, [], [], FileVideoSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file video solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root275();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1275();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2275();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileVideoSolid = hmr(FileVideoSolid, () => FileVideoSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileVideoSolid[HMR].source;
    set(FileVideoSolid[HMR].source, module.default[HMR].original);
  });
}
var FileVideoSolid_default = FileVideoSolid;
mark_module_end(FileVideoSolid);

// node_modules/flowbite-svelte-icons/dist/FileWordOutline.svelte
mark_module_start();
FileWordOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileWordOutline.svelte";
var root_1276 = add_locations(ns_template(`<title> </title>`), FileWordOutline[FILENAME], [[41, 4]]);
var root_2276 = add_locations(ns_template(`<desc> </desc>`), FileWordOutline[FILENAME], [[44, 4]]);
var root276 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 3v4a1 1 0 0 1-1 1H5m4 4 1 5 2-3.333L14 17l1-5m4-8v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Z"></path></svg>`), FileWordOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileWordOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileWordOutline);
  validate_prop_bindings($$props, [], [], FileWordOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file word outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root276();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1276();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2276();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileWordOutline = hmr(FileWordOutline, () => FileWordOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileWordOutline[HMR].source;
    set(FileWordOutline[HMR].source, module.default[HMR].original);
  });
}
var FileWordOutline_default = FileWordOutline;
mark_module_end(FileWordOutline);

// node_modules/flowbite-svelte-icons/dist/FileWordSolid.svelte
mark_module_start();
FileWordSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileWordSolid.svelte";
var root_1277 = add_locations(ns_template(`<title> </title>`), FileWordSolid[FILENAME], [[39, 4]]);
var root_2277 = add_locations(ns_template(`<desc> </desc>`), FileWordSolid[FILENAME], [[42, 4]]);
var root277 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 7V2.221a2 2 0 0 0-.5.365L4.586 6.5a2 2 0 0 0-.365.5H9Zm2 0V2h7a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9h5a2 2 0 0 0 2-2Zm-1.02 4.804a1 1 0 1 0-1.96.392l1 5a1 1 0 0 0 1.838.319L12 15.61l1.143 1.905a1 1 0 0 0 1.838-.319l1-5a1 1 0 0 0-1.962-.392l-.492 2.463-.67-1.115a1 1 0 0 0-1.714 0l-.67 1.116-.492-2.464Z" clip-rule="evenodd"></path></svg>`), FileWordSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileWordSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileWordSolid);
  validate_prop_bindings($$props, [], [], FileWordSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file word solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root277();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1277();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2277();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileWordSolid = hmr(FileWordSolid, () => FileWordSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileWordSolid[HMR].source;
    set(FileWordSolid[HMR].source, module.default[HMR].original);
  });
}
var FileWordSolid_default = FileWordSolid;
mark_module_end(FileWordSolid);

// node_modules/flowbite-svelte-icons/dist/FileZipOutline.svelte
mark_module_start();
FileZipOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileZipOutline.svelte";
var root_1278 = add_locations(ns_template(`<title> </title>`), FileZipOutline[FILENAME], [[41, 4]]);
var root_2278 = add_locations(ns_template(`<desc> </desc>`), FileZipOutline[FILENAME], [[44, 4]]);
var root278 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M10 3v4a1 1 0 0 1-1 1H5m14-4v16a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V7.914a1 1 0 0 1 .293-.707l3.914-3.914A1 1 0 0 1 9.914 3H18a1 1 0 0 1 1 1Zm-4 1h.01v.01H15V5Zm-2 2h.01v.01H13V7Zm2 2h.01v.01H15V9Zm-2 2h.01v.01H13V11Zm2 2h.01v.01H15V13Zm-2 2h.01v.01H13V15Zm2 2h.01v.01H15V17Zm-2 2h.01v.01H13V19Z"></path></svg>`), FileZipOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FileZipOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileZipOutline);
  validate_prop_bindings($$props, [], [], FileZipOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "file zip outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root278();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1278();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2278();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileZipOutline = hmr(FileZipOutline, () => FileZipOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileZipOutline[HMR].source;
    set(FileZipOutline[HMR].source, module.default[HMR].original);
  });
}
var FileZipOutline_default = FileZipOutline;
mark_module_end(FileZipOutline);

// node_modules/flowbite-svelte-icons/dist/FileZipSolid.svelte
mark_module_start();
FileZipSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FileZipSolid.svelte";
var root_1279 = add_locations(ns_template(`<title> </title>`), FileZipSolid[FILENAME], [[39, 4]]);
var root_2279 = add_locations(ns_template(`<desc> </desc>`), FileZipSolid[FILENAME], [[42, 4]]);
var root279 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 2.221V7H4.221a2 2 0 0 1 .365-.5L8.5 2.586A2 2 0 0 1 9 2.22ZM11 2v5a2 2 0 0 1-2 2H4v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2h-7Zm3 2h2.01v2.01h-2V8h2v2.01h-2V12h2v2.01h-2V16h2v2.01h-2v2H12V18h2v-1.99h-2V14h2v-1.99h-2V10h2V8.01h-2V6h2V4Z" clip-rule="evenodd"></path></svg>`), FileZipSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FileZipSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FileZipSolid);
  validate_prop_bindings($$props, [], [], FileZipSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "file zip solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root279();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1279();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2279();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FileZipSolid = hmr(FileZipSolid, () => FileZipSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FileZipSolid[HMR].source;
    set(FileZipSolid[HMR].source, module.default[HMR].original);
  });
}
var FileZipSolid_default = FileZipSolid;
mark_module_end(FileZipSolid);

// node_modules/flowbite-svelte-icons/dist/FilterDollarOutline.svelte
mark_module_start();
FilterDollarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilterDollarOutline.svelte";
var root_1280 = add_locations(ns_template(`<title> </title>`), FilterDollarOutline[FILENAME], [[41, 4]]);
var root_2280 = add_locations(ns_template(`<desc> </desc>`), FilterDollarOutline[FILENAME], [[44, 4]]);
var root280 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m11.0001 18-.8536-.8536c-.0937-.0937-.1464-.2209-.1464-.3535v-4.4172c0-.2422-.08794-.4762-.24744-.6585L4.45127 5.6585C3.88551 5.01192 4.34469 4 5.20385 4H18.7547c.8658 0 1.3225 1.02544.7433 1.66896L16.5001 9m-2.5 9.3754c.3347.3615.7824.6134 1.2788.7195.4771.1584 1.0002.1405 1.464-.05.4638-.1906.8338-.5396 1.0356-.977.2462-.8286-.6363-1.7337-1.7735-1.9948-1.1372-.2611-2.016-1.1604-1.7735-1.9948.2016-.4375.5716-.7868 1.0354-.9774.4639-.1905.9871-.2082 1.4643-.0496.491.1045.9348.3517 1.2689.7067m-1.9397 5.41V20m0-8v.9771"></path></svg>`), FilterDollarOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FilterDollarOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilterDollarOutline);
  validate_prop_bindings($$props, [], [], FilterDollarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "filter dollar outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root280();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1280();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2280();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilterDollarOutline = hmr(FilterDollarOutline, () => FilterDollarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilterDollarOutline[HMR].source;
    set(FilterDollarOutline[HMR].source, module.default[HMR].original);
  });
}
var FilterDollarOutline_default = FilterDollarOutline;
mark_module_end(FilterDollarOutline);

// node_modules/flowbite-svelte-icons/dist/FilterDollarSolid.svelte
mark_module_start();
FilterDollarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilterDollarSolid.svelte";
var root_1281 = add_locations(ns_template(`<title> </title>`), FilterDollarSolid[FILENAME], [[39, 4]]);
var root_2281 = add_locations(ns_template(`<desc> </desc>`), FilterDollarSolid[FILENAME], [[42, 4]]);
var root281 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M3.69869 6.31701C2.56717 5.02384 3.48553 3 5.20384 3H18.7547c1.7316 0 2.6449 2.05088 1.4866 3.33793L17.47 9.34198s-.4632-.20588-.6184-.24042c-.1551-.03453-.488-.10604-.9206-.10604-.9034 0-2.138.66073-2.5716 1.73108-1.3256.8485-1.6921 1.8133-1.7929 2.0078-.1009.1944-.2618.5312-.3399 1.2148-.0781.6836 0 1.6055.5235 2.4688-.0721.0626-.2383.289-.3321.4375-.0937.1484-.5898.875-.3515 2.1445-.1993 0-.6387-.158-.92-.4393l-.70708-.7071c-.28131-.2814-.43934-.6629-.43934-1.0607v-4.4172L3.69869 6.31701Z"></path><path fill="currentColor" fill-rule="evenodd" d="M16.0604 11c.5523 0 1 .4477 1 1v.1013c.6366.1591 1.2184.4937 1.668.9715.3784.4022.3592 1.0351-.0431 1.4135-.4022.3785-1.0351.3592-1.4135-.043-.1902-.2021-.4506-.3504-.7488-.4139-.0363-.0077-.0722-.0174-.1074-.0292-.0543-.018-.1098-.0317-.1658-.041-.0614.0117-.1247.0179-.1894.0179-.063 0-.1245-.0058-.1843-.017-.0784.0136-.1554.0355-.2292.0658-.1976.0812-.3513.2132-.4504.3673.0006.002.0013.0042.002.0064.0138.0431.0516.1195.1396.2154.1806.1971.4983.3934.8907.4835.746.1712 1.4369.5572 1.9192 1.0838.476.5197.8461 1.3054.5891 2.1704-.0136.0459-.0305.0907-.0506.1342-.3123.6768-.8768 1.2008-1.5636 1.483-.0208.0085-.0416.0168-.0625.0248V20c0 .5523-.4477 1-1 1-.5271 0-.9589-.4077-.9973-.9249-.0154-.0046-.0308-.0093-.0462-.0141-.6707-.1541-1.2837-.502-1.7506-1.0062-.3752-.4053-.3509-1.038.0544-1.4132.4052-.3752 1.0379-.3508 1.4131.0544.1903.2055.4527.3566.754.4209.0359.0077.0713.0173.1061.0289.0754.025.1531.0416.2315.0499.0753-.0181.154-.0277.235-.0277.0421 0 .0836.0026.1244.0076.0608-.0134.1204-.032.1781-.0557.1979-.0813.3518-.2135.451-.368l-.001-.0032c-.0136-.0424-.0513-.1189-.1398-.2156-.1817-.1984-.5007-.3955-.8919-.4854-.7448-.171-1.4351-.5549-1.9176-1.0814-.4776-.5211-.8432-1.304-.5924-2.167.0138-.0477.0312-.0943.052-.1394.312-.6773.8766-1.2017 1.5637-1.4839.0573-.0236.1151-.0453.1735-.0653V12c0-.5523.4477-1 1-1Z" clip-rule="evenodd"></path></svg>`), FilterDollarSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 2]]]
]);
function FilterDollarSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilterDollarSolid);
  validate_prop_bindings($$props, [], [], FilterDollarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "filter dollar solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root281();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1281();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2281();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilterDollarSolid = hmr(FilterDollarSolid, () => FilterDollarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilterDollarSolid[HMR].source;
    set(FilterDollarSolid[HMR].source, module.default[HMR].original);
  });
}
var FilterDollarSolid_default = FilterDollarSolid;
mark_module_end(FilterDollarSolid);

// node_modules/flowbite-svelte-icons/dist/FilterOutline.svelte
mark_module_start();
FilterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilterOutline.svelte";
var root_1282 = add_locations(ns_template(`<title> </title>`), FilterOutline[FILENAME], [[41, 4]]);
var root_2282 = add_locations(ns_template(`<desc> </desc>`), FilterOutline[FILENAME], [[44, 4]]);
var root282 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M18.796 4H5.204a1 1 0 0 0-.753 1.659l5.302 6.058a1 1 0 0 1 .247.659v4.874a.5.5 0 0 0 .2.4l3 2.25a.5.5 0 0 0 .8-.4v-7.124a1 1 0 0 1 .247-.659l5.302-6.059c.566-.646.106-1.658-.753-1.658Z"></path></svg>`), FilterOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FilterOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilterOutline);
  validate_prop_bindings($$props, [], [], FilterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "filter outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root282();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1282();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2282();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilterOutline = hmr(FilterOutline, () => FilterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilterOutline[HMR].source;
    set(FilterOutline[HMR].source, module.default[HMR].original);
  });
}
var FilterOutline_default = FilterOutline;
mark_module_end(FilterOutline);

// node_modules/flowbite-svelte-icons/dist/FilterSolid.svelte
mark_module_start();
FilterSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FilterSolid.svelte";
var root_1283 = add_locations(ns_template(`<title> </title>`), FilterSolid[FILENAME], [[39, 4]]);
var root_2283 = add_locations(ns_template(`<desc> </desc>`), FilterSolid[FILENAME], [[42, 4]]);
var root283 = add_locations(ns_template(`<svg><!><!><path d="M5.05 3C3.291 3 2.352 5.024 3.51 6.317l5.422 6.059v4.874c0 .472.227.917.613 1.2l3.069 2.25c1.01.742 2.454.036 2.454-1.2v-7.124l5.422-6.059C21.647 5.024 20.708 3 18.95 3H5.05Z"></path></svg>`), FilterSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FilterSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FilterSolid);
  validate_prop_bindings($$props, [], [], FilterSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "filter solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root283();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1283();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2283();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FilterSolid = hmr(FilterSolid, () => FilterSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FilterSolid[HMR].source;
    set(FilterSolid[HMR].source, module.default[HMR].original);
  });
}
var FilterSolid_default = FilterSolid;
mark_module_end(FilterSolid);

// node_modules/flowbite-svelte-icons/dist/FingerprintOutline.svelte
mark_module_start();
FingerprintOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FingerprintOutline.svelte";
var root_1284 = add_locations(ns_template(`<title> </title>`), FingerprintOutline[FILENAME], [[41, 4]]);
var root_2284 = add_locations(ns_template(`<desc> </desc>`), FingerprintOutline[FILENAME], [[44, 4]]);
var root284 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M21 12a28.076 28.076 0 0 1-1.091 9M7.231 4.37a8.994 8.994 0 0 1 12.88 3.73M2.958 15S3 14.577 3 12a8.949 8.949 0 0 1 1.735-5.307m12.84 3.088A5.98 5.98 0 0 1 18 12a30 30 0 0 1-.464 6.232M6 12a6 6 0 0 1 9.352-4.974M4 21a5.964 5.964 0 0 1 1.01-3.328 5.15 5.15 0 0 0 .786-1.926m8.66 2.486a13.96 13.96 0 0 1-.962 2.683M7.5 19.336C9 17.092 9 14.845 9 12a3 3 0 1 1 6 0c0 .749 0 1.521-.031 2.311M12 12c0 3 0 6-2 9"></path></svg>`), FingerprintOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FingerprintOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FingerprintOutline);
  validate_prop_bindings($$props, [], [], FingerprintOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "fingerprint outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root284();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1284();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2284();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FingerprintOutline = hmr(FingerprintOutline, () => FingerprintOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FingerprintOutline[HMR].source;
    set(FingerprintOutline[HMR].source, module.default[HMR].original);
  });
}
var FingerprintOutline_default = FingerprintOutline;
mark_module_end(FingerprintOutline);

// node_modules/flowbite-svelte-icons/dist/FireOutline.svelte
mark_module_start();
FireOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FireOutline.svelte";
var root_1285 = add_locations(ns_template(`<title> </title>`), FireOutline[FILENAME], [[41, 4]]);
var root_2285 = add_locations(ns_template(`<desc> </desc>`), FireOutline[FILENAME], [[44, 4]]);
var root285 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.122 17.645a7.185 7.185 0 0 1-2.656 2.495 7.06 7.06 0 0 1-3.52.853 6.617 6.617 0 0 1-3.306-.718 6.73 6.73 0 0 1-2.54-2.266c-2.672-4.57.287-8.846.887-9.668A4.448 4.448 0 0 0 8.07 6.31 4.49 4.49 0 0 0 7.997 4c1.284.965 6.43 3.258 5.525 10.631 1.496-1.136 2.7-3.046 2.846-6.216 1.43 1.061 3.985 5.462 1.754 9.23Z"></path></svg>`), FireOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FireOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FireOutline);
  validate_prop_bindings($$props, [], [], FireOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "fire outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root285();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1285();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2285();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FireOutline = hmr(FireOutline, () => FireOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FireOutline[HMR].source;
    set(FireOutline[HMR].source, module.default[HMR].original);
  });
}
var FireOutline_default = FireOutline;
mark_module_end(FireOutline);

// node_modules/flowbite-svelte-icons/dist/FireSolid.svelte
mark_module_start();
FireSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FireSolid.svelte";
var root_1286 = add_locations(ns_template(`<title> </title>`), FireSolid[FILENAME], [[39, 4]]);
var root_2286 = add_locations(ns_template(`<desc> </desc>`), FireSolid[FILENAME], [[42, 4]]);
var root286 = add_locations(ns_template(`<svg><!><!><path d="M8.597 3.2A1 1 0 0 0 7.04 4.289a3.49 3.49 0 0 1 .057 1.795 3.448 3.448 0 0 1-.84 1.575.999.999 0 0 0-.077.094c-.596.817-3.96 5.6-.941 10.762l.03.049a7.73 7.73 0 0 0 2.917 2.602 7.617 7.617 0 0 0 3.772.829 8.06 8.06 0 0 0 3.986-.975 8.185 8.185 0 0 0 3.04-2.864c1.301-2.2 1.184-4.556.588-6.441-.583-1.848-1.68-3.414-2.607-4.102a1 1 0 0 0-1.594.757c-.067 1.431-.363 2.551-.794 3.431-.222-2.407-1.127-4.196-2.224-5.524-1.147-1.39-2.564-2.3-3.323-2.788a8.487 8.487 0 0 1-.432-.287Z"></path></svg>`), FireSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FireSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FireSolid);
  validate_prop_bindings($$props, [], [], FireSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "fire solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root286();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1286();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2286();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FireSolid = hmr(FireSolid, () => FireSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FireSolid[HMR].source;
    set(FireSolid[HMR].source, module.default[HMR].original);
  });
}
var FireSolid_default = FireSolid;
mark_module_end(FireSolid);

// node_modules/flowbite-svelte-icons/dist/FixTablesOutline.svelte
mark_module_start();
FixTablesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FixTablesOutline.svelte";
var root_1287 = add_locations(ns_template(`<title> </title>`), FixTablesOutline[FILENAME], [[41, 4]]);
var root_2287 = add_locations(ns_template(`<desc> </desc>`), FixTablesOutline[FILENAME], [[44, 4]]);
var root287 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h4v-4m-5 0v-4m0 4h5m-5-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v1.98935M3 11h5v4m9.4708 4.1718-.8696-1.4388-2.8164-.235-2.573-4.2573 1.4873-2.8362 1.4441 2.3893c.3865.6396 1.2183.8447 1.8579.4582.6396-.3866.8447-1.2184.4582-1.858l-1.444-2.38925h3.1353l2.6101 4.27715-1.0713 2.5847.8695 1.4388"></path></svg>`), FixTablesOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FixTablesOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FixTablesOutline);
  validate_prop_bindings($$props, [], [], FixTablesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "fix tables outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root287();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1287();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2287();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FixTablesOutline = hmr(FixTablesOutline, () => FixTablesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FixTablesOutline[HMR].source;
    set(FixTablesOutline[HMR].source, module.default[HMR].original);
  });
}
var FixTablesOutline_default = FixTablesOutline;
mark_module_end(FixTablesOutline);

// node_modules/flowbite-svelte-icons/dist/FlagOutline.svelte
mark_module_start();
FlagOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FlagOutline.svelte";
var root_1288 = add_locations(ns_template(`<title> </title>`), FlagOutline[FILENAME], [[41, 4]]);
var root_2288 = add_locations(ns_template(`<desc> </desc>`), FlagOutline[FILENAME], [[44, 4]]);
var root288 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 14v7M5 4.971v9.541c5.6-5.538 8.4 2.64 14-.086v-9.54C13.4 7.61 10.6-.568 5 4.97Z"></path></svg>`), FlagOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FlagOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FlagOutline);
  validate_prop_bindings($$props, [], [], FlagOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "flag outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root288();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1288();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2288();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FlagOutline = hmr(FlagOutline, () => FlagOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FlagOutline[HMR].source;
    set(FlagOutline[HMR].source, module.default[HMR].original);
  });
}
var FlagOutline_default = FlagOutline;
mark_module_end(FlagOutline);

// node_modules/flowbite-svelte-icons/dist/FlagSolid.svelte
mark_module_start();
FlagSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FlagSolid.svelte";
var root_1289 = add_locations(ns_template(`<title> </title>`), FlagSolid[FILENAME], [[39, 4]]);
var root_2289 = add_locations(ns_template(`<desc> </desc>`), FlagSolid[FILENAME], [[42, 4]]);
var root289 = add_locations(ns_template(`<svg><!><!><path d="M13.09 3.294c1.924.95 3.422 1.69 5.472.692a1 1 0 0 1 1.438.9v9.54a1 1 0 0 1-.562.9c-2.981 1.45-5.382.24-7.25-.701a38.739 38.739 0 0 0-.622-.31c-1.033-.497-1.887-.812-2.756-.77-.76.036-1.672.357-2.81 1.396V21a1 1 0 1 1-2 0V4.971a1 1 0 0 1 .297-.71c1.522-1.506 2.967-2.185 4.417-2.255 1.407-.068 2.653.453 3.72.967.225.108.443.216.655.32Z"></path></svg>`), FlagSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FlagSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FlagSolid);
  validate_prop_bindings($$props, [], [], FlagSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "flag solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root289();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1289();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2289();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FlagSolid = hmr(FlagSolid, () => FlagSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FlagSolid[HMR].source;
    set(FlagSolid[HMR].source, module.default[HMR].original);
  });
}
var FlagSolid_default = FlagSolid;
mark_module_end(FlagSolid);

// node_modules/flowbite-svelte-icons/dist/FloppyDiskAltOutline.svelte
mark_module_start();
FloppyDiskAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FloppyDiskAltOutline.svelte";
var root_1290 = add_locations(ns_template(`<title> </title>`), FloppyDiskAltOutline[FILENAME], [[41, 4]]);
var root_2290 = add_locations(ns_template(`<desc> </desc>`), FloppyDiskAltOutline[FILENAME], [[44, 4]]);
var root290 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M11 16h2m6.707-9.293-2.414-2.414A1 1 0 0 0 16.586 4H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V7.414a1 1 0 0 0-.293-.707ZM16 20v-6a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v6h8ZM9 4h6v3a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1V4Z"></path></svg>`), FloppyDiskAltOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FloppyDiskAltOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FloppyDiskAltOutline);
  validate_prop_bindings($$props, [], [], FloppyDiskAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "floppy disk alt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root290();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1290();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2290();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FloppyDiskAltOutline = hmr(FloppyDiskAltOutline, () => FloppyDiskAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FloppyDiskAltOutline[HMR].source;
    set(FloppyDiskAltOutline[HMR].source, module.default[HMR].original);
  });
}
var FloppyDiskAltOutline_default = FloppyDiskAltOutline;
mark_module_end(FloppyDiskAltOutline);

// node_modules/flowbite-svelte-icons/dist/FloppyDiskAltSolid.svelte
mark_module_start();
FloppyDiskAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FloppyDiskAltSolid.svelte";
var root_1291 = add_locations(ns_template(`<title> </title>`), FloppyDiskAltSolid[FILENAME], [[39, 4]]);
var root_2291 = add_locations(ns_template(`<desc> </desc>`), FloppyDiskAltSolid[FILENAME], [[42, 4]]);
var root291 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7.414A2 2 0 0 0 20.414 6L18 3.586A2 2 0 0 0 16.586 3H5Zm3 11a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v6H8v-6Zm1-7V5h6v2a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M14 17h-4v-2h4v2Z" clip-rule="evenodd"></path></svg>`), FloppyDiskAltSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 5]]]
]);
function FloppyDiskAltSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FloppyDiskAltSolid);
  validate_prop_bindings($$props, [], [], FloppyDiskAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "floppy disk alt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root291();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1291();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2291();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FloppyDiskAltSolid = hmr(FloppyDiskAltSolid, () => FloppyDiskAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FloppyDiskAltSolid[HMR].source;
    set(FloppyDiskAltSolid[HMR].source, module.default[HMR].original);
  });
}
var FloppyDiskAltSolid_default = FloppyDiskAltSolid;
mark_module_end(FloppyDiskAltSolid);

// node_modules/flowbite-svelte-icons/dist/FloppyDiskOutline.svelte
mark_module_start();
FloppyDiskOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FloppyDiskOutline.svelte";
var root_1292 = add_locations(ns_template(`<title> </title>`), FloppyDiskOutline[FILENAME], [[41, 4]]);
var root_2292 = add_locations(ns_template(`<desc> </desc>`), FloppyDiskOutline[FILENAME], [[44, 4]]);
var root292 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M4 5a1 1 0 0 1 1-1h11.586a1 1 0 0 1 .707.293l2.414 2.414a1 1 0 0 1 .293.707V19a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V5Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M8 4h8v4H8V4Zm7 10a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), FloppyDiskOutline[FILENAME], [
  [30, 0, [[46, 2], [52, 2]]]
]);
function FloppyDiskOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FloppyDiskOutline);
  validate_prop_bindings($$props, [], [], FloppyDiskOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "floppy disk outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root292();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1292();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2292();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FloppyDiskOutline = hmr(FloppyDiskOutline, () => FloppyDiskOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FloppyDiskOutline[HMR].source;
    set(FloppyDiskOutline[HMR].source, module.default[HMR].original);
  });
}
var FloppyDiskOutline_default = FloppyDiskOutline;
mark_module_end(FloppyDiskOutline);

// node_modules/flowbite-svelte-icons/dist/FloppyDiskSolid.svelte
mark_module_start();
FloppyDiskSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FloppyDiskSolid.svelte";
var root_1293 = add_locations(ns_template(`<title> </title>`), FloppyDiskSolid[FILENAME], [[39, 4]]);
var root_2293 = add_locations(ns_template(`<desc> </desc>`), FloppyDiskSolid[FILENAME], [[42, 4]]);
var root293 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V7.414A2 2 0 0 0 20.414 6L18 3.586A2 2 0 0 0 16.586 3H5Zm10 11a3 3 0 1 1-6 0 3 3 0 0 1 6 0ZM8 7V5h8v2a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), FloppyDiskSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FloppyDiskSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FloppyDiskSolid);
  validate_prop_bindings($$props, [], [], FloppyDiskSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "floppy disk solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root293();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1293();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2293();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FloppyDiskSolid = hmr(FloppyDiskSolid, () => FloppyDiskSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FloppyDiskSolid[HMR].source;
    set(FloppyDiskSolid[HMR].source, module.default[HMR].original);
  });
}
var FloppyDiskSolid_default = FloppyDiskSolid;
mark_module_end(FloppyDiskSolid);

// node_modules/flowbite-svelte-icons/dist/FlowbiteSolid.svelte
mark_module_start();
FlowbiteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FlowbiteSolid.svelte";
var root_1294 = add_locations(ns_template(`<title> </title>`), FlowbiteSolid[FILENAME], [[39, 4]]);
var root_2294 = add_locations(ns_template(`<desc> </desc>`), FlowbiteSolid[FILENAME], [[42, 4]]);
var root294 = add_locations(ns_template(`<svg><!><!><path d="M15.907 11.998 10.332 9.23a.9.9 0 0 1-.16-.037l-.018-.007v6.554c0 .017.008.034.01.051l2.388-2.974 3.355-.82Z"></path><path d="m11.463 4.054 5.579 3.323A4.02 4.02 0 0 1 18.525 9c.332.668.47 1.414.398 2.155a3.07 3.07 0 0 1-.745 1.65 3.108 3.108 0 0 1-1.55.951c-.022.007-.045.005-.07.01-.062.03-.126.057-.191.08l-2.72.667-1.992 2.48c-.18.227-.41.409-.67.534.047.034.085.077.137.107a2.05 2.05 0 0 0 1.995.035c.592-.33 2.15-1.201 4.636-2.892l.28-.19c1.328-.895 3.616-2.442 3.967-4.215a9.94 9.94 0 0 0-1.713-4.154 10.027 10.027 0 0 0-3.375-2.989 10.107 10.107 0 0 0-8.802-.418c1.162.287 2.287.704 3.354 1.243Z"></path><path d="M5.382 17.082v-6.457a3.7 3.7 0 0 1 .45-1.761 3.733 3.733 0 0 1 1.238-1.34 3.915 3.915 0 0 1 3.433-.245c.176.03.347.084.508.161l5.753 2.856c.082.05.161.105.236.165a2.128 2.128 0 0 0-.953-1.455l-5.51-3.284c-1.74-.857-3.906-1.523-5.244-1.097a9.96 9.96 0 0 0-2.5 3.496 9.895 9.895 0 0 0 .283 8.368 9.973 9.973 0 0 0 2.73 3.322 17.161 17.161 0 0 1-.424-2.729Z"></path><path d="m19.102 16.163-.272.183c-2.557 1.74-4.169 2.64-4.698 2.935a4.083 4.083 0 0 1-2 .53 3.946 3.946 0 0 1-1.983-.535 3.788 3.788 0 0 1-1.36-1.361 3.752 3.752 0 0 1-.51-1.85 1.812 1.812 0 0 1-.043-.26V9.143c0-.024.009-.046.01-.07-.056.02-.11.043-.162.07a1.796 1.796 0 0 0-.787 1.516v6.377a10.67 10.67 0 0 0 1.113 4.27 10.11 10.11 0 0 0 8.505-.53 10.022 10.022 0 0 0 3.282-2.858 9.936 9.936 0 0 0 1.75-3.97 19.615 19.615 0 0 1-2.845 2.216Z"></path></svg>`), FlowbiteSolid[FILENAME], [
  [
    29,
    0,
    [
      [44, 2],
      [47, 2],
      [50, 2],
      [53, 2]
    ]
  ]
]);
function FlowbiteSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FlowbiteSolid);
  validate_prop_bindings($$props, [], [], FlowbiteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "flowbite solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root294();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1294();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2294();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(4);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FlowbiteSolid = hmr(FlowbiteSolid, () => FlowbiteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FlowbiteSolid[HMR].source;
    set(FlowbiteSolid[HMR].source, module.default[HMR].original);
  });
}
var FlowbiteSolid_default = FlowbiteSolid;
mark_module_end(FlowbiteSolid);

// node_modules/flowbite-svelte-icons/dist/FolderArrowRightOutline.svelte
mark_module_start();
FolderArrowRightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderArrowRightOutline.svelte";
var root_1295 = add_locations(ns_template(`<title> </title>`), FolderArrowRightOutline[FILENAME], [[41, 4]]);
var root_2295 = add_locations(ns_template(`<desc> </desc>`), FolderArrowRightOutline[FILENAME], [[44, 4]]);
var root295 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.5 8H4m4 6h8m0 0-2-2m2 2-2 2M4 6v13a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-5.032a1 1 0 0 1-.768-.36l-1.9-2.28a1 1 0 0 0-.768-.36H5a1 1 0 0 0-1 1Z"></path></svg>`), FolderArrowRightOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FolderArrowRightOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderArrowRightOutline);
  validate_prop_bindings($$props, [], [], FolderArrowRightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "folder arrow right outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root295();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1295();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2295();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderArrowRightOutline = hmr(FolderArrowRightOutline, () => FolderArrowRightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderArrowRightOutline[HMR].source;
    set(FolderArrowRightOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderArrowRightOutline_default = FolderArrowRightOutline;
mark_module_end(FolderArrowRightOutline);

// node_modules/flowbite-svelte-icons/dist/FolderArrowRightSolid.svelte
mark_module_start();
FolderArrowRightSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderArrowRightSolid.svelte";
var root_1296 = add_locations(ns_template(`<title> </title>`), FolderArrowRightSolid[FILENAME], [[39, 4]]);
var root_2296 = add_locations(ns_template(`<desc> </desc>`), FolderArrowRightSolid[FILENAME], [[42, 4]]);
var root296 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 4a2 2 0 0 0-2 2v1h10.968l-1.9-2.28A2 2 0 0 0 10.532 4H5ZM3 19V9h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm11.707-7.707a1 1 0 0 0-1.414 1.414l.293.293H8a1 1 0 1 0 0 2h5.586l-.293.293a1 1 0 0 0 1.414 1.414l2-2a1 1 0 0 0 0-1.414l-2-2Z" clip-rule="evenodd"></path></svg>`), FolderArrowRightSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FolderArrowRightSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderArrowRightSolid);
  validate_prop_bindings($$props, [], [], FolderArrowRightSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "folder arrow right solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root296();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1296();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2296();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderArrowRightSolid = hmr(FolderArrowRightSolid, () => FolderArrowRightSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderArrowRightSolid[HMR].source;
    set(FolderArrowRightSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderArrowRightSolid_default = FolderArrowRightSolid;
mark_module_end(FolderArrowRightSolid);

// node_modules/flowbite-svelte-icons/dist/FolderDuplicateOutline.svelte
mark_module_start();
FolderDuplicateOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderDuplicateOutline.svelte";
var root_1297 = add_locations(ns_template(`<title> </title>`), FolderDuplicateOutline[FILENAME], [[41, 4]]);
var root_2297 = add_locations(ns_template(`<desc> </desc>`), FolderDuplicateOutline[FILENAME], [[44, 4]]);
var root297 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 11H4m15.5 5a.5.5 0 0 0 .5-.5V8a1 1 0 0 0-1-1h-3.75a1 1 0 0 1-.829-.44l-1.436-2.12a1 1 0 0 0-.828-.44H8a1 1 0 0 0-1 1M4 9v10a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1h-3.75a1 1 0 0 1-.829-.44L9.985 8.44A1 1 0 0 0 9.157 8H5a1 1 0 0 0-1 1Z"></path></svg>`), FolderDuplicateOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FolderDuplicateOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderDuplicateOutline);
  validate_prop_bindings($$props, [], [], FolderDuplicateOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "folder duplicate outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root297();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1297();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2297();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderDuplicateOutline = hmr(FolderDuplicateOutline, () => FolderDuplicateOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderDuplicateOutline[HMR].source;
    set(FolderDuplicateOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderDuplicateOutline_default = FolderDuplicateOutline;
mark_module_end(FolderDuplicateOutline);

// node_modules/flowbite-svelte-icons/dist/FolderDuplicateSolid.svelte
mark_module_start();
FolderDuplicateSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderDuplicateSolid.svelte";
var root_1298 = add_locations(ns_template(`<title> </title>`), FolderDuplicateSolid[FILENAME], [[39, 4]]);
var root_2298 = add_locations(ns_template(`<desc> </desc>`), FolderDuplicateSolid[FILENAME], [[42, 4]]);
var root298 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M6 5a2 2 0 0 1 2-2h4.157a2 2 0 0 1 1.656.879L15.249 6H19a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2v-5a3 3 0 0 0-3-3h-3.22l-1.14-1.682A3 3 0 0 0 9.157 6H6V5Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M3 9a2 2 0 0 1 2-2h4.157a2 2 0 0 1 1.656.879L12.249 10H3V9Zm0 3v7a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2v-7H3Z" clip-rule="evenodd"></path></svg>`), FolderDuplicateSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function FolderDuplicateSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderDuplicateSolid);
  validate_prop_bindings($$props, [], [], FolderDuplicateSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "folder duplicate solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root298();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1298();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2298();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderDuplicateSolid = hmr(FolderDuplicateSolid, () => FolderDuplicateSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderDuplicateSolid[HMR].source;
    set(FolderDuplicateSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderDuplicateSolid_default = FolderDuplicateSolid;
mark_module_end(FolderDuplicateSolid);

// node_modules/flowbite-svelte-icons/dist/FolderOpenOutline.svelte
mark_module_start();
FolderOpenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderOpenOutline.svelte";
var root_1299 = add_locations(ns_template(`<title> </title>`), FolderOpenOutline[FILENAME], [[41, 4]]);
var root_2299 = add_locations(ns_template(`<desc> </desc>`), FolderOpenOutline[FILENAME], [[44, 4]]);
var root299 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 19V6a1 1 0 0 1 1-1h4.032a1 1 0 0 1 .768.36l1.9 2.28a1 1 0 0 0 .768.36H16a1 1 0 0 1 1 1v1M3 19l3-8h15l-3 8H3Z"></path></svg>`), FolderOpenOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FolderOpenOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderOpenOutline);
  validate_prop_bindings($$props, [], [], FolderOpenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "folder open outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root299();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1299();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2299();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderOpenOutline = hmr(FolderOpenOutline, () => FolderOpenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderOpenOutline[HMR].source;
    set(FolderOpenOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderOpenOutline_default = FolderOpenOutline;
mark_module_end(FolderOpenOutline);

// node_modules/flowbite-svelte-icons/dist/FolderOpenSolid.svelte
mark_module_start();
FolderOpenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderOpenSolid.svelte";
var root_1300 = add_locations(ns_template(`<title> </title>`), FolderOpenSolid[FILENAME], [[39, 4]]);
var root_2300 = add_locations(ns_template(`<desc> </desc>`), FolderOpenSolid[FILENAME], [[42, 4]]);
var root300 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 .087.586l2.977-7.937A1 1 0 0 1 6 10h12V9a2 2 0 0 0-2-2h-4.532l-1.9-2.28A2 2 0 0 0 8.032 4H4Zm2.693 8H6.5l-3 8H18l3-8H6.693Z" clip-rule="evenodd"></path></svg>`), FolderOpenSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FolderOpenSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderOpenSolid);
  validate_prop_bindings($$props, [], [], FolderOpenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "folder open solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root300();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1300();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2300();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderOpenSolid = hmr(FolderOpenSolid, () => FolderOpenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderOpenSolid[HMR].source;
    set(FolderOpenSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderOpenSolid_default = FolderOpenSolid;
mark_module_end(FolderOpenSolid);

// node_modules/flowbite-svelte-icons/dist/FolderOutline.svelte
mark_module_start();
FolderOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderOutline.svelte";
var root_1301 = add_locations(ns_template(`<title> </title>`), FolderOutline[FILENAME], [[41, 4]]);
var root_2301 = add_locations(ns_template(`<desc> </desc>`), FolderOutline[FILENAME], [[44, 4]]);
var root301 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.5 8H4m0-2v13a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-5.032a1 1 0 0 1-.768-.36l-1.9-2.28a1 1 0 0 0-.768-.36H5a1 1 0 0 0-1 1Z"></path></svg>`), FolderOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FolderOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderOutline);
  validate_prop_bindings($$props, [], [], FolderOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "folder outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root301();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1301();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2301();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderOutline = hmr(FolderOutline, () => FolderOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderOutline[HMR].source;
    set(FolderOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderOutline_default = FolderOutline;
mark_module_end(FolderOutline);

// node_modules/flowbite-svelte-icons/dist/FolderPlusOutline.svelte
mark_module_start();
FolderPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderPlusOutline.svelte";
var root_1302 = add_locations(ns_template(`<title> </title>`), FolderPlusOutline[FILENAME], [[41, 4]]);
var root_2302 = add_locations(ns_template(`<desc> </desc>`), FolderPlusOutline[FILENAME], [[44, 4]]);
var root302 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14 8H4m8 3.5v5M9.5 14h5M4 6v13a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-5.032a1 1 0 0 1-.768-.36l-1.9-2.28a1 1 0 0 0-.768-.36H5a1 1 0 0 0-1 1Z"></path></svg>`), FolderPlusOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FolderPlusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderPlusOutline);
  validate_prop_bindings($$props, [], [], FolderPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "folder plus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root302();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1302();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2302();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderPlusOutline = hmr(FolderPlusOutline, () => FolderPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderPlusOutline[HMR].source;
    set(FolderPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var FolderPlusOutline_default = FolderPlusOutline;
mark_module_end(FolderPlusOutline);

// node_modules/flowbite-svelte-icons/dist/FolderPlusSolid.svelte
mark_module_start();
FolderPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderPlusSolid.svelte";
var root_1303 = add_locations(ns_template(`<title> </title>`), FolderPlusSolid[FILENAME], [[39, 4]]);
var root_2303 = add_locations(ns_template(`<desc> </desc>`), FolderPlusSolid[FILENAME], [[42, 4]]);
var root303 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 4a2 2 0 0 0-2 2v1h10.968l-1.9-2.28A2 2 0 0 0 10.532 4H5ZM3 19V9h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm9-8.5a1 1 0 0 1 1 1V13h1.5a1 1 0 1 1 0 2H13v1.5a1 1 0 1 1-2 0V15H9.5a1 1 0 1 1 0-2H11v-1.5a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), FolderPlusSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FolderPlusSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderPlusSolid);
  validate_prop_bindings($$props, [], [], FolderPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "folder plus solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root303();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1303();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2303();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderPlusSolid = hmr(FolderPlusSolid, () => FolderPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderPlusSolid[HMR].source;
    set(FolderPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderPlusSolid_default = FolderPlusSolid;
mark_module_end(FolderPlusSolid);

// node_modules/flowbite-svelte-icons/dist/FolderSolid.svelte
mark_module_start();
FolderSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FolderSolid.svelte";
var root_1304 = add_locations(ns_template(`<title> </title>`), FolderSolid[FILENAME], [[39, 4]]);
var root_2304 = add_locations(ns_template(`<desc> </desc>`), FolderSolid[FILENAME], [[42, 4]]);
var root304 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M3 6a2 2 0 0 1 2-2h5.532a2 2 0 0 1 1.536.72l1.9 2.28H3V6Zm0 3v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9H3Z" clip-rule="evenodd"></path></svg>`), FolderSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function FolderSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FolderSolid);
  validate_prop_bindings($$props, [], [], FolderSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "folder solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root304();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1304();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2304();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FolderSolid = hmr(FolderSolid, () => FolderSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FolderSolid[HMR].source;
    set(FolderSolid[HMR].source, module.default[HMR].original);
  });
}
var FolderSolid_default = FolderSolid;
mark_module_end(FolderSolid);

// node_modules/flowbite-svelte-icons/dist/FontColorAltSolid.svelte
mark_module_start();
FontColorAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FontColorAltSolid.svelte";
var root_1305 = add_locations(ns_template(`<title> </title>`), FontColorAltSolid[FILENAME], [[39, 4]]);
var root_2305 = add_locations(ns_template(`<desc> </desc>`), FontColorAltSolid[FILENAME], [[42, 4]]);
var root305 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M19.9999 18.0661c0 1.6203-1.3431 2.9339-3 2.9339-1.6568 0-3-1.3136-3-2.9339 0-1.6204 3-6.0661 3-6.0661s3 4.4457 3 6.0661Z"></path><path fill="currentColor" fill-rule="evenodd" d="M10.4817 7.52489 9.12238 10.9817H11.841l-1.3593-3.45681Zm3.7494 4.06961-2.7166-6.90843c-.3694-.93918-1.69627-.93917-2.06558 0L6.76269 11.5173c-.03333.0634-.06004.1309-.07922.2014l-1.28309 3.263h-.41869c-.55229 0-1 .4477-1 1s.44771 1 1 1h2.75c.55228 0 1-.4477 1-1s-.44772-1-1-1h-.18223l.78646-2h4.29158l.3676.9349c.2021.514.7826.7668 1.2966.5647.514-.2021.7668-.7826.5647-1.2966l-.6085-1.5473c-.0053-.0144-.0109-.0287-.0168-.0429Z" clip-rule="evenodd"></path></svg>`), FontColorAltSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 2]]]
]);
function FontColorAltSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FontColorAltSolid);
  validate_prop_bindings($$props, [], [], FontColorAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "font color alt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root305();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1305();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2305();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FontColorAltSolid = hmr(FontColorAltSolid, () => FontColorAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FontColorAltSolid[HMR].source;
    set(FontColorAltSolid[HMR].source, module.default[HMR].original);
  });
}
var FontColorAltSolid_default = FontColorAltSolid;
mark_module_end(FontColorAltSolid);

// node_modules/flowbite-svelte-icons/dist/FontColorOutline.svelte
mark_module_start();
FontColorOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FontColorOutline.svelte";
var root_1306 = add_locations(ns_template(`<title> </title>`), FontColorOutline[FILENAME], [[41, 4]]);
var root_2306 = add_locations(ns_template(`<desc> </desc>`), FontColorOutline[FILENAME], [[44, 4]]);
var root306 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m6.08169 15.9817 1.57292-4m-1.57292 4h-1.1m1.1 0h1.65m-.07708-4 2.72499-6.92967c.0368-.09379.1673-.09379.2042 0l2.725 6.92967m-5.65419 0h-.00607m.00607 0h5.65419m0 0 .6169 1.569m5.1104 4.453c0 1.1025-.8543 1.9963-1.908 1.9963s-1.908-.8938-1.908-1.9963c0-1.1026 1.908-4.1275 1.908-4.1275s1.908 3.0249 1.908 4.1275Z"></path></svg>`), FontColorOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FontColorOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FontColorOutline);
  validate_prop_bindings($$props, [], [], FontColorOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "font color outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root306();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1306();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2306();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FontColorOutline = hmr(FontColorOutline, () => FontColorOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FontColorOutline[HMR].source;
    set(FontColorOutline[HMR].source, module.default[HMR].original);
  });
}
var FontColorOutline_default = FontColorOutline;
mark_module_end(FontColorOutline);

// node_modules/flowbite-svelte-icons/dist/FontFamilyOutline.svelte
mark_module_start();
FontFamilyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FontFamilyOutline.svelte";
var root_1307 = add_locations(ns_template(`<title> </title>`), FontFamilyOutline[FILENAME], [[41, 4]]);
var root_2307 = add_locations(ns_template(`<desc> </desc>`), FontFamilyOutline[FILENAME], [[44, 4]]);
var root307 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10.5785 19 4.2979-10.92966c.0369-.09379.1674-.09379.2042 0L19.3785 19m-8.8 0H9.47851m1.09999 0h1.65m7.15 0h-1.65m1.65 0h1.1m-7.7-3.9846h4.4M3 16l1.56685-3.9846m0 0 2.73102-6.94506c.03688-.09379.16738-.09379.20426 0l2.50367 6.94506H4.56685Z"></path></svg>`), FontFamilyOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FontFamilyOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FontFamilyOutline);
  validate_prop_bindings($$props, [], [], FontFamilyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "font family outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root307();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1307();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2307();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FontFamilyOutline = hmr(FontFamilyOutline, () => FontFamilyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FontFamilyOutline[HMR].source;
    set(FontFamilyOutline[HMR].source, module.default[HMR].original);
  });
}
var FontFamilyOutline_default = FontFamilyOutline;
mark_module_end(FontFamilyOutline);

// node_modules/flowbite-svelte-icons/dist/FontHighlightOutline.svelte
mark_module_start();
FontHighlightOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/FontHighlightOutline.svelte";
var root_1308 = add_locations(ns_template(`<title> </title>`), FontHighlightOutline[FILENAME], [[41, 4]]);
var root_2308 = add_locations(ns_template(`<desc> </desc>`), FontHighlightOutline[FILENAME], [[44, 4]]);
var root308 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M9 20H5.5c-.27614 0-.5-.2239-.5-.5v-3c0-.2761.22386-.5.5-.5h13c.2761 0 .5.2239.5.5v3c0 .2761-.2239.5-.5.5H18m-6-1 1.42 1.8933c.04.0534.12.0534.16 0L15 19m-7-6 3.9072-9.76789c.0335-.08381.1521-.08381.1856 0L16 13m-8 0H7m1 0h1.5m6.5 0h-1.5m1.5 0h1m-7-3.00001h4"></path></svg>`), FontHighlightOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function FontHighlightOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, FontHighlightOutline);
  validate_prop_bindings($$props, [], [], FontHighlightOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "font highlight outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root308();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1308();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2308();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  FontHighlightOutline = hmr(FontHighlightOutline, () => FontHighlightOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = FontHighlightOutline[HMR].source;
    set(FontHighlightOutline[HMR].source, module.default[HMR].original);
  });
}
var FontHighlightOutline_default = FontHighlightOutline;
mark_module_end(FontHighlightOutline);

// node_modules/flowbite-svelte-icons/dist/ForwardOutline.svelte
mark_module_start();
ForwardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ForwardOutline.svelte";
var root_1309 = add_locations(ns_template(`<title> </title>`), ForwardOutline[FILENAME], [[41, 4]]);
var root_2309 = add_locations(ns_template(`<desc> </desc>`), ForwardOutline[FILENAME], [[44, 4]]);
var root309 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4.248 19C3.22 15.77 5.275 8.232 12.466 8.232V6.079a1.025 1.025 0 0 1 1.644-.862l5.479 4.307a1.108 1.108 0 0 1 0 1.723l-5.48 4.307a1.026 1.026 0 0 1-1.643-.861v-2.154C5.275 13.616 4.248 19 4.248 19Z"></path></svg>`), ForwardOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ForwardOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ForwardOutline);
  validate_prop_bindings($$props, [], [], ForwardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "forward outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root309();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1309();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2309();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ForwardOutline = hmr(ForwardOutline, () => ForwardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ForwardOutline[HMR].source;
    set(ForwardOutline[HMR].source, module.default[HMR].original);
  });
}
var ForwardOutline_default = ForwardOutline;
mark_module_end(ForwardOutline);

// node_modules/flowbite-svelte-icons/dist/ForwardSolid.svelte
mark_module_start();
ForwardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ForwardSolid.svelte";
var root_1310 = add_locations(ns_template(`<title> </title>`), ForwardSolid[FILENAME], [[39, 4]]);
var root_2310 = add_locations(ns_template(`<desc> </desc>`), ForwardSolid[FILENAME], [[42, 4]]);
var root310 = add_locations(ns_template(`<svg><!><!><path d="M5.027 10.9a8.729 8.729 0 0 1 6.422-3.62v-1.2A2.061 2.061 0 0 1 12.61 4.2a1.986 1.986 0 0 1 2.104.23l5.491 4.308a2.11 2.11 0 0 1 .588 2.566 2.109 2.109 0 0 1-.588.734l-5.489 4.308a1.983 1.983 0 0 1-2.104.228 2.065 2.065 0 0 1-1.16-1.876v-.942c-5.33 1.284-6.212 5.251-6.25 5.441a1 1 0 0 1-.923.806h-.06a1.003 1.003 0 0 1-.955-.7A10.221 10.221 0 0 1 5.027 10.9Z"></path></svg>`), ForwardSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ForwardSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ForwardSolid);
  validate_prop_bindings($$props, [], [], ForwardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "forward solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root310();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1310();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2310();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ForwardSolid = hmr(ForwardSolid, () => ForwardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ForwardSolid[HMR].source;
    set(ForwardSolid[HMR].source, module.default[HMR].original);
  });
}
var ForwardSolid_default = ForwardSolid;
mark_module_end(ForwardSolid);

// node_modules/flowbite-svelte-icons/dist/ForwardStepOutline.svelte
mark_module_start();
ForwardStepOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ForwardStepOutline.svelte";
var root_1311 = add_locations(ns_template(`<title> </title>`), ForwardStepOutline[FILENAME], [[41, 4]]);
var root_2311 = add_locations(ns_template(`<desc> </desc>`), ForwardStepOutline[FILENAME], [[44, 4]]);
var root311 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 6v12M8 6v12l8-6-8-6Z"></path></svg>`), ForwardStepOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ForwardStepOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ForwardStepOutline);
  validate_prop_bindings($$props, [], [], ForwardStepOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "forward step outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root311();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1311();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2311();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ForwardStepOutline = hmr(ForwardStepOutline, () => ForwardStepOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ForwardStepOutline[HMR].source;
    set(ForwardStepOutline[HMR].source, module.default[HMR].original);
  });
}
var ForwardStepOutline_default = ForwardStepOutline;
mark_module_end(ForwardStepOutline);

// node_modules/flowbite-svelte-icons/dist/ForwardStepSolid.svelte
mark_module_start();
ForwardStepSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ForwardStepSolid.svelte";
var root_1312 = add_locations(ns_template(`<title> </title>`), ForwardStepSolid[FILENAME], [[39, 4]]);
var root_2312 = add_locations(ns_template(`<desc> </desc>`), ForwardStepSolid[FILENAME], [[42, 4]]);
var root312 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M17 6a1 1 0 1 0-2 0v4L8.6 5.2A1 1 0 0 0 7 6v12a1 1 0 0 0 1.6.8L15 14v4a1 1 0 1 0 2 0V6Z" clip-rule="evenodd"></path></svg>`), ForwardStepSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ForwardStepSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ForwardStepSolid);
  validate_prop_bindings($$props, [], [], ForwardStepSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "forward step solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root312();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1312();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2312();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ForwardStepSolid = hmr(ForwardStepSolid, () => ForwardStepSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ForwardStepSolid[HMR].source;
    set(ForwardStepSolid[HMR].source, module.default[HMR].original);
  });
}
var ForwardStepSolid_default = ForwardStepSolid;
mark_module_end(ForwardStepSolid);

// node_modules/flowbite-svelte-icons/dist/GiftBoxOutline.svelte
mark_module_start();
GiftBoxOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GiftBoxOutline.svelte";
var root_1313 = add_locations(ns_template(`<title> </title>`), GiftBoxOutline[FILENAME], [[41, 4]]);
var root_2313 = add_locations(ns_template(`<desc> </desc>`), GiftBoxOutline[FILENAME], [[44, 4]]);
var root313 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 21v-9m3-4H7.5a2.5 2.5 0 1 1 0-5c1.5 0 2.875 1.25 3.875 2.5M14 21v-9m-9 0h14v8a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1v-8ZM4 8h16a1 1 0 0 1 1 1v3H3V9a1 1 0 0 1 1-1Zm12.155-5c-3 0-5.5 5-5.5 5h5.5a2.5 2.5 0 0 0 0-5Z"></path></svg>`), GiftBoxOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function GiftBoxOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GiftBoxOutline);
  validate_prop_bindings($$props, [], [], GiftBoxOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "gift box outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root313();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1313();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2313();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GiftBoxOutline = hmr(GiftBoxOutline, () => GiftBoxOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GiftBoxOutline[HMR].source;
    set(GiftBoxOutline[HMR].source, module.default[HMR].original);
  });
}
var GiftBoxOutline_default = GiftBoxOutline;
mark_module_end(GiftBoxOutline);

// node_modules/flowbite-svelte-icons/dist/GiftBoxSolid.svelte
mark_module_start();
GiftBoxSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GiftBoxSolid.svelte";
var root_1314 = add_locations(ns_template(`<title> </title>`), GiftBoxSolid[FILENAME], [[39, 4]]);
var root_2314 = add_locations(ns_template(`<desc> </desc>`), GiftBoxSolid[FILENAME], [[42, 4]]);
var root314 = add_locations(ns_template(`<svg><!><!><path d="M20 7h-.7c.229-.467.349-.98.351-1.5a3.5 3.5 0 0 0-3.5-3.5c-1.717 0-3.215 1.2-4.331 2.481C10.4 2.842 8.949 2 7.5 2A3.5 3.5 0 0 0 4 5.5c.003.52.123 1.033.351 1.5H4a2 2 0 0 0-2 2v2a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V9a2 2 0 0 0-2-2Zm-9.942 0H7.5a1.5 1.5 0 0 1 0-3c.9 0 2 .754 3.092 2.122-.219.337-.392.635-.534.878Zm6.1 0h-3.742c.933-1.368 2.371-3 3.739-3a1.5 1.5 0 0 1 0 3h.003ZM13 14h-2v8h2v-8Zm-4 0H4v6a2 2 0 0 0 2 2h3v-8Zm6 0v8h3a2 2 0 0 0 2-2v-6h-5Z"></path></svg>`), GiftBoxSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function GiftBoxSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GiftBoxSolid);
  validate_prop_bindings($$props, [], [], GiftBoxSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "gift box solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root314();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1314();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2314();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GiftBoxSolid = hmr(GiftBoxSolid, () => GiftBoxSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GiftBoxSolid[HMR].source;
    set(GiftBoxSolid[HMR].source, module.default[HMR].original);
  });
}
var GiftBoxSolid_default = GiftBoxSolid;
mark_module_end(GiftBoxSolid);

// node_modules/flowbite-svelte-icons/dist/GithubSolid.svelte
mark_module_start();
GithubSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GithubSolid.svelte";
var root_1315 = add_locations(ns_template(`<title> </title>`), GithubSolid[FILENAME], [[39, 4]]);
var root_2315 = add_locations(ns_template(`<desc> </desc>`), GithubSolid[FILENAME], [[42, 4]]);
var root315 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12.006 2a9.847 9.847 0 0 0-6.484 2.44 10.32 10.32 0 0 0-3.393 6.17 10.48 10.48 0 0 0 1.317 6.955 10.045 10.045 0 0 0 5.4 4.418c.504.095.683-.223.683-.494 0-.245-.01-1.052-.014-1.908-2.78.62-3.366-1.21-3.366-1.21a2.711 2.711 0 0 0-1.11-1.5c-.907-.637.07-.621.07-.621.317.044.62.163.885.346.266.183.487.426.647.71.135.253.318.476.538.655a2.079 2.079 0 0 0 2.37.196c.045-.52.27-1.006.635-1.37-2.219-.259-4.554-1.138-4.554-5.07a4.022 4.022 0 0 1 1.031-2.75 3.77 3.77 0 0 1 .096-2.713s.839-.275 2.749 1.05a9.26 9.26 0 0 1 5.004 0c1.906-1.325 2.74-1.05 2.74-1.05.37.858.406 1.828.101 2.713a4.017 4.017 0 0 1 1.029 2.75c0 3.939-2.339 4.805-4.564 5.058a2.471 2.471 0 0 1 .679 1.897c0 1.372-.012 2.477-.012 2.814 0 .272.18.592.687.492a10.05 10.05 0 0 0 5.388-4.421 10.473 10.473 0 0 0 1.313-6.948 10.32 10.32 0 0 0-3.39-6.165A9.847 9.847 0 0 0 12.007 2Z" clip-rule="evenodd"></path></svg>`), GithubSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function GithubSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GithubSolid);
  validate_prop_bindings($$props, [], [], GithubSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "github solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root315();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1315();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2315();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GithubSolid = hmr(GithubSolid, () => GithubSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GithubSolid[HMR].source;
    set(GithubSolid[HMR].source, module.default[HMR].original);
  });
}
var GithubSolid_default = GithubSolid;
mark_module_end(GithubSolid);

// node_modules/flowbite-svelte-icons/dist/GitlabSolid.svelte
mark_module_start();
GitlabSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GitlabSolid.svelte";
var root_1316 = add_locations(ns_template(`<title> </title>`), GitlabSolid[FILENAME], [[39, 4]]);
var root_2316 = add_locations(ns_template(`<desc> </desc>`), GitlabSolid[FILENAME], [[42, 4]]);
var root316 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="m20.7011 10.1255-.0253-.0672-2.4501-6.63953c-.0498-.13013-.1381-.24053-.2521-.31534-.1141-.07354-.2472-.10896-.3812-.10147-.1341.00748-.2628.05751-.3686.14332-.1047.08828-.1806.2079-.2175.34259l-1.6543 5.2556H8.65334l-1.65429-5.2556c-.03588-.13542-.11197-.25564-.21745-.34356-.10584-.08582-.23449-.13584-.36857-.14333-.13409-.00748-.26716.02794-.38125.10148-.11376.07511-.20195.18541-.25213.31534l-2.45472 6.6367-.02437.0671c-.35269.9569-.39623 2.007-.12404 2.9918.27219.9849.84535 1.8511 1.63305 2.4682l.00844.0068.02249.0166 3.73223 2.9022 1.84647 1.4512 1.1247.8817c.1316.1037.2922.1599.4574.1599.1652 0 .3258-.0562.4574-.1599l1.1247-.8817 1.8464-1.4512 3.7548-2.9198.0093-.0077c.786-.6172 1.3578-1.4826 1.6296-2.4661.2717-.9835.2288-2.0321-.1224-2.9881Z"></path></svg>`), GitlabSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function GitlabSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GitlabSolid);
  validate_prop_bindings($$props, [], [], GitlabSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "gitlab solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root316();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1316();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2316();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GitlabSolid = hmr(GitlabSolid, () => GitlabSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GitlabSolid[HMR].source;
    set(GitlabSolid[HMR].source, module.default[HMR].original);
  });
}
var GitlabSolid_default = GitlabSolid;
mark_module_end(GitlabSolid);

// node_modules/flowbite-svelte-icons/dist/GlobeOutline.svelte
mark_module_start();
GlobeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GlobeOutline.svelte";
var root_1317 = add_locations(ns_template(`<title> </title>`), GlobeOutline[FILENAME], [[41, 4]]);
var root_2317 = add_locations(ns_template(`<desc> </desc>`), GlobeOutline[FILENAME], [[44, 4]]);
var root317 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M4.37 7.657c2.063.528 2.396 2.806 3.202 3.87 1.07 1.413 2.075 1.228 3.192 2.644 1.805 2.289 1.312 5.705 1.312 6.705M20 15h-1a4 4 0 0 0-4 4v1M8.587 3.992c0 .822.112 1.886 1.515 2.58 1.402.693 2.918.351 2.918 2.334 0 .276 0 2.008 1.972 2.008 2.026.031 2.026-1.678 2.026-2.008 0-.65.527-.9 1.177-.9H20M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), GlobeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function GlobeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GlobeOutline);
  validate_prop_bindings($$props, [], [], GlobeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "globe outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root317();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1317();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2317();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GlobeOutline = hmr(GlobeOutline, () => GlobeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GlobeOutline[HMR].source;
    set(GlobeOutline[HMR].source, module.default[HMR].original);
  });
}
var GlobeOutline_default = GlobeOutline;
mark_module_end(GlobeOutline);

// node_modules/flowbite-svelte-icons/dist/GlobeSolid.svelte
mark_module_start();
GlobeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GlobeSolid.svelte";
var root_1318 = add_locations(ns_template(`<title> </title>`), GlobeSolid[FILENAME], [[39, 4]]);
var root_2318 = add_locations(ns_template(`<desc> </desc>`), GlobeSolid[FILENAME], [[42, 4]]);
var root318 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8.64 4.737A7.97 7.97 0 0 1 12 4a7.997 7.997 0 0 1 6.933 4.006h-.738c-.65 0-1.177.25-1.177.9 0 .33 0 2.04-2.026 2.008-1.972 0-1.972-1.732-1.972-2.008 0-1.429-.787-1.65-1.752-1.923-.374-.105-.774-.218-1.166-.411-1.004-.497-1.347-1.183-1.461-1.835ZM6 4a10.06 10.06 0 0 0-2.812 3.27A9.956 9.956 0 0 0 2 12c0 5.289 4.106 9.619 9.304 9.976l.054.004a10.12 10.12 0 0 0 1.155.007h.002a10.024 10.024 0 0 0 1.5-.19 9.925 9.925 0 0 0 2.259-.754 10.041 10.041 0 0 0 4.987-5.263A9.917 9.917 0 0 0 22 12a10.025 10.025 0 0 0-.315-2.5A10.001 10.001 0 0 0 12 2a9.964 9.964 0 0 0-6 2Zm13.372 11.113a2.575 2.575 0 0 0-.75-.112h-.217A3.405 3.405 0 0 0 15 18.405v1.014a8.027 8.027 0 0 0 4.372-4.307ZM12.114 20H12A8 8 0 0 1 5.1 7.95c.95.541 1.421 1.537 1.835 2.415.209.441.403.853.637 1.162.54.712 1.063 1.019 1.591 1.328.52.305 1.047.613 1.6 1.316 1.44 1.825 1.419 4.366 1.35 5.828Z" clip-rule="evenodd"></path></svg>`), GlobeSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function GlobeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GlobeSolid);
  validate_prop_bindings($$props, [], [], GlobeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "globe solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root318();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1318();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2318();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GlobeSolid = hmr(GlobeSolid, () => GlobeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GlobeSolid[HMR].source;
    set(GlobeSolid[HMR].source, module.default[HMR].original);
  });
}
var GlobeSolid_default = GlobeSolid;
mark_module_end(GlobeSolid);

// node_modules/flowbite-svelte-icons/dist/GoToNextCellOutline.svelte
mark_module_start();
GoToNextCellOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GoToNextCellOutline.svelte";
var root_1319 = add_locations(ns_template(`<title> </title>`), GoToNextCellOutline[FILENAME], [[41, 4]]);
var root_2319 = add_locations(ns_template(`<desc> </desc>`), GoToNextCellOutline[FILENAME], [[44, 4]]);
var root319 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h9.5M3 15v-4m0 4h9m-9-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v5H3Zm5 0v8m4-8v8m7.0999-1.0999L21 16m0 0-1.9001-1.9001M21 16h-5"></path></svg>`), GoToNextCellOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function GoToNextCellOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GoToNextCellOutline);
  validate_prop_bindings($$props, [], [], GoToNextCellOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "go to next cell outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root319();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1319();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2319();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GoToNextCellOutline = hmr(GoToNextCellOutline, () => GoToNextCellOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GoToNextCellOutline[HMR].source;
    set(GoToNextCellOutline[HMR].source, module.default[HMR].original);
  });
}
var GoToNextCellOutline_default = GoToNextCellOutline;
mark_module_end(GoToNextCellOutline);

// node_modules/flowbite-svelte-icons/dist/GoToPrevCellOutline.svelte
mark_module_start();
GoToPrevCellOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GoToPrevCellOutline.svelte";
var root_1320 = add_locations(ns_template(`<title> </title>`), GoToPrevCellOutline[FILENAME], [[41, 4]]);
var root_2320 = add_locations(ns_template(`<desc> </desc>`), GoToPrevCellOutline[FILENAME], [[44, 4]]);
var root320 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h9.5M3 15v-4m0 4h9m-9-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v5H3Zm5 0v8m4-8v8m5.9001-1.0999L16 16m0 0 1.9001-1.9001M16 16h5"></path></svg>`), GoToPrevCellOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function GoToPrevCellOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GoToPrevCellOutline);
  validate_prop_bindings($$props, [], [], GoToPrevCellOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "go to prev cell outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root320();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1320();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2320();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GoToPrevCellOutline = hmr(GoToPrevCellOutline, () => GoToPrevCellOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GoToPrevCellOutline[HMR].source;
    set(GoToPrevCellOutline[HMR].source, module.default[HMR].original);
  });
}
var GoToPrevCellOutline_default = GoToPrevCellOutline;
mark_module_end(GoToPrevCellOutline);

// node_modules/flowbite-svelte-icons/dist/GoogleSolid.svelte
mark_module_start();
GoogleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GoogleSolid.svelte";
var root_1321 = add_locations(ns_template(`<title> </title>`), GoogleSolid[FILENAME], [[39, 4]]);
var root_2321 = add_locations(ns_template(`<desc> </desc>`), GoogleSolid[FILENAME], [[42, 4]]);
var root321 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12.037 21.998a10.313 10.313 0 0 1-7.168-3.049 9.888 9.888 0 0 1-2.868-7.118 9.947 9.947 0 0 1 3.064-6.949A10.37 10.37 0 0 1 12.212 2h.176a9.935 9.935 0 0 1 6.614 2.564L16.457 6.88a6.187 6.187 0 0 0-4.131-1.566 6.9 6.9 0 0 0-4.794 1.913 6.618 6.618 0 0 0-2.045 4.657 6.608 6.608 0 0 0 1.882 4.723 6.891 6.891 0 0 0 4.725 2.07h.143c1.41.072 2.8-.354 3.917-1.2a5.77 5.77 0 0 0 2.172-3.41l.043-.117H12.22v-3.41h9.678c.075.617.109 1.238.1 1.859-.099 5.741-4.017 9.6-9.746 9.6l-.215-.002Z" clip-rule="evenodd"></path></svg>`), GoogleSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function GoogleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GoogleSolid);
  validate_prop_bindings($$props, [], [], GoogleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "google solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root321();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1321();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2321();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GoogleSolid = hmr(GoogleSolid, () => GoogleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GoogleSolid[HMR].source;
    set(GoogleSolid[HMR].source, module.default[HMR].original);
  });
}
var GoogleSolid_default = GoogleSolid;
mark_module_end(GoogleSolid);

// node_modules/flowbite-svelte-icons/dist/GridOutline.svelte
mark_module_start();
GridOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GridOutline.svelte";
var root_1322 = add_locations(ns_template(`<title> </title>`), GridOutline[FILENAME], [[41, 4]]);
var root_2322 = add_locations(ns_template(`<desc> </desc>`), GridOutline[FILENAME], [[44, 4]]);
var root322 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.143 4H4.857A.857.857 0 0 0 4 4.857v4.286c0 .473.384.857.857.857h4.286A.857.857 0 0 0 10 9.143V4.857A.857.857 0 0 0 9.143 4Zm10 0h-4.286a.857.857 0 0 0-.857.857v4.286c0 .473.384.857.857.857h4.286A.857.857 0 0 0 20 9.143V4.857A.857.857 0 0 0 19.143 4Zm-10 10H4.857a.857.857 0 0 0-.857.857v4.286c0 .473.384.857.857.857h4.286a.857.857 0 0 0 .857-.857v-4.286A.857.857 0 0 0 9.143 14Zm10 0h-4.286a.857.857 0 0 0-.857.857v4.286c0 .473.384.857.857.857h4.286a.857.857 0 0 0 .857-.857v-4.286a.857.857 0 0 0-.857-.857Z"></path></svg>`), GridOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function GridOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GridOutline);
  validate_prop_bindings($$props, [], [], GridOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "grid outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root322();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1322();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2322();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GridOutline = hmr(GridOutline, () => GridOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GridOutline[HMR].source;
    set(GridOutline[HMR].source, module.default[HMR].original);
  });
}
var GridOutline_default = GridOutline;
mark_module_end(GridOutline);

// node_modules/flowbite-svelte-icons/dist/GridPlusOutline.svelte
mark_module_start();
GridPlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GridPlusOutline.svelte";
var root_1323 = add_locations(ns_template(`<title> </title>`), GridPlusOutline[FILENAME], [[41, 4]]);
var root_2323 = add_locations(ns_template(`<desc> </desc>`), GridPlusOutline[FILENAME], [[44, 4]]);
var root323 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14 17h6m-3 3v-6M4.857 4h4.286c.473 0 .857.384.857.857v4.286a.857.857 0 0 1-.857.857H4.857A.857.857 0 0 1 4 9.143V4.857C4 4.384 4.384 4 4.857 4Zm10 0h4.286c.473 0 .857.384.857.857v4.286a.857.857 0 0 1-.857.857h-4.286A.857.857 0 0 1 14 9.143V4.857c0-.473.384-.857.857-.857Zm-10 10h4.286c.473 0 .857.384.857.857v4.286a.857.857 0 0 1-.857.857H4.857A.857.857 0 0 1 4 19.143v-4.286c0-.473.384-.857.857-.857Z"></path></svg>`), GridPlusOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function GridPlusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GridPlusOutline);
  validate_prop_bindings($$props, [], [], GridPlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "grid plus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root323();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1323();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2323();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GridPlusOutline = hmr(GridPlusOutline, () => GridPlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GridPlusOutline[HMR].source;
    set(GridPlusOutline[HMR].source, module.default[HMR].original);
  });
}
var GridPlusOutline_default = GridPlusOutline;
mark_module_end(GridPlusOutline);

// node_modules/flowbite-svelte-icons/dist/GridPlusSolid.svelte
mark_module_start();
GridPlusSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GridPlusSolid.svelte";
var root_1324 = add_locations(ns_template(`<title> </title>`), GridPlusSolid[FILENAME], [[39, 4]]);
var root_2324 = add_locations(ns_template(`<desc> </desc>`), GridPlusSolid[FILENAME], [[42, 4]]);
var root324 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4.857 3A1.857 1.857 0 0 0 3 4.857v4.286C3 10.169 3.831 11 4.857 11h4.286A1.857 1.857 0 0 0 11 9.143V4.857A1.857 1.857 0 0 0 9.143 3H4.857Zm10 0A1.857 1.857 0 0 0 13 4.857v4.286c0 1.026.831 1.857 1.857 1.857h4.286A1.857 1.857 0 0 0 21 9.143V4.857A1.857 1.857 0 0 0 19.143 3h-4.286Zm-10 10A1.857 1.857 0 0 0 3 14.857v4.286C3 20.169 3.831 21 4.857 21h4.286A1.857 1.857 0 0 0 11 19.143v-4.286A1.857 1.857 0 0 0 9.143 13H4.857ZM18 14a1 1 0 1 0-2 0v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2Z" clip-rule="evenodd"></path></svg>`), GridPlusSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function GridPlusSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GridPlusSolid);
  validate_prop_bindings($$props, [], [], GridPlusSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "grid plus solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root324();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1324();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2324();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GridPlusSolid = hmr(GridPlusSolid, () => GridPlusSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GridPlusSolid[HMR].source;
    set(GridPlusSolid[HMR].source, module.default[HMR].original);
  });
}
var GridPlusSolid_default = GridPlusSolid;
mark_module_end(GridPlusSolid);

// node_modules/flowbite-svelte-icons/dist/GridSolid.svelte
mark_module_start();
GridSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/GridSolid.svelte";
var root_1325 = add_locations(ns_template(`<title> </title>`), GridSolid[FILENAME], [[39, 4]]);
var root_2325 = add_locations(ns_template(`<desc> </desc>`), GridSolid[FILENAME], [[42, 4]]);
var root325 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4.857 3A1.857 1.857 0 0 0 3 4.857v4.286C3 10.169 3.831 11 4.857 11h4.286A1.857 1.857 0 0 0 11 9.143V4.857A1.857 1.857 0 0 0 9.143 3H4.857Zm10 0A1.857 1.857 0 0 0 13 4.857v4.286c0 1.026.831 1.857 1.857 1.857h4.286A1.857 1.857 0 0 0 21 9.143V4.857A1.857 1.857 0 0 0 19.143 3h-4.286Zm-10 10A1.857 1.857 0 0 0 3 14.857v4.286C3 20.169 3.831 21 4.857 21h4.286A1.857 1.857 0 0 0 11 19.143v-4.286A1.857 1.857 0 0 0 9.143 13H4.857Zm10 0A1.857 1.857 0 0 0 13 14.857v4.286c0 1.026.831 1.857 1.857 1.857h4.286A1.857 1.857 0 0 0 21 19.143v-4.286A1.857 1.857 0 0 0 19.143 13h-4.286Z" clip-rule="evenodd"></path></svg>`), GridSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function GridSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, GridSolid);
  validate_prop_bindings($$props, [], [], GridSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "grid solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root325();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1325();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2325();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  GridSolid = hmr(GridSolid, () => GridSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = GridSolid[HMR].source;
    set(GridSolid[HMR].source, module.default[HMR].original);
  });
}
var GridSolid_default = GridSolid;
mark_module_end(GridSolid);

// node_modules/flowbite-svelte-icons/dist/HammerOutline.svelte
mark_module_start();
HammerOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HammerOutline.svelte";
var root_1326 = add_locations(ns_template(`<title> </title>`), HammerOutline[FILENAME], [[41, 4]]);
var root_2326 = add_locations(ns_template(`<desc> </desc>`), HammerOutline[FILENAME], [[44, 4]]);
var root326 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="m20.9532 11.7634-2.0523-2.05225-2.0523 2.05225 2.0523 2.0523 2.0523-2.0523Zm-1.3681-2.73651-4.1046-4.10457L12.06 8.3428l4.1046 4.1046 3.4205-3.42051Zm-4.1047 2.73651-2.7363-2.73638-8.20919 8.20918 2.73639 2.7364 8.2091-8.2092Z"></path><path stroke="currentColor" stroke-linejoin="round" d="m12.9306 3.74083 1.8658 1.86571-2.0523 2.05229-1.5548-1.55476c-.995-.99505-3.23389-.49753-3.91799.18657l2.73639-2.73639c.6841-.68409 1.9901-.74628 2.9229.18658Z"></path></svg>`), HammerOutline[FILENAME], [
  [30, 0, [[46, 2], [52, 2]]]
]);
function HammerOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HammerOutline);
  validate_prop_bindings($$props, [], [], HammerOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "hammer outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root326();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1326();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2326();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HammerOutline = hmr(HammerOutline, () => HammerOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HammerOutline[HMR].source;
    set(HammerOutline[HMR].source, module.default[HMR].original);
  });
}
var HammerOutline_default = HammerOutline;
mark_module_end(HammerOutline);

// node_modules/flowbite-svelte-icons/dist/HammerSolid.svelte
mark_module_start();
HammerSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HammerSolid.svelte";
var root_1327 = add_locations(ns_template(`<title> </title>`), HammerSolid[FILENAME], [[39, 4]]);
var root_2327 = add_locations(ns_template(`<desc> </desc>`), HammerSolid[FILENAME], [[42, 4]]);
var root327 = add_locations(ns_template(`<svg><!><!><path d="M8.4 6.763c-.251.1-.383.196-.422.235L6.564 5.584l2.737-2.737c1.113-1.113 3.053-1.097 4.337.187l1.159 1.159a1 1 0 0 1 1.39.022l4.105 4.105a1 1 0 0 1 .023 1.39l1.345 1.346a1 1 0 0 1 0 1.415l-2.052 2.052a1 1 0 0 1-1.414 0l-1.346-1.346a1 1 0 0 1-1.323.039L11.29 8.983a1 1 0 0 1 .04-1.324l-.849-.848c-.18-.18-.606-.322-1.258-.25a3.271 3.271 0 0 0-.824.202Zm1.519 3.675L3.828 16.53a1 1 0 0 0 0 1.414l2.736 2.737a1 1 0 0 0 1.414 0l6.091-6.091-4.15-4.15Z"></path></svg>`), HammerSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function HammerSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HammerSolid);
  validate_prop_bindings($$props, [], [], HammerSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "hammer solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root327();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1327();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2327();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HammerSolid = hmr(HammerSolid, () => HammerSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HammerSolid[HMR].source;
    set(HammerSolid[HMR].source, module.default[HMR].original);
  });
}
var HammerSolid_default = HammerSolid;
mark_module_end(HammerSolid);

// node_modules/flowbite-svelte-icons/dist/HeadphonesOutline.svelte
mark_module_start();
HeadphonesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HeadphonesOutline.svelte";
var root_1328 = add_locations(ns_template(`<title> </title>`), HeadphonesOutline[FILENAME], [[41, 4]]);
var root_2328 = add_locations(ns_template(`<desc> </desc>`), HeadphonesOutline[FILENAME], [[44, 4]]);
var root328 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M20 16v-4a8 8 0 1 0-16 0v4m16 0v2a2 2 0 0 1-2 2h-2v-6h2a2 2 0 0 1 2 2ZM4 16v2a2 2 0 0 0 2 2h2v-6H6a2 2 0 0 0-2 2Z"></path></svg>`), HeadphonesOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function HeadphonesOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HeadphonesOutline);
  validate_prop_bindings($$props, [], [], HeadphonesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "headphones outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root328();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1328();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2328();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeadphonesOutline = hmr(HeadphonesOutline, () => HeadphonesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeadphonesOutline[HMR].source;
    set(HeadphonesOutline[HMR].source, module.default[HMR].original);
  });
}
var HeadphonesOutline_default = HeadphonesOutline;
mark_module_end(HeadphonesOutline);

// node_modules/flowbite-svelte-icons/dist/HeadphonesSolid.svelte
mark_module_start();
HeadphonesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HeadphonesSolid.svelte";
var root_1329 = add_locations(ns_template(`<title> </title>`), HeadphonesSolid[FILENAME], [[39, 4]]);
var root_2329 = add_locations(ns_template(`<desc> </desc>`), HeadphonesSolid[FILENAME], [[42, 4]]);
var root329 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 5a7 7 0 0 0-7 7v1.17c.313-.11.65-.17 1-.17h2a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H6a3 3 0 0 1-3-3v-6a9 9 0 0 1 18 0v6a3 3 0 0 1-3 3h-2a1 1 0 0 1-1-1v-6a1 1 0 0 1 1-1h2c.35 0 .687.06 1 .17V12a7 7 0 0 0-7-7Z" clip-rule="evenodd"></path></svg>`), HeadphonesSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function HeadphonesSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HeadphonesSolid);
  validate_prop_bindings($$props, [], [], HeadphonesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "headphones solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root329();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1329();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2329();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeadphonesSolid = hmr(HeadphonesSolid, () => HeadphonesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeadphonesSolid[HMR].source;
    set(HeadphonesSolid[HMR].source, module.default[HMR].original);
  });
}
var HeadphonesSolid_default = HeadphonesSolid;
mark_module_end(HeadphonesSolid);

// node_modules/flowbite-svelte-icons/dist/HeartOutline.svelte
mark_module_start();
HeartOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HeartOutline.svelte";
var root_1330 = add_locations(ns_template(`<title> </title>`), HeartOutline[FILENAME], [[41, 4]]);
var root_2330 = add_locations(ns_template(`<desc> </desc>`), HeartOutline[FILENAME], [[44, 4]]);
var root330 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12.01 6.001C6.5 1 1 8 5.782 13.001L12.011 20l6.23-7C23 8 17.5 1 12.01 6.002Z"></path></svg>`), HeartOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function HeartOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HeartOutline);
  validate_prop_bindings($$props, [], [], HeartOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "heart outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root330();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1330();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2330();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeartOutline = hmr(HeartOutline, () => HeartOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeartOutline[HMR].source;
    set(HeartOutline[HMR].source, module.default[HMR].original);
  });
}
var HeartOutline_default = HeartOutline;
mark_module_end(HeartOutline);

// node_modules/flowbite-svelte-icons/dist/HeartSolid.svelte
mark_module_start();
HeartSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HeartSolid.svelte";
var root_1331 = add_locations(ns_template(`<title> </title>`), HeartSolid[FILENAME], [[39, 4]]);
var root_2331 = add_locations(ns_template(`<desc> </desc>`), HeartSolid[FILENAME], [[42, 4]]);
var root331 = add_locations(ns_template(`<svg><!><!><path d="m12.75 20.66 6.184-7.098c2.677-2.884 2.559-6.506.754-8.705-.898-1.095-2.206-1.816-3.72-1.855-1.293-.034-2.652.43-3.963 1.442-1.315-1.012-2.678-1.476-3.973-1.442-1.515.04-2.825.76-3.724 1.855-1.806 2.201-1.915 5.823.772 8.706l6.183 7.097c.19.216.46.34.743.34a.985.985 0 0 0 .743-.34Z"></path></svg>`), HeartSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function HeartSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HeartSolid);
  validate_prop_bindings($$props, [], [], HeartSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "heart solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root331();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1331();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2331();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HeartSolid = hmr(HeartSolid, () => HeartSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HeartSolid[HMR].source;
    set(HeartSolid[HMR].source, module.default[HMR].original);
  });
}
var HeartSolid_default = HeartSolid;
mark_module_end(HeartSolid);

// node_modules/flowbite-svelte-icons/dist/HomeOutline.svelte
mark_module_start();
HomeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HomeOutline.svelte";
var root_1332 = add_locations(ns_template(`<title> </title>`), HomeOutline[FILENAME], [[41, 4]]);
var root_2332 = add_locations(ns_template(`<desc> </desc>`), HomeOutline[FILENAME], [[44, 4]]);
var root332 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m4 12 8-8 8 8M6 10.5V19a1 1 0 0 0 1 1h3v-3a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v3h3a1 1 0 0 0 1-1v-8.5"></path></svg>`), HomeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function HomeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HomeOutline);
  validate_prop_bindings($$props, [], [], HomeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "home outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root332();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1332();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2332();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HomeOutline = hmr(HomeOutline, () => HomeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HomeOutline[HMR].source;
    set(HomeOutline[HMR].source, module.default[HMR].original);
  });
}
var HomeOutline_default = HomeOutline;
mark_module_end(HomeOutline);

// node_modules/flowbite-svelte-icons/dist/HomeSolid.svelte
mark_module_start();
HomeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HomeSolid.svelte";
var root_1333 = add_locations(ns_template(`<title> </title>`), HomeSolid[FILENAME], [[39, 4]]);
var root_2333 = add_locations(ns_template(`<desc> </desc>`), HomeSolid[FILENAME], [[42, 4]]);
var root333 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M11.293 3.293a1 1 0 0 1 1.414 0l6 6 2 2a1 1 0 0 1-1.414 1.414L19 12.414V19a2 2 0 0 1-2 2h-3a1 1 0 0 1-1-1v-3h-2v3a1 1 0 0 1-1 1H7a2 2 0 0 1-2-2v-6.586l-.293.293a1 1 0 0 1-1.414-1.414l2-2 6-6Z" clip-rule="evenodd"></path></svg>`), HomeSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function HomeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HomeSolid);
  validate_prop_bindings($$props, [], [], HomeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "home solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root333();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1333();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2333();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HomeSolid = hmr(HomeSolid, () => HomeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HomeSolid[HMR].source;
    set(HomeSolid[HMR].source, module.default[HMR].original);
  });
}
var HomeSolid_default = HomeSolid;
mark_module_end(HomeSolid);

// node_modules/flowbite-svelte-icons/dist/HorizontalLinesOutline.svelte
mark_module_start();
HorizontalLinesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HorizontalLinesOutline.svelte";
var root_1334 = add_locations(ns_template(`<title> </title>`), HorizontalLinesOutline[FILENAME], [[41, 4]]);
var root_2334 = add_locations(ns_template(`<desc> </desc>`), HorizontalLinesOutline[FILENAME], [[44, 4]]);
var root334 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 12h14"></path><path stroke="currentColor" stroke-linecap="round" d="M6 9.5h12m-12-2h12m-12-2h12m-12 13h12m-12-2h12m-12-2h12"></path></svg>`), HorizontalLinesOutline[FILENAME], [
  [30, 0, [[46, 2], [47, 2]]]
]);
function HorizontalLinesOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HorizontalLinesOutline);
  validate_prop_bindings($$props, [], [], HorizontalLinesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "horizontal lines outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root334();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1334();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2334();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  next();
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HorizontalLinesOutline = hmr(HorizontalLinesOutline, () => HorizontalLinesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HorizontalLinesOutline[HMR].source;
    set(HorizontalLinesOutline[HMR].source, module.default[HMR].original);
  });
}
var HorizontalLinesOutline_default = HorizontalLinesOutline;
mark_module_end(HorizontalLinesOutline);

// node_modules/flowbite-svelte-icons/dist/HourglassOutline.svelte
mark_module_start();
HourglassOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HourglassOutline.svelte";
var root_1335 = add_locations(ns_template(`<title> </title>`), HourglassOutline[FILENAME], [[41, 4]]);
var root_2335 = add_locations(ns_template(`<desc> </desc>`), HourglassOutline[FILENAME], [[44, 4]]);
var root335 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.5 4h-13m13 16h-13M8 20v-3.333a2 2 0 0 1 .4-1.2L10 12.6a1 1 0 0 0 0-1.2L8.4 8.533a2 2 0 0 1-.4-1.2V4h8v3.333a2 2 0 0 1-.4 1.2L13.957 11.4a1 1 0 0 0 0 1.2l1.643 2.867a2 2 0 0 1 .4 1.2V20H8Z"></path></svg>`), HourglassOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function HourglassOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HourglassOutline);
  validate_prop_bindings($$props, [], [], HourglassOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "hourglass outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root335();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1335();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2335();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HourglassOutline = hmr(HourglassOutline, () => HourglassOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HourglassOutline[HMR].source;
    set(HourglassOutline[HMR].source, module.default[HMR].original);
  });
}
var HourglassOutline_default = HourglassOutline;
mark_module_end(HourglassOutline);

// node_modules/flowbite-svelte-icons/dist/HourglassSolid.svelte
mark_module_start();
HourglassSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HourglassSolid.svelte";
var root_1336 = add_locations(ns_template(`<title> </title>`), HourglassSolid[FILENAME], [[39, 4]]);
var root_2336 = add_locations(ns_template(`<desc> </desc>`), HourglassSolid[FILENAME], [[42, 4]]);
var root336 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5.5 3a1 1 0 0 0 0 2H7v2.333a3 3 0 0 0 .556 1.74l1.57 2.814A1.1 1.1 0 0 0 9.2 12a.998.998 0 0 0-.073.113l-1.57 2.814A3 3 0 0 0 7 16.667V19H5.5a1 1 0 1 0 0 2h13a1 1 0 1 0 0-2H17v-2.333a3 3 0 0 0-.56-1.745l-1.616-2.82a1 1 0 0 0-.067-.102 1 1 0 0 0 .067-.103l1.616-2.819A3 3 0 0 0 17 7.333V5h1.5a1 1 0 1 0 0-2h-13Z" clip-rule="evenodd"></path></svg>`), HourglassSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function HourglassSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HourglassSolid);
  validate_prop_bindings($$props, [], [], HourglassSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "hourglass solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root336();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1336();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2336();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HourglassSolid = hmr(HourglassSolid, () => HourglassSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HourglassSolid[HMR].source;
    set(HourglassSolid[HMR].source, module.default[HMR].original);
  });
}
var HourglassSolid_default = HourglassSolid;
mark_module_end(HourglassSolid);

// node_modules/flowbite-svelte-icons/dist/HtmlSolid.svelte
mark_module_start();
HtmlSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/HtmlSolid.svelte";
var root_1337 = add_locations(ns_template(`<title> </title>`), HtmlSolid[FILENAME], [[39, 4]]);
var root_2337 = add_locations(ns_template(`<desc> </desc>`), HtmlSolid[FILENAME], [[42, 4]]);
var root337 = add_locations(ns_template(`<svg><!><!><path d="m3 2 1.578 17.824L12 22l7.467-2.175L21 2H3Zm14.049 6.048H9.075l.172 2.016h7.697l-.626 6.565-4.246 1.381-4.281-1.455-.288-2.932h2.024l.16 1.411 2.4.815 2.346-.763.297-3.005H7.416l-.562-6.05h10.412l-.217 2.017Z"></path></svg>`), HtmlSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function HtmlSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, HtmlSolid);
  validate_prop_bindings($$props, [], [], HtmlSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "html solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root337();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1337();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2337();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  HtmlSolid = hmr(HtmlSolid, () => HtmlSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HtmlSolid[HMR].source;
    set(HtmlSolid[HMR].source, module.default[HMR].original);
  });
}
var HtmlSolid_default = HtmlSolid;
mark_module_end(HtmlSolid);

// node_modules/flowbite-svelte-icons/dist/IconOutline.svelte
mark_module_start();
IconOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IconOutline.svelte";
function IconOutline($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, IconOutline);
  validate_prop_bindings($$props, [], [], IconOutline);
  let color = prop($$props, "color", 3, "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "Icon",
      "size",
      "role",
      "color",
      "ariaLabel",
      "class"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => $$props.Icon, ($$anchor2, $$component) => {
    $$component($$anchor2, spread_props(
      {
        fill: "none",
        get color() {
          return color();
        }
      },
      () => restProps,
      {
        get role() {
          return $$props.role;
        },
        get size() {
          return $$props.size;
        },
        get class() {
          return $$props.class;
        },
        get ariaLabel() {
          return $$props.ariaLabel;
        }
      }
    ));
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  IconOutline = hmr(IconOutline, () => IconOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IconOutline[HMR].source;
    set(IconOutline[HMR].source, module.default[HMR].original);
  });
}
var IconOutline_default = IconOutline;
mark_module_end(IconOutline);

// node_modules/flowbite-svelte-icons/dist/IconSolid.svelte
mark_module_start();
IconSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IconSolid.svelte";
function IconSolid($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, IconSolid);
  validate_prop_bindings($$props, [], [], IconSolid);
  let color = prop($$props, "color", 3, "currentColor"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "Icon",
      "size",
      "role",
      "color",
      "ariaLabel",
      "strokeWidth",
      "class"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  component(node, () => $$props.Icon, ($$anchor2, $$component) => {
    $$component($$anchor2, spread_props(
      {
        get fill() {
          return color();
        }
      },
      () => restProps,
      {
        get role() {
          return $$props.role;
        },
        get size() {
          return $$props.size;
        },
        get strokeWidth() {
          return $$props.strokeWidth;
        },
        get class() {
          return $$props.class;
        },
        get ariaLabel() {
          return $$props.ariaLabel;
        }
      }
    ));
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  IconSolid = hmr(IconSolid, () => IconSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IconSolid[HMR].source;
    set(IconSolid[HMR].source, module.default[HMR].original);
  });
}
var IconSolid_default = IconSolid;
mark_module_end(IconSolid);

// node_modules/flowbite-svelte-icons/dist/ImageOutline.svelte
mark_module_start();
ImageOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ImageOutline.svelte";
var root_1338 = add_locations(ns_template(`<title> </title>`), ImageOutline[FILENAME], [[41, 4]]);
var root_2338 = add_locations(ns_template(`<desc> </desc>`), ImageOutline[FILENAME], [[44, 4]]);
var root338 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m3 16 5-7 6 6.5m6.5 2.5L16 13l-4.286 6M14 10h.01M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), ImageOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ImageOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ImageOutline);
  validate_prop_bindings($$props, [], [], ImageOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "image outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root338();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1338();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2338();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ImageOutline = hmr(ImageOutline, () => ImageOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ImageOutline[HMR].source;
    set(ImageOutline[HMR].source, module.default[HMR].original);
  });
}
var ImageOutline_default = ImageOutline;
mark_module_end(ImageOutline);

// node_modules/flowbite-svelte-icons/dist/ImageSolid.svelte
mark_module_start();
ImageSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ImageSolid.svelte";
var root_1339 = add_locations(ns_template(`<title> </title>`), ImageSolid[FILENAME], [[39, 4]]);
var root_2339 = add_locations(ns_template(`<desc> </desc>`), ImageSolid[FILENAME], [[42, 4]]);
var root339 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M13 10a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H14a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12c0 .556-.227 1.06-.593 1.422A.999.999 0 0 1 20.5 20H4a2.002 2.002 0 0 1-2-2V6Zm6.892 12 3.833-5.356-3.99-4.322a1 1 0 0 0-1.549.097L4 12.879V6h16v9.95l-3.257-3.619a1 1 0 0 0-1.557.088L11.2 18H8.892Z" clip-rule="evenodd"></path></svg>`), ImageSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function ImageSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ImageSolid);
  validate_prop_bindings($$props, [], [], ImageSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "image solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root339();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1339();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2339();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ImageSolid = hmr(ImageSolid, () => ImageSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ImageSolid[HMR].source;
    set(ImageSolid[HMR].source, module.default[HMR].original);
  });
}
var ImageSolid_default = ImageSolid;
mark_module_end(ImageSolid);

// node_modules/flowbite-svelte-icons/dist/InboxFullOutline.svelte
mark_module_start();
InboxFullOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InboxFullOutline.svelte";
var root_1340 = add_locations(ns_template(`<title> </title>`), InboxFullOutline[FILENAME], [[41, 4]]);
var root_2340 = add_locations(ns_template(`<desc> </desc>`), InboxFullOutline[FILENAME], [[44, 4]]);
var root340 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 13h3.439a.991.991 0 0 1 .908.6 3.978 3.978 0 0 0 7.306 0 .99.99 0 0 1 .908-.6H20M4 13v6a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-6M4 13l2-9h12l2 9M9 7h6m-7 3h8"></path></svg>`), InboxFullOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function InboxFullOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InboxFullOutline);
  validate_prop_bindings($$props, [], [], InboxFullOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "inbox full outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root340();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1340();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2340();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InboxFullOutline = hmr(InboxFullOutline, () => InboxFullOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InboxFullOutline[HMR].source;
    set(InboxFullOutline[HMR].source, module.default[HMR].original);
  });
}
var InboxFullOutline_default = InboxFullOutline;
mark_module_end(InboxFullOutline);

// node_modules/flowbite-svelte-icons/dist/InboxFullSolid.svelte
mark_module_start();
InboxFullSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InboxFullSolid.svelte";
var root_1341 = add_locations(ns_template(`<title> </title>`), InboxFullSolid[FILENAME], [[39, 4]]);
var root_2341 = add_locations(ns_template(`<desc> </desc>`), InboxFullSolid[FILENAME], [[42, 4]]);
var root341 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5.024 3.783A1 1 0 0 1 6 3h12a1 1 0 0 1 .976.783L20.802 12h-4.244a1.99 1.99 0 0 0-1.824 1.205 2.978 2.978 0 0 1-5.468 0A1.991 1.991 0 0 0 7.442 12H3.198l1.826-8.217ZM3 14v5a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-5h-4.43a4.978 4.978 0 0 1-9.14 0H3Zm5-7a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1Zm0 2a1 1 0 0 0 0 2h8a1 1 0 1 0 0-2H8Z" clip-rule="evenodd"></path></svg>`), InboxFullSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function InboxFullSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InboxFullSolid);
  validate_prop_bindings($$props, [], [], InboxFullSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "inbox full solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root341();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1341();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2341();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InboxFullSolid = hmr(InboxFullSolid, () => InboxFullSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InboxFullSolid[HMR].source;
    set(InboxFullSolid[HMR].source, module.default[HMR].original);
  });
}
var InboxFullSolid_default = InboxFullSolid;
mark_module_end(InboxFullSolid);

// node_modules/flowbite-svelte-icons/dist/InboxOutline.svelte
mark_module_start();
InboxOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InboxOutline.svelte";
var root_1342 = add_locations(ns_template(`<title> </title>`), InboxOutline[FILENAME], [[41, 4]]);
var root_2342 = add_locations(ns_template(`<desc> </desc>`), InboxOutline[FILENAME], [[44, 4]]);
var root342 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 13h3.439a.991.991 0 0 1 .908.6 3.978 3.978 0 0 0 7.306 0 .99.99 0 0 1 .908-.6H20M4 13v6a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-6M4 13l2-9h12l2 9"></path></svg>`), InboxOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function InboxOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InboxOutline);
  validate_prop_bindings($$props, [], [], InboxOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "inbox outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root342();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1342();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2342();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InboxOutline = hmr(InboxOutline, () => InboxOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InboxOutline[HMR].source;
    set(InboxOutline[HMR].source, module.default[HMR].original);
  });
}
var InboxOutline_default = InboxOutline;
mark_module_end(InboxOutline);

// node_modules/flowbite-svelte-icons/dist/InboxSolid.svelte
mark_module_start();
InboxSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InboxSolid.svelte";
var root_1343 = add_locations(ns_template(`<title> </title>`), InboxSolid[FILENAME], [[39, 4]]);
var root_2343 = add_locations(ns_template(`<desc> </desc>`), InboxSolid[FILENAME], [[42, 4]]);
var root343 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5.024 3.783A1 1 0 0 1 6 3h12a1 1 0 0 1 .976.783L20.802 12h-4.244a1.99 1.99 0 0 0-1.824 1.205 2.978 2.978 0 0 1-5.468 0A1.991 1.991 0 0 0 7.442 12H3.198l1.826-8.217ZM3 14v5a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-5h-4.43a4.978 4.978 0 0 1-9.14 0H3Z" clip-rule="evenodd"></path></svg>`), InboxSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function InboxSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InboxSolid);
  validate_prop_bindings($$props, [], [], InboxSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "inbox solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root343();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1343();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2343();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InboxSolid = hmr(InboxSolid, () => InboxSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InboxSolid[HMR].source;
    set(InboxSolid[HMR].source, module.default[HMR].original);
  });
}
var InboxSolid_default = InboxSolid;
mark_module_end(InboxSolid);

// node_modules/flowbite-svelte-icons/dist/IndentOutline.svelte
mark_module_start();
IndentOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IndentOutline.svelte";
var root_1344 = add_locations(ns_template(`<title> </title>`), IndentOutline[FILENAME], [[41, 4]]);
var root_2344 = add_locations(ns_template(`<desc> </desc>`), IndentOutline[FILENAME], [[44, 4]]);
var root344 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 6h12M6 18h12m-5-8h5m-5 4h5M6 9v6l3.5-3L6 9Z"></path></svg>`), IndentOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function IndentOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, IndentOutline);
  validate_prop_bindings($$props, [], [], IndentOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "indent outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root344();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1344();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2344();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  IndentOutline = hmr(IndentOutline, () => IndentOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IndentOutline[HMR].source;
    set(IndentOutline[HMR].source, module.default[HMR].original);
  });
}
var IndentOutline_default = IndentOutline;
mark_module_end(IndentOutline);

// node_modules/flowbite-svelte-icons/dist/IndentSolid.svelte
mark_module_start();
IndentSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/IndentSolid.svelte";
var root_1345 = add_locations(ns_template(`<title> </title>`), IndentSolid[FILENAME], [[39, 4]]);
var root_2345 = add_locations(ns_template(`<desc> </desc>`), IndentSolid[FILENAME], [[42, 4]]);
var root345 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 6a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm0 12a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm1.65-9.76A1 1 0 0 0 5 9v6a1 1 0 0 0 1.65.76l3.5-3a1 1 0 0 0 0-1.52l-3.5-3ZM12 10a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Zm0 4a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), IndentSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function IndentSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, IndentSolid);
  validate_prop_bindings($$props, [], [], IndentSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "indent solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root345();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1345();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2345();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  IndentSolid = hmr(IndentSolid, () => IndentSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = IndentSolid[HMR].source;
    set(IndentSolid[HMR].source, module.default[HMR].original);
  });
}
var IndentSolid_default = IndentSolid;
mark_module_end(IndentSolid);

// node_modules/flowbite-svelte-icons/dist/InfoCircleOutline.svelte
mark_module_start();
InfoCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InfoCircleOutline.svelte";
var root_1346 = add_locations(ns_template(`<title> </title>`), InfoCircleOutline[FILENAME], [[41, 4]]);
var root_2346 = add_locations(ns_template(`<desc> </desc>`), InfoCircleOutline[FILENAME], [[44, 4]]);
var root346 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 11h2v5m-2 0h4m-2.592-8.5h.01M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), InfoCircleOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function InfoCircleOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InfoCircleOutline);
  validate_prop_bindings($$props, [], [], InfoCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "info circle outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root346();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1346();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2346();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InfoCircleOutline = hmr(InfoCircleOutline, () => InfoCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InfoCircleOutline[HMR].source;
    set(InfoCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var InfoCircleOutline_default = InfoCircleOutline;
mark_module_end(InfoCircleOutline);

// node_modules/flowbite-svelte-icons/dist/InfoCircleSolid.svelte
mark_module_start();
InfoCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InfoCircleSolid.svelte";
var root_1347 = add_locations(ns_template(`<title> </title>`), InfoCircleSolid[FILENAME], [[39, 4]]);
var root_2347 = add_locations(ns_template(`<desc> </desc>`), InfoCircleSolid[FILENAME], [[42, 4]]);
var root347 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm9.408-5.5a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM10 10a1 1 0 1 0 0 2h1v3h-1a1 1 0 1 0 0 2h4a1 1 0 1 0 0-2h-1v-4a1 1 0 0 0-1-1h-2Z" clip-rule="evenodd"></path></svg>`), InfoCircleSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function InfoCircleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InfoCircleSolid);
  validate_prop_bindings($$props, [], [], InfoCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "info circle solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root347();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1347();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2347();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InfoCircleSolid = hmr(InfoCircleSolid, () => InfoCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InfoCircleSolid[HMR].source;
    set(InfoCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var InfoCircleSolid_default = InfoCircleSolid;
mark_module_end(InfoCircleSolid);

// node_modules/flowbite-svelte-icons/dist/InsertRowAfterOutline.svelte
mark_module_start();
InsertRowAfterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InsertRowAfterOutline.svelte";
var root_1348 = add_locations(ns_template(`<title> </title>`), InsertRowAfterOutline[FILENAME], [[41, 4]]);
var root_2348 = add_locations(ns_template(`<desc> </desc>`), InsertRowAfterOutline[FILENAME], [[44, 4]]);
var root348 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 9V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44771 1 1v3M3 9v9c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1V9M3 9h18M8 9V5m4 4V5m4 4V5m-6 9h2m0 0h2m-2 0v-2m0 2v2"></path></svg>`), InsertRowAfterOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function InsertRowAfterOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InsertRowAfterOutline);
  validate_prop_bindings($$props, [], [], InsertRowAfterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "insert row after outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root348();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1348();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2348();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InsertRowAfterOutline = hmr(InsertRowAfterOutline, () => InsertRowAfterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InsertRowAfterOutline[HMR].source;
    set(InsertRowAfterOutline[HMR].source, module.default[HMR].original);
  });
}
var InsertRowAfterOutline_default = InsertRowAfterOutline;
mark_module_end(InsertRowAfterOutline);

// node_modules/flowbite-svelte-icons/dist/InsertRowBeforeOutline.svelte
mark_module_start();
InsertRowBeforeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InsertRowBeforeOutline.svelte";
var root_1349 = add_locations(ns_template(`<title> </title>`), InsertRowBeforeOutline[FILENAME], [[41, 4]]);
var root_2349 = add_locations(ns_template(`<desc> </desc>`), InsertRowBeforeOutline[FILENAME], [[44, 4]]);
var root349 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1v-3M3 15V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v9M3 15h18M8 15v4m4-4v4m4-4v4m-6-9h2m0 0h2m-2 0v2m0-2V8"></path></svg>`), InsertRowBeforeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function InsertRowBeforeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InsertRowBeforeOutline);
  validate_prop_bindings($$props, [], [], InsertRowBeforeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "insert row before outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root349();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1349();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2349();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InsertRowBeforeOutline = hmr(InsertRowBeforeOutline, () => InsertRowBeforeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InsertRowBeforeOutline[HMR].source;
    set(InsertRowBeforeOutline[HMR].source, module.default[HMR].original);
  });
}
var InsertRowBeforeOutline_default = InsertRowBeforeOutline;
mark_module_end(InsertRowBeforeOutline);

// node_modules/flowbite-svelte-icons/dist/InsertTableAltOutline.svelte
mark_module_start();
InsertTableAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InsertTableAltOutline.svelte";
var root_1350 = add_locations(ns_template(`<title> </title>`), InsertTableAltOutline[FILENAME], [[41, 4]]);
var root_2350 = add_locations(ns_template(`<desc> </desc>`), InsertTableAltOutline[FILENAME], [[44, 4]]);
var root350 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h10.5M3 15v-4m0 4h11M3 11V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v5M3 11h18m0 0v1M8 11v8m4-8v8m4-8v2m1 4h2m0 0h2m-2 0v2m0-2v-2"></path></svg>`), InsertTableAltOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function InsertTableAltOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InsertTableAltOutline);
  validate_prop_bindings($$props, [], [], InsertTableAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "insert table alt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root350();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1350();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2350();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InsertTableAltOutline = hmr(InsertTableAltOutline, () => InsertTableAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InsertTableAltOutline[HMR].source;
    set(InsertTableAltOutline[HMR].source, module.default[HMR].original);
  });
}
var InsertTableAltOutline_default = InsertTableAltOutline;
mark_module_end(InsertTableAltOutline);

// node_modules/flowbite-svelte-icons/dist/InsertTableOutline.svelte
mark_module_start();
InsertTableOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InsertTableOutline.svelte";
var root_1351 = add_locations(ns_template(`<title> </title>`), InsertTableOutline[FILENAME], [[41, 4]]);
var root_2351 = add_locations(ns_template(`<desc> </desc>`), InsertTableOutline[FILENAME], [[44, 4]]);
var root351 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" d="M3 11h18M3 15h18M8 10.792V19m4-8.208V19m4-8.208V19M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), InsertTableOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function InsertTableOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InsertTableOutline);
  validate_prop_bindings($$props, [], [], InsertTableOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "insert table outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root351();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1351();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2351();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InsertTableOutline = hmr(InsertTableOutline, () => InsertTableOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InsertTableOutline[HMR].source;
    set(InsertTableOutline[HMR].source, module.default[HMR].original);
  });
}
var InsertTableOutline_default = InsertTableOutline;
mark_module_end(InsertTableOutline);

// node_modules/flowbite-svelte-icons/dist/InstagramSolid.svelte
mark_module_start();
InstagramSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/InstagramSolid.svelte";
var root_1352 = add_locations(ns_template(`<title> </title>`), InstagramSolid[FILENAME], [[39, 4]]);
var root_2352 = add_locations(ns_template(`<desc> </desc>`), InstagramSolid[FILENAME], [[42, 4]]);
var root352 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" fill-rule="evenodd" d="M3 8a5 5 0 0 1 5-5h8a5 5 0 0 1 5 5v8a5 5 0 0 1-5 5H8a5 5 0 0 1-5-5V8Zm5-3a3 3 0 0 0-3 3v8a3 3 0 0 0 3 3h8a3 3 0 0 0 3-3V8a3 3 0 0 0-3-3H8Zm7.597 2.214a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2h-.01a1 1 0 0 1-1-1ZM12 9a3 3 0 1 0 0 6 3 3 0 0 0 0-6Zm-5 3a5 5 0 1 1 10 0 5 5 0 0 1-10 0Z" clip-rule="evenodd"></path></svg>`), InstagramSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function InstagramSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, InstagramSolid);
  validate_prop_bindings($$props, [], [], InstagramSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "instagram solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root352();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1352();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2352();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  InstagramSolid = hmr(InstagramSolid, () => InstagramSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = InstagramSolid[HMR].source;
    set(InstagramSolid[HMR].source, module.default[HMR].original);
  });
}
var InstagramSolid_default = InstagramSolid;
mark_module_end(InstagramSolid);

// node_modules/flowbite-svelte-icons/dist/KeyboardOutline.svelte
mark_module_start();
KeyboardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/KeyboardOutline.svelte";
var root_1353 = add_locations(ns_template(`<title> </title>`), KeyboardOutline[FILENAME], [[41, 4]]);
var root_2353 = add_locations(ns_template(`<desc> </desc>`), KeyboardOutline[FILENAME], [[44, 4]]);
var root353 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="square" d="M8 15h7.01v.01H15L8 15Z"></path><path stroke="currentColor" stroke-linecap="square" d="M20 6H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Z"></path><path stroke="currentColor" stroke-linecap="square" d="M6 9h.01v.01H6V9Zm0 3h.01v.01H6V12Zm0 3h.01v.01H6V15Zm3-6h.01v.01H9V9Zm0 3h.01v.01H9V12Zm3-3h.01v.01H12V9Zm0 3h.01v.01H12V12Zm3 0h.01v.01H15V12Zm3 0h.01v.01H18V12Zm0 3h.01v.01H18V15Zm-3-6h.01v.01H15V9Zm3 0h.01v.01H18V9Z"></path></svg>`), KeyboardOutline[FILENAME], [
  [
    30,
    0,
    [[46, 2], [52, 2], [58, 2]]
  ]
]);
function KeyboardOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, KeyboardOutline);
  validate_prop_bindings($$props, [], [], KeyboardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "keyboard outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root353();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1353();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2353();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  var path_2 = sibling(path_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
    set_attribute(path_2, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  KeyboardOutline = hmr(KeyboardOutline, () => KeyboardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = KeyboardOutline[HMR].source;
    set(KeyboardOutline[HMR].source, module.default[HMR].original);
  });
}
var KeyboardOutline_default = KeyboardOutline;
mark_module_end(KeyboardOutline);

// node_modules/flowbite-svelte-icons/dist/KeyboardSolid.svelte
mark_module_start();
KeyboardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/KeyboardSolid.svelte";
var root_1354 = add_locations(ns_template(`<title> </title>`), KeyboardSolid[FILENAME], [[39, 4]]);
var root_2354 = add_locations(ns_template(`<desc> </desc>`), KeyboardSolid[FILENAME], [[42, 4]]);
var root354 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 7a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V7Zm5.01 1H5v2.01h2.01V8Zm3 0H8v2.01h2.01V8Zm3 0H11v2.01h2.01V8Zm3 0H14v2.01h2.01V8Zm3 0H17v2.01h2.01V8Zm-12 3H5v2.01h2.01V11Zm3 0H8v2.01h2.01V11Zm3 0H11v2.01h2.01V11Zm3 0H14v2.01h2.01V11Zm3 0H17v2.01h2.01V11Zm-12 3H5v2.01h2.01V14ZM8 14l-.001 2 8.011.01V14H8Zm11.01 0H17v2.01h2.01V14Z" clip-rule="evenodd"></path></svg>`), KeyboardSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function KeyboardSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, KeyboardSolid);
  validate_prop_bindings($$props, [], [], KeyboardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "keyboard solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root354();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1354();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2354();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  KeyboardSolid = hmr(KeyboardSolid, () => KeyboardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = KeyboardSolid[HMR].source;
    set(KeyboardSolid[HMR].source, module.default[HMR].original);
  });
}
var KeyboardSolid_default = KeyboardSolid;
mark_module_end(KeyboardSolid);

// node_modules/flowbite-svelte-icons/dist/LabelOutline.svelte
mark_module_start();
LabelOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LabelOutline.svelte";
var root_1355 = add_locations(ns_template(`<title> </title>`), LabelOutline[FILENAME], [[41, 4]]);
var root_2355 = add_locations(ns_template(`<desc> </desc>`), LabelOutline[FILENAME], [[44, 4]]);
var root355 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.2 6H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h11.2a1 1 0 0 0 .747-.334l4.46-5a1 1 0 0 0 0-1.332l-4.46-5A1 1 0 0 0 15.2 6Z"></path></svg>`), LabelOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LabelOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LabelOutline);
  validate_prop_bindings($$props, [], [], LabelOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "label outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root355();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1355();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2355();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LabelOutline = hmr(LabelOutline, () => LabelOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LabelOutline[HMR].source;
    set(LabelOutline[HMR].source, module.default[HMR].original);
  });
}
var LabelOutline_default = LabelOutline;
mark_module_end(LabelOutline);

// node_modules/flowbite-svelte-icons/dist/LabelSolid.svelte
mark_module_start();
LabelSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LabelSolid.svelte";
var root_1356 = add_locations(ns_template(`<title> </title>`), LabelSolid[FILENAME], [[39, 4]]);
var root_2356 = add_locations(ns_template(`<desc> </desc>`), LabelSolid[FILENAME], [[42, 4]]);
var root356 = add_locations(ns_template(`<svg><!><!><path d="M4 6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11.613a2 2 0 0 0 1.346-.52l4.4-4a2 2 0 0 0 0-2.96l-4.4-4A2 2 0 0 0 15.613 6H4Z"></path></svg>`), LabelSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function LabelSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LabelSolid);
  validate_prop_bindings($$props, [], [], LabelSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "label solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root356();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1356();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2356();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LabelSolid = hmr(LabelSolid, () => LabelSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LabelSolid[HMR].source;
    set(LabelSolid[HMR].source, module.default[HMR].original);
  });
}
var LabelSolid_default = LabelSolid;
mark_module_end(LabelSolid);

// node_modules/flowbite-svelte-icons/dist/LandmarkOutline.svelte
mark_module_start();
LandmarkOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LandmarkOutline.svelte";
var root_1357 = add_locations(ns_template(`<title> </title>`), LandmarkOutline[FILENAME], [[41, 4]]);
var root_2357 = add_locations(ns_template(`<desc> </desc>`), LandmarkOutline[FILENAME], [[44, 4]]);
var root357 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M3 21h18M4 18h16M6 10v8m4-8v8m4-8v8m4-8v8M4 9.5v-.955a1 1 0 0 1 .458-.84l7-4.52a1 1 0 0 1 1.084 0l7 4.52a1 1 0 0 1 .458.84V9.5a.5.5 0 0 1-.5.5h-15a.5.5 0 0 1-.5-.5Z"></path></svg>`), LandmarkOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LandmarkOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LandmarkOutline);
  validate_prop_bindings($$props, [], [], LandmarkOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "landmark outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root357();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1357();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2357();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LandmarkOutline = hmr(LandmarkOutline, () => LandmarkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LandmarkOutline[HMR].source;
    set(LandmarkOutline[HMR].source, module.default[HMR].original);
  });
}
var LandmarkOutline_default = LandmarkOutline;
mark_module_end(LandmarkOutline);

// node_modules/flowbite-svelte-icons/dist/LandmarkSolid.svelte
mark_module_start();
LandmarkSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LandmarkSolid.svelte";
var root_1358 = add_locations(ns_template(`<title> </title>`), LandmarkSolid[FILENAME], [[39, 4]]);
var root_2358 = add_locations(ns_template(`<desc> </desc>`), LandmarkSolid[FILENAME], [[42, 4]]);
var root358 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M10.915 2.345a2 2 0 0 1 2.17 0l7 4.52A2 2 0 0 1 21 8.544V9.5a1.5 1.5 0 0 1-1.5 1.5H19v6h1a1 1 0 1 1 0 2H4a1 1 0 1 1 0-2h1v-6h-.5A1.5 1.5 0 0 1 3 9.5v-.955a2 2 0 0 1 .915-1.68l7-4.52ZM17 17v-6h-2v6h2Zm-6-6h2v6h-2v-6Zm-2 6v-6H7v6h2Z" clip-rule="evenodd"></path><path d="M2 21a1 1 0 0 1 1-1h18a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1Z"></path></svg>`), LandmarkSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 5]]]
]);
function LandmarkSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LandmarkSolid);
  validate_prop_bindings($$props, [], [], LandmarkSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "landmark solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root358();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1358();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2358();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LandmarkSolid = hmr(LandmarkSolid, () => LandmarkSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LandmarkSolid[HMR].source;
    set(LandmarkSolid[HMR].source, module.default[HMR].original);
  });
}
var LandmarkSolid_default = LandmarkSolid;
mark_module_end(LandmarkSolid);

// node_modules/flowbite-svelte-icons/dist/LanguageOutline.svelte
mark_module_start();
LanguageOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LanguageOutline.svelte";
var root_1359 = add_locations(ns_template(`<title> </title>`), LanguageOutline[FILENAME], [[41, 4]]);
var root_2359 = add_locations(ns_template(`<desc> </desc>`), LanguageOutline[FILENAME], [[44, 4]]);
var root359 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m13 19 3.5-9 3.5 9m-6.125-2h5.25M3 7h7m0 0h2m-2 0c0 1.63-.793 3.926-2.239 5.655M7.5 6.818V5m.261 7.655C6.79 13.82 5.521 14.725 4 15m3.761-2.345L5 10m2.761 2.655L10.2 15"></path></svg>`), LanguageOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LanguageOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LanguageOutline);
  validate_prop_bindings($$props, [], [], LanguageOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "language outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root359();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1359();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2359();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LanguageOutline = hmr(LanguageOutline, () => LanguageOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LanguageOutline[HMR].source;
    set(LanguageOutline[HMR].source, module.default[HMR].original);
  });
}
var LanguageOutline_default = LanguageOutline;
mark_module_end(LanguageOutline);

// node_modules/flowbite-svelte-icons/dist/LaravelSolid.svelte
mark_module_start();
LaravelSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LaravelSolid.svelte";
var root_1360 = add_locations(ns_template(`<title> </title>`), LaravelSolid[FILENAME], [[39, 4]]);
var root_2360 = add_locations(ns_template(`<desc> </desc>`), LaravelSolid[FILENAME], [[42, 4]]);
var root360 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="m17 13 3.4641-2V7L17 5l-3.4641 2v4M17 13l-3.4641-2M17 13v4l-7.00001 4M17 13V9m0 4-7.00001 4m3.53591-6L10.5 12.7348M9.99999 21l-3.4641-2.1318M9.99999 21v-4m-3.4641 2v-.1318m0 0V15L10.5 12.7348m-3.96411 6.1334L3.5 17V5m0 0L7 3l3.5 2m-7 0 2.99999 2M10.5 5v7.7348M10.5 5 6.49999 7M17 9l3.5-2M17 9l-3.5-2M9.99999 17l-3.5-2m0 .5V7"></path></svg>`), LaravelSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function LaravelSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LaravelSolid);
  validate_prop_bindings($$props, [], [], LaravelSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "laravel solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root360();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1360();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2360();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LaravelSolid = hmr(LaravelSolid, () => LaravelSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LaravelSolid[HMR].source;
    set(LaravelSolid[HMR].source, module.default[HMR].original);
  });
}
var LaravelSolid_default = LaravelSolid;
mark_module_end(LaravelSolid);

// node_modules/flowbite-svelte-icons/dist/LayersOutline.svelte
mark_module_start();
LayersOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LayersOutline.svelte";
var root_1361 = add_locations(ns_template(`<title> </title>`), LayersOutline[FILENAME], [[41, 4]]);
var root_2361 = add_locations(ns_template(`<desc> </desc>`), LayersOutline[FILENAME], [[44, 4]]);
var root361 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5.005 11.19V12l6.998 4.042L19 12v-.81M5 16.15v.81L11.997 21l6.998-4.042v-.81M12.003 3 5.005 7.042l6.998 4.042L19 7.042 12.003 3Z"></path></svg>`), LayersOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LayersOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LayersOutline);
  validate_prop_bindings($$props, [], [], LayersOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "layers outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root361();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1361();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2361();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LayersOutline = hmr(LayersOutline, () => LayersOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LayersOutline[HMR].source;
    set(LayersOutline[HMR].source, module.default[HMR].original);
  });
}
var LayersOutline_default = LayersOutline;
mark_module_end(LayersOutline);

// node_modules/flowbite-svelte-icons/dist/LayersSolid.svelte
mark_module_start();
LayersSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LayersSolid.svelte";
var root_1362 = add_locations(ns_template(`<title> </title>`), LayersSolid[FILENAME], [[39, 4]]);
var root_2362 = add_locations(ns_template(`<desc> </desc>`), LayersSolid[FILENAME], [[42, 4]]);
var root362 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5.005 10.19a1 1 0 0 1 1 1v.233l5.998 3.464L18 11.423v-.232a1 1 0 1 1 2 0V12a1 1 0 0 1-.5.866l-6.997 4.042a1 1 0 0 1-1 0l-6.998-4.042a1 1 0 0 1-.5-.866v-.81a1 1 0 0 1 1-1ZM5 15.15a1 1 0 0 1 1 1v.232l5.997 3.464 5.998-3.464v-.232a1 1 0 1 1 2 0v.81a1 1 0 0 1-.5.865l-6.998 4.042a1 1 0 0 1-1 0L4.5 17.824a1 1 0 0 1-.5-.866v-.81a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path><path d="M12.503 2.134a1 1 0 0 0-1 0L4.501 6.17A1 1 0 0 0 4.5 7.902l7.002 4.047a1 1 0 0 0 1 0l6.998-4.04a1 1 0 0 0 0-1.732l-6.997-4.042Z"></path></svg>`), LayersSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function LayersSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LayersSolid);
  validate_prop_bindings($$props, [], [], LayersSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "layers solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root362();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1362();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2362();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LayersSolid = hmr(LayersSolid, () => LayersSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LayersSolid[HMR].source;
    set(LayersSolid[HMR].source, module.default[HMR].original);
  });
}
var LayersSolid_default = LayersSolid;
mark_module_end(LayersSolid);

// node_modules/flowbite-svelte-icons/dist/LetterBoldOutline.svelte
mark_module_start();
LetterBoldOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LetterBoldOutline.svelte";
var root_1363 = add_locations(ns_template(`<title> </title>`), LetterBoldOutline[FILENAME], [[41, 4]]);
var root_2363 = add_locations(ns_template(`<desc> </desc>`), LetterBoldOutline[FILENAME], [[44, 4]]);
var root363 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 5h4.5a3.5 3.5 0 1 1 0 7H8m0-7v7m0-7H6m2 7h6.5a3.5 3.5 0 1 1 0 7H8m0-7v7m0 0H6"></path></svg>`), LetterBoldOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LetterBoldOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LetterBoldOutline);
  validate_prop_bindings($$props, [], [], LetterBoldOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "letter bold outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root363();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1363();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2363();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LetterBoldOutline = hmr(LetterBoldOutline, () => LetterBoldOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LetterBoldOutline[HMR].source;
    set(LetterBoldOutline[HMR].source, module.default[HMR].original);
  });
}
var LetterBoldOutline_default = LetterBoldOutline;
mark_module_end(LetterBoldOutline);

// node_modules/flowbite-svelte-icons/dist/LetterItalicOutline.svelte
mark_module_start();
LetterItalicOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LetterItalicOutline.svelte";
var root_1364 = add_locations(ns_template(`<title> </title>`), LetterItalicOutline[FILENAME], [[41, 4]]);
var root_2364 = add_locations(ns_template(`<desc> </desc>`), LetterItalicOutline[FILENAME], [[44, 4]]);
var root364 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8.874 19 6.143-14M6 19h6.33m-.66-14H18"></path></svg>`), LetterItalicOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LetterItalicOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LetterItalicOutline);
  validate_prop_bindings($$props, [], [], LetterItalicOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "letter italic outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root364();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1364();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2364();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LetterItalicOutline = hmr(LetterItalicOutline, () => LetterItalicOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LetterItalicOutline[HMR].source;
    set(LetterItalicOutline[HMR].source, module.default[HMR].original);
  });
}
var LetterItalicOutline_default = LetterItalicOutline;
mark_module_end(LetterItalicOutline);

// node_modules/flowbite-svelte-icons/dist/LetterUnderlineOutline.svelte
mark_module_start();
LetterUnderlineOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LetterUnderlineOutline.svelte";
var root_1365 = add_locations(ns_template(`<title> </title>`), LetterUnderlineOutline[FILENAME], [[41, 4]]);
var root_2365 = add_locations(ns_template(`<desc> </desc>`), LetterUnderlineOutline[FILENAME], [[44, 4]]);
var root365 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M6 19h12M8 5v9a4 4 0 0 0 8 0V5M6 5h4m4 0h4"></path></svg>`), LetterUnderlineOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LetterUnderlineOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LetterUnderlineOutline);
  validate_prop_bindings($$props, [], [], LetterUnderlineOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "letter underline outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root365();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1365();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2365();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LetterUnderlineOutline = hmr(LetterUnderlineOutline, () => LetterUnderlineOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LetterUnderlineOutline[HMR].source;
    set(LetterUnderlineOutline[HMR].source, module.default[HMR].original);
  });
}
var LetterUnderlineOutline_default = LetterUnderlineOutline;
mark_module_end(LetterUnderlineOutline);

// node_modules/flowbite-svelte-icons/dist/LifeSaverOutline.svelte
mark_module_start();
LifeSaverOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LifeSaverOutline.svelte";
var root_1366 = add_locations(ns_template(`<title> </title>`), LifeSaverOutline[FILENAME], [[41, 4]]);
var root_2366 = add_locations(ns_template(`<desc> </desc>`), LifeSaverOutline[FILENAME], [[44, 4]]);
var root366 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m13.46 8.291 3.849-3.849a1.5 1.5 0 0 1 2.122 0l.127.127a1.5 1.5 0 0 1 0 2.122l-3.84 3.838a4 4 0 0 0-2.258-2.238Zm0 0a4 4 0 0 1 2.263 2.238l3.662-3.662a8.961 8.961 0 0 1 0 10.27l-3.676-3.676m-2.25-5.17 3.678-3.676a8.961 8.961 0 0 0-10.27 0l3.662 3.662a4 4 0 0 0-2.238 2.258L4.615 6.863a8.96 8.96 0 0 0 0 10.27l3.662-3.662a4 4 0 0 0 2.258 2.238l-3.672 3.676a8.96 8.96 0 0 0 10.27 0l-3.662-3.662a4.001 4.001 0 0 0 2.238-2.262m0 0 3.849 3.848a1.5 1.5 0 0 1 0 2.122l-.127.126a1.499 1.499 0 0 1-2.122 0l-3.838-3.838a4 4 0 0 0 2.238-2.258Zm.29-1.461a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-7.718 1.471-3.84 3.838a1.5 1.5 0 0 0 0 2.122l.128.126a1.5 1.5 0 0 0 2.122 0l3.848-3.848a4 4 0 0 1-2.258-2.238Zm2.248-5.19L6.69 4.442a1.5 1.5 0 0 0-2.122 0l-.127.127a1.5 1.5 0 0 0 0 2.122l3.849 3.848a4 4 0 0 1 2.238-2.258Z"></path></svg>`), LifeSaverOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LifeSaverOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LifeSaverOutline);
  validate_prop_bindings($$props, [], [], LifeSaverOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "life saver outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root366();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1366();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2366();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LifeSaverOutline = hmr(LifeSaverOutline, () => LifeSaverOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LifeSaverOutline[HMR].source;
    set(LifeSaverOutline[HMR].source, module.default[HMR].original);
  });
}
var LifeSaverOutline_default = LifeSaverOutline;
mark_module_end(LifeSaverOutline);

// node_modules/flowbite-svelte-icons/dist/LifeSaverSolid.svelte
mark_module_start();
LifeSaverSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LifeSaverSolid.svelte";
var root_1367 = add_locations(ns_template(`<title> </title>`), LifeSaverSolid[FILENAME], [[39, 4]]);
var root_2367 = add_locations(ns_template(`<desc> </desc>`), LifeSaverSolid[FILENAME], [[42, 4]]);
var root367 = add_locations(ns_template(`<svg><!><!><path d="m7.4 3.736 3.43 3.429A5.046 5.046 0 0 1 12.133 7c.356.01.71.06 1.056.147l3.41-3.412a2.32 2.32 0 0 1 .451-.344A9.89 9.89 0 0 0 12.268 2a10.022 10.022 0 0 0-5.322 1.392c.165.095.318.211.454.344Zm11.451 1.54-.127-.127a.5.5 0 0 0-.706 0l-2.932 2.932c.03.023.05.054.078.077.237.194.454.41.651.645.033.038.077.067.11.107l2.926-2.927a.5.5 0 0 0 0-.707Zm-2.931 9.81c-.025.03-.058.052-.082.082a4.97 4.97 0 0 1-.633.639c-.04.036-.072.083-.115.117l2.927 2.927a.5.5 0 0 0 .707 0l.127-.127a.5.5 0 0 0 0-.707l-2.932-2.931Zm-1.443-4.763a3.037 3.037 0 0 0-1.383-1.1l-.012-.007a2.956 2.956 0 0 0-1-.213H12a2.964 2.964 0 0 0-2.122.893c-.285.29-.509.634-.657 1.013l-.009.016a2.96 2.96 0 0 0-.21 1 2.99 2.99 0 0 0 .488 1.716l.032.04a3.04 3.04 0 0 0 1.384 1.1l.012.007c.319.129.657.2 1 .213.393.015.784-.05 1.15-.192.012-.005.021-.013.033-.018a3.01 3.01 0 0 0 1.676-1.7v-.007a2.89 2.89 0 0 0 0-2.207 2.868 2.868 0 0 0-.27-.515c-.007-.012-.02-.025-.03-.039Zm6.137-3.373a2.53 2.53 0 0 1-.349.447l-3.426 3.426c.112.428.166.869.161 1.311a4.954 4.954 0 0 1-.148 1.054l3.413 3.412c.133.134.249.283.347.444A9.88 9.88 0 0 0 22 12.269a9.913 9.913 0 0 0-1.386-5.319ZM16.6 20.264l-3.42-3.421c-.386.1-.782.152-1.18.157h-.135c-.356-.01-.71-.06-1.056-.147L7.4 20.265a2.503 2.503 0 0 1-.444.347A9.884 9.884 0 0 0 11.732 22H12a9.9 9.9 0 0 0 5.044-1.388 2.515 2.515 0 0 1-.444-.348ZM3.735 16.6l3.426-3.426a4.608 4.608 0 0 1-.013-2.367L3.735 7.4a2.508 2.508 0 0 1-.349-.447 9.889 9.889 0 0 0 0 10.1 2.48 2.48 0 0 1 .35-.453Zm5.101-.758a4.959 4.959 0 0 1-.65-.645c-.034-.038-.078-.067-.11-.107L5.15 18.017a.5.5 0 0 0 0 .707l.127.127a.5.5 0 0 0 .706 0l2.932-2.933c-.029-.018-.049-.053-.078-.076Zm-.755-6.928c.03-.037.07-.063.1-.1.183-.22.383-.423.6-.609.046-.04.081-.092.128-.13L5.983 5.149a.5.5 0 0 0-.707 0l-.127.127a.5.5 0 0 0 0 .707l2.932 2.931Z"></path></svg>`), LifeSaverSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function LifeSaverSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LifeSaverSolid);
  validate_prop_bindings($$props, [], [], LifeSaverSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "life saver solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root367();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1367();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2367();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LifeSaverSolid = hmr(LifeSaverSolid, () => LifeSaverSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LifeSaverSolid[HMR].source;
    set(LifeSaverSolid[HMR].source, module.default[HMR].original);
  });
}
var LifeSaverSolid_default = LifeSaverSolid;
mark_module_end(LifeSaverSolid);

// node_modules/flowbite-svelte-icons/dist/LightbulbOutline.svelte
mark_module_start();
LightbulbOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LightbulbOutline.svelte";
var root_1368 = add_locations(ns_template(`<title> </title>`), LightbulbOutline[FILENAME], [[41, 4]]);
var root_2368 = add_locations(ns_template(`<desc> </desc>`), LightbulbOutline[FILENAME], [[44, 4]]);
var root368 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 9a3 3 0 0 1 3-3m-2 15h4m0-3c0-4.1 4-4.9 4-9A6 6 0 1 0 6 9c0 4 4 5 4 9h4Z"></path></svg>`), LightbulbOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LightbulbOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LightbulbOutline);
  validate_prop_bindings($$props, [], [], LightbulbOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "lightbulb outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root368();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1368();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2368();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LightbulbOutline = hmr(LightbulbOutline, () => LightbulbOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LightbulbOutline[HMR].source;
    set(LightbulbOutline[HMR].source, module.default[HMR].original);
  });
}
var LightbulbOutline_default = LightbulbOutline;
mark_module_end(LightbulbOutline);

// node_modules/flowbite-svelte-icons/dist/LightbulbSolid.svelte
mark_module_start();
LightbulbSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LightbulbSolid.svelte";
var root_1369 = add_locations(ns_template(`<title> </title>`), LightbulbSolid[FILENAME], [[39, 4]]);
var root_2369 = add_locations(ns_template(`<desc> </desc>`), LightbulbSolid[FILENAME], [[42, 4]]);
var root369 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M7.05 4.05A7 7 0 0 1 19 9c0 2.407-1.197 3.874-2.186 5.084l-.04.048C15.77 15.362 15 16.34 15 18a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1c0-1.612-.77-2.613-1.78-3.875l-.045-.056C6.193 12.842 5 11.352 5 9a7 7 0 0 1 2.05-4.95ZM9 21a1 1 0 0 1 1-1h4a1 1 0 1 1 0 2h-4a1 1 0 0 1-1-1Zm1.586-13.414A2 2 0 0 1 12 7a1 1 0 1 0 0-2 4 4 0 0 0-4 4 1 1 0 0 0 2 0 2 2 0 0 1 .586-1.414Z" clip-rule="evenodd"></path></svg>`), LightbulbSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function LightbulbSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LightbulbSolid);
  validate_prop_bindings($$props, [], [], LightbulbSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "lightbulb solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root369();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1369();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2369();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LightbulbSolid = hmr(LightbulbSolid, () => LightbulbSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LightbulbSolid[HMR].source;
    set(LightbulbSolid[HMR].source, module.default[HMR].original);
  });
}
var LightbulbSolid_default = LightbulbSolid;
mark_module_end(LightbulbSolid);

// node_modules/flowbite-svelte-icons/dist/LinkBreakOutline.svelte
mark_module_start();
LinkBreakOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LinkBreakOutline.svelte";
var root_1370 = add_locations(ns_template(`<title> </title>`), LinkBreakOutline[FILENAME], [[41, 4]]);
var root_2370 = add_locations(ns_template(`<desc> </desc>`), LinkBreakOutline[FILENAME], [[44, 4]]);
var root370 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M13.2131 9.78732c-.6359-.63557-1.4983-.99259-2.3974-.99259-.89911 0-1.76143.35702-2.39741.99259l-3.4253 3.42528C4.35719 13.8485 4 14.7108 4 15.61c0 .8992.35719 1.7616.99299 2.3974.63598.6356 1.4983.9926 2.39742.9926.89912 0 1.76144-.357 2.39742-.9926l.32157-.3043m-.32157-4.4905c.63587.6358 1.49827.993 2.39747.993.8991 0 1.7615-.3572 2.3974-.993l3.4243-3.42528c.6358-.63585.993-1.49822.993-2.39741 0-.89919-.3572-1.76156-.993-2.39741C17.3712 4.357 16.509 4 15.6101 4c-.899 0-1.7612.357-2.397.9925l-1.0278.96062m7.3873 14.04678-1.7862-1.7862m0 0L16 16.4274m1.7864 1.7863 1.7862-1.7863m-1.7862 1.7863L16 20"></path></svg>`), LinkBreakOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LinkBreakOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LinkBreakOutline);
  validate_prop_bindings($$props, [], [], LinkBreakOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "link break outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root370();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1370();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2370();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LinkBreakOutline = hmr(LinkBreakOutline, () => LinkBreakOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LinkBreakOutline[HMR].source;
    set(LinkBreakOutline[HMR].source, module.default[HMR].original);
  });
}
var LinkBreakOutline_default = LinkBreakOutline;
mark_module_end(LinkBreakOutline);

// node_modules/flowbite-svelte-icons/dist/LinkOutline.svelte
mark_module_start();
LinkOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LinkOutline.svelte";
var root_1371 = add_locations(ns_template(`<title> </title>`), LinkOutline[FILENAME], [[41, 4]]);
var root_2371 = add_locations(ns_template(`<desc> </desc>`), LinkOutline[FILENAME], [[44, 4]]);
var root371 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.213 9.787a3.391 3.391 0 0 0-4.795 0l-3.425 3.426a3.39 3.39 0 0 0 4.795 4.794l.321-.304m-.321-4.49a3.39 3.39 0 0 0 4.795 0l3.424-3.426a3.39 3.39 0 0 0-4.794-4.795l-1.028.961"></path></svg>`), LinkOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LinkOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LinkOutline);
  validate_prop_bindings($$props, [], [], LinkOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "link outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root371();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1371();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2371();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LinkOutline = hmr(LinkOutline, () => LinkOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LinkOutline[HMR].source;
    set(LinkOutline[HMR].source, module.default[HMR].original);
  });
}
var LinkOutline_default = LinkOutline;
mark_module_end(LinkOutline);

// node_modules/flowbite-svelte-icons/dist/LinkedinSolid.svelte
mark_module_start();
LinkedinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LinkedinSolid.svelte";
var root_1372 = add_locations(ns_template(`<title> </title>`), LinkedinSolid[FILENAME], [[39, 4]]);
var root_2372 = add_locations(ns_template(`<desc> </desc>`), LinkedinSolid[FILENAME], [[42, 4]]);
var root372 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12.51 8.796v1.697a3.738 3.738 0 0 1 3.288-1.684c3.455 0 4.202 2.16 4.202 4.97V19.5h-3.2v-5.072c0-1.21-.244-2.766-2.128-2.766-1.827 0-2.139 1.317-2.139 2.676V19.5h-3.19V8.796h3.168ZM7.2 6.106a1.61 1.61 0 0 1-.988 1.483 1.595 1.595 0 0 1-1.743-.348A1.607 1.607 0 0 1 5.6 4.5a1.601 1.601 0 0 1 1.6 1.606Z" clip-rule="evenodd"></path><path d="M7.2 8.809H4V19.5h3.2V8.809Z"></path></svg>`), LinkedinSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 5]]]
]);
function LinkedinSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LinkedinSolid);
  validate_prop_bindings($$props, [], [], LinkedinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "linkedin solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root372();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1372();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2372();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LinkedinSolid = hmr(LinkedinSolid, () => LinkedinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LinkedinSolid[HMR].source;
    set(LinkedinSolid[HMR].source, module.default[HMR].original);
  });
}
var LinkedinSolid_default = LinkedinSolid;
mark_module_end(LinkedinSolid);

// node_modules/flowbite-svelte-icons/dist/ListMusicOutline.svelte
mark_module_start();
ListMusicOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ListMusicOutline.svelte";
var root_1373 = add_locations(ns_template(`<title> </title>`), ListMusicOutline[FILENAME], [[41, 4]]);
var root_2373 = add_locations(ns_template(`<desc> </desc>`), ListMusicOutline[FILENAME], [[44, 4]]);
var root373 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 15.5V5s3 1 3 4m-7-3H4m9 4H4m4 4H4m13 2.4c0 1.326-1.343 2.4-3 2.4s-3-1.075-3-2.4 1.343-2.4 3-2.4 3 1.075 3 2.4Z"></path></svg>`), ListMusicOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ListMusicOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ListMusicOutline);
  validate_prop_bindings($$props, [], [], ListMusicOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "list music outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root373();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1373();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2373();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ListMusicOutline = hmr(ListMusicOutline, () => ListMusicOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListMusicOutline[HMR].source;
    set(ListMusicOutline[HMR].source, module.default[HMR].original);
  });
}
var ListMusicOutline_default = ListMusicOutline;
mark_module_end(ListMusicOutline);

// node_modules/flowbite-svelte-icons/dist/ListMusicSolid.svelte
mark_module_start();
ListMusicSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ListMusicSolid.svelte";
var root_1374 = add_locations(ns_template(`<title> </title>`), ListMusicSolid[FILENAME], [[39, 4]]);
var root_2374 = add_locations(ns_template(`<desc> </desc>`), ListMusicSolid[FILENAME], [[42, 4]]);
var root374 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M17.316 4.052a.99.99 0 0 0-.9.14c-.262.19-.416.495-.416.82v8.566a4.573 4.573 0 0 0-2-.464c-1.99 0-4 1.342-4 3.443 0 2.1 2.01 3.443 4 3.443 1.99 0 4-1.342 4-3.443V6.801c.538.5 1 1.219 1 2.262 0 .56.448 1.013 1 1.013s1-.453 1-1.013c0-1.905-.956-3.18-1.86-3.942a6.391 6.391 0 0 0-1.636-.998 4 4 0 0 0-.166-.063l-.013-.005-.005-.002h-.002l-.002-.001ZM4 5.012c-.552 0-1 .454-1 1.013 0 .56.448 1.013 1 1.013h9c.552 0 1-.453 1-1.013 0-.559-.448-1.012-1-1.012H4Zm0 4.051c-.552 0-1 .454-1 1.013 0 .56.448 1.013 1 1.013h9c.552 0 1-.454 1-1.013 0-.56-.448-1.013-1-1.013H4Zm0 4.05c-.552 0-1 .454-1 1.014 0 .559.448 1.012 1 1.012h4c.552 0 1-.453 1-1.012 0-.56-.448-1.013-1-1.013H4Z" clip-rule="evenodd"></path></svg>`), ListMusicSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ListMusicSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ListMusicSolid);
  validate_prop_bindings($$props, [], [], ListMusicSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "list music solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root374();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1374();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2374();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ListMusicSolid = hmr(ListMusicSolid, () => ListMusicSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListMusicSolid[HMR].source;
    set(ListMusicSolid[HMR].source, module.default[HMR].original);
  });
}
var ListMusicSolid_default = ListMusicSolid;
mark_module_end(ListMusicSolid);

// node_modules/flowbite-svelte-icons/dist/ListOutline.svelte
mark_module_start();
ListOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ListOutline.svelte";
var root_1375 = add_locations(ns_template(`<title> </title>`), ListOutline[FILENAME], [[41, 4]]);
var root_2375 = add_locations(ns_template(`<desc> </desc>`), ListOutline[FILENAME], [[44, 4]]);
var root375 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M9 8h10M9 12h10M9 16h10M4.99 8H5m-.02 4h.01m0 4H5"></path></svg>`), ListOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ListOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ListOutline);
  validate_prop_bindings($$props, [], [], ListOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "list outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root375();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1375();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2375();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ListOutline = hmr(ListOutline, () => ListOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ListOutline[HMR].source;
    set(ListOutline[HMR].source, module.default[HMR].original);
  });
}
var ListOutline_default = ListOutline;
mark_module_end(ListOutline);

// node_modules/flowbite-svelte-icons/dist/LockOpenOutline.svelte
mark_module_start();
LockOpenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockOpenOutline.svelte";
var root_1376 = add_locations(ns_template(`<title> </title>`), LockOpenOutline[FILENAME], [[41, 4]]);
var root_2376 = add_locations(ns_template(`<desc> </desc>`), LockOpenOutline[FILENAME], [[44, 4]]);
var root376 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 14v3m4-6V7a3 3 0 1 1 6 0v4M5 11h10a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-7a1 1 0 0 1 1-1Z"></path></svg>`), LockOpenOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LockOpenOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LockOpenOutline);
  validate_prop_bindings($$props, [], [], LockOpenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "lock open outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root376();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1376();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2376();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LockOpenOutline = hmr(LockOpenOutline, () => LockOpenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockOpenOutline[HMR].source;
    set(LockOpenOutline[HMR].source, module.default[HMR].original);
  });
}
var LockOpenOutline_default = LockOpenOutline;
mark_module_end(LockOpenOutline);

// node_modules/flowbite-svelte-icons/dist/LockOpenSolid.svelte
mark_module_start();
LockOpenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockOpenSolid.svelte";
var root_1377 = add_locations(ns_template(`<title> </title>`), LockOpenSolid[FILENAME], [[39, 4]]);
var root_2377 = add_locations(ns_template(`<desc> </desc>`), LockOpenSolid[FILENAME], [[42, 4]]);
var root377 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M15 7a2 2 0 1 1 4 0v4a1 1 0 1 0 2 0V7a4 4 0 0 0-8 0v3H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2V7Zm-5 6a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0v-3a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), LockOpenSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function LockOpenSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LockOpenSolid);
  validate_prop_bindings($$props, [], [], LockOpenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "lock open solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root377();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1377();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2377();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LockOpenSolid = hmr(LockOpenSolid, () => LockOpenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockOpenSolid[HMR].source;
    set(LockOpenSolid[HMR].source, module.default[HMR].original);
  });
}
var LockOpenSolid_default = LockOpenSolid;
mark_module_end(LockOpenSolid);

// node_modules/flowbite-svelte-icons/dist/LockOutline.svelte
mark_module_start();
LockOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockOutline.svelte";
var root_1378 = add_locations(ns_template(`<title> </title>`), LockOutline[FILENAME], [[41, 4]]);
var root_2378 = add_locations(ns_template(`<desc> </desc>`), LockOutline[FILENAME], [[44, 4]]);
var root378 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 14v3m-3-6V7a3 3 0 1 1 6 0v4m-8 0h10a1 1 0 0 1 1 1v7a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1v-7a1 1 0 0 1 1-1Z"></path></svg>`), LockOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LockOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LockOutline);
  validate_prop_bindings($$props, [], [], LockOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "lock outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root378();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1378();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2378();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LockOutline = hmr(LockOutline, () => LockOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockOutline[HMR].source;
    set(LockOutline[HMR].source, module.default[HMR].original);
  });
}
var LockOutline_default = LockOutline;
mark_module_end(LockOutline);

// node_modules/flowbite-svelte-icons/dist/LockSolid.svelte
mark_module_start();
LockSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockSolid.svelte";
var root_1379 = add_locations(ns_template(`<title> </title>`), LockSolid[FILENAME], [[39, 4]]);
var root_2379 = add_locations(ns_template(`<desc> </desc>`), LockSolid[FILENAME], [[42, 4]]);
var root379 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 10V7a4 4 0 1 1 8 0v3h1a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h1Zm2-3a2 2 0 1 1 4 0v3h-4V7Zm2 6a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0v-3a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), LockSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function LockSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LockSolid);
  validate_prop_bindings($$props, [], [], LockSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "lock solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root379();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1379();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2379();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LockSolid = hmr(LockSolid, () => LockSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockSolid[HMR].source;
    set(LockSolid[HMR].source, module.default[HMR].original);
  });
}
var LockSolid_default = LockSolid;
mark_module_end(LockSolid);

// node_modules/flowbite-svelte-icons/dist/LockTimeOutline.svelte
mark_module_start();
LockTimeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockTimeOutline.svelte";
var root_1380 = add_locations(ns_template(`<title> </title>`), LockTimeOutline[FILENAME], [[41, 4]]);
var root_2380 = add_locations(ns_template(`<desc> </desc>`), LockTimeOutline[FILENAME], [[44, 4]]);
var root380 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.5 11H5a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h4.5M7 11V7a3 3 0 0 1 6 0v1.5m2.5 5.5v1.5l1 1m3.5-1a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0Z"></path></svg>`), LockTimeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function LockTimeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LockTimeOutline);
  validate_prop_bindings($$props, [], [], LockTimeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "lock time outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root380();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1380();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2380();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LockTimeOutline = hmr(LockTimeOutline, () => LockTimeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockTimeOutline[HMR].source;
    set(LockTimeOutline[HMR].source, module.default[HMR].original);
  });
}
var LockTimeOutline_default = LockTimeOutline;
mark_module_end(LockTimeOutline);

// node_modules/flowbite-svelte-icons/dist/LockTimeSolid.svelte
mark_module_start();
LockTimeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/LockTimeSolid.svelte";
var root_1381 = add_locations(ns_template(`<title> </title>`), LockTimeSolid[FILENAME], [[39, 4]]);
var root_2381 = add_locations(ns_template(`<desc> </desc>`), LockTimeSolid[FILENAME], [[42, 4]]);
var root381 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M10 5a2 2 0 0 0-2 2v3h2.4A7.48 7.48 0 0 0 8 15.5a7.48 7.48 0 0 0 2.4 5.5H5a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h1V7a4 4 0 1 1 8 0v1.15a7.446 7.446 0 0 0-1.943.685A.999.999 0 0 1 12 8.5V7a2 2 0 0 0-2-2Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M10 15.5a5.5 5.5 0 1 1 11 0 5.5 5.5 0 0 1-11 0Zm6.5-1.5a1 1 0 1 0-2 0v1.5a1 1 0 0 0 .293.707l1 1a1 1 0 0 0 1.414-1.414l-.707-.707V14Z" clip-rule="evenodd"></path></svg>`), LockTimeSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function LockTimeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, LockTimeSolid);
  validate_prop_bindings($$props, [], [], LockTimeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "lock time solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root381();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1381();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2381();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  LockTimeSolid = hmr(LockTimeSolid, () => LockTimeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = LockTimeSolid[HMR].source;
    set(LockTimeSolid[HMR].source, module.default[HMR].original);
  });
}
var LockTimeSolid_default = LockTimeSolid;
mark_module_end(LockTimeSolid);

// node_modules/flowbite-svelte-icons/dist/MailBoxOutline.svelte
mark_module_start();
MailBoxOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MailBoxOutline.svelte";
var root_1382 = add_locations(ns_template(`<title> </title>`), MailBoxOutline[FILENAME], [[41, 4]]);
var root_2382 = add_locations(ns_template(`<desc> </desc>`), MailBoxOutline[FILENAME], [[44, 4]]);
var root382 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 16v-5.5A3.5 3.5 0 0 0 7.5 7m3.5 9H4v-5.5A3.5 3.5 0 0 1 7.5 7m3.5 9v4M7.5 7H14m0 0V4h2.5M14 7v3m-3.5 6H20v-6a3 3 0 0 0-3-3m-2 9v4m-8-6.5h1"></path></svg>`), MailBoxOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MailBoxOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MailBoxOutline);
  validate_prop_bindings($$props, [], [], MailBoxOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "mail box outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root382();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1382();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2382();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MailBoxOutline = hmr(MailBoxOutline, () => MailBoxOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MailBoxOutline[HMR].source;
    set(MailBoxOutline[HMR].source, module.default[HMR].original);
  });
}
var MailBoxOutline_default = MailBoxOutline;
mark_module_end(MailBoxOutline);

// node_modules/flowbite-svelte-icons/dist/MailBoxSolid.svelte
mark_module_start();
MailBoxSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MailBoxSolid.svelte";
var root_1383 = add_locations(ns_template(`<title> </title>`), MailBoxSolid[FILENAME], [[39, 4]]);
var root_2383 = add_locations(ns_template(`<desc> </desc>`), MailBoxSolid[FILENAME], [[42, 4]]);
var root383 = add_locations(ns_template(`<svg><!><!><path d="M17 6h-2V5h1a1 1 0 1 0 0-2h-2a1 1 0 0 0-1 1v2h-.541A5.965 5.965 0 0 1 14 10v4a1 1 0 1 1-2 0v-4c0-2.206-1.794-4-4-4-.075 0-.148.012-.22.028C7.686 6.022 7.596 6 7.5 6A4.505 4.505 0 0 0 3 10.5V16a1 1 0 0 0 1 1h7v3a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-3h5a1 1 0 0 0 1-1v-6c0-2.206-1.794-4-4-4Zm-9 8.5H7a1 1 0 1 1 0-2h1a1 1 0 1 1 0 2Z"></path></svg>`), MailBoxSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MailBoxSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MailBoxSolid);
  validate_prop_bindings($$props, [], [], MailBoxSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "mail box solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root383();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1383();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2383();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MailBoxSolid = hmr(MailBoxSolid, () => MailBoxSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MailBoxSolid[HMR].source;
    set(MailBoxSolid[HMR].source, module.default[HMR].original);
  });
}
var MailBoxSolid_default = MailBoxSolid;
mark_module_end(MailBoxSolid);

// node_modules/flowbite-svelte-icons/dist/MapPinAltOutline.svelte
mark_module_start();
MapPinAltOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MapPinAltOutline.svelte";
var root_1384 = add_locations(ns_template(`<title> </title>`), MapPinAltOutline[FILENAME], [[41, 4]]);
var root_2384 = add_locations(ns_template(`<desc> </desc>`), MapPinAltOutline[FILENAME], [[44, 4]]);
var root384 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 13a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"></path><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17.8 13.938h-.011a7 7 0 1 0-11.464.144h-.016l.14.171c.1.127.2.251.3.371L12 21l5.13-6.248c.194-.209.374-.429.54-.659l.13-.155Z"></path></svg>`), MapPinAltOutline[FILENAME], [
  [30, 0, [[46, 2], [53, 2]]]
]);
function MapPinAltOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MapPinAltOutline);
  validate_prop_bindings($$props, [], [], MapPinAltOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "map pin alt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root384();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1384();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2384();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MapPinAltOutline = hmr(MapPinAltOutline, () => MapPinAltOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MapPinAltOutline[HMR].source;
    set(MapPinAltOutline[HMR].source, module.default[HMR].original);
  });
}
var MapPinAltOutline_default = MapPinAltOutline;
mark_module_end(MapPinAltOutline);

// node_modules/flowbite-svelte-icons/dist/MapPinAltSolid.svelte
mark_module_start();
MapPinAltSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MapPinAltSolid.svelte";
var root_1385 = add_locations(ns_template(`<title> </title>`), MapPinAltSolid[FILENAME], [[39, 4]]);
var root_2385 = add_locations(ns_template(`<desc> </desc>`), MapPinAltSolid[FILENAME], [[42, 4]]);
var root385 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M11.906 1.994a8.002 8.002 0 0 1 8.09 8.421 7.996 7.996 0 0 1-1.297 3.957.996.996 0 0 1-.133.204l-.108.129c-.178.243-.37.477-.573.699l-5.112 6.224a1 1 0 0 1-1.545 0L5.982 15.26l-.002-.002a18.146 18.146 0 0 1-.309-.38l-.133-.163a.999.999 0 0 1-.13-.202 7.995 7.995 0 0 1 6.498-12.518ZM15 9.997a3 3 0 1 1-5.999 0 3 3 0 0 1 5.999 0Z" clip-rule="evenodd"></path></svg>`), MapPinAltSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MapPinAltSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MapPinAltSolid);
  validate_prop_bindings($$props, [], [], MapPinAltSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "map pin alt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root385();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1385();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2385();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MapPinAltSolid = hmr(MapPinAltSolid, () => MapPinAltSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MapPinAltSolid[HMR].source;
    set(MapPinAltSolid[HMR].source, module.default[HMR].original);
  });
}
var MapPinAltSolid_default = MapPinAltSolid;
mark_module_end(MapPinAltSolid);

// node_modules/flowbite-svelte-icons/dist/MapPinOutline.svelte
mark_module_start();
MapPinOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MapPinOutline.svelte";
var root_1386 = add_locations(ns_template(`<title> </title>`), MapPinOutline[FILENAME], [[41, 4]]);
var root_2386 = add_locations(ns_template(`<desc> </desc>`), MapPinOutline[FILENAME], [[44, 4]]);
var root386 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 15a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm0 0v6M9.5 9A2.5 2.5 0 0 1 12 6.5"></path></svg>`), MapPinOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MapPinOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MapPinOutline);
  validate_prop_bindings($$props, [], [], MapPinOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "map pin outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root386();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1386();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2386();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MapPinOutline = hmr(MapPinOutline, () => MapPinOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MapPinOutline[HMR].source;
    set(MapPinOutline[HMR].source, module.default[HMR].original);
  });
}
var MapPinOutline_default = MapPinOutline;
mark_module_end(MapPinOutline);

// node_modules/flowbite-svelte-icons/dist/MapPinSolid.svelte
mark_module_start();
MapPinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MapPinSolid.svelte";
var root_1387 = add_locations(ns_template(`<title> </title>`), MapPinSolid[FILENAME], [[39, 4]]);
var root_2387 = add_locations(ns_template(`<desc> </desc>`), MapPinSolid[FILENAME], [[42, 4]]);
var root387 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 9a7 7 0 1 1 8 6.93V21a1 1 0 1 1-2 0v-5.07A7.001 7.001 0 0 1 5 9Zm5.94-1.06A1.5 1.5 0 0 1 12 7.5a1 1 0 1 0 0-2A3.5 3.5 0 0 0 8.5 9a1 1 0 0 0 2 0c0-.398.158-.78.44-1.06Z" clip-rule="evenodd"></path></svg>`), MapPinSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MapPinSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MapPinSolid);
  validate_prop_bindings($$props, [], [], MapPinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "map pin solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root387();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1387();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2387();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MapPinSolid = hmr(MapPinSolid, () => MapPinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MapPinSolid[HMR].source;
    set(MapPinSolid[HMR].source, module.default[HMR].original);
  });
}
var MapPinSolid_default = MapPinSolid;
mark_module_end(MapPinSolid);

// node_modules/flowbite-svelte-icons/dist/MastercardSolid.svelte
mark_module_start();
MastercardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MastercardSolid.svelte";
var root_1388 = add_locations(ns_template(`<title> </title>`), MastercardSolid[FILENAME], [[39, 4]]);
var root_2388 = add_locations(ns_template(`<desc> </desc>`), MastercardSolid[FILENAME], [[42, 4]]);
var root388 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4Zm5.178 12.137a4.137 4.137 0 1 1 1.036-8.144A6.113 6.113 0 0 0 8.726 12c0 1.531.56 2.931 1.488 4.006a4.114 4.114 0 0 1-1.036.131ZM10.726 12c0-1.183.496-2.252 1.294-3.006A4.125 4.125 0 0 1 13.315 12a4.126 4.126 0 0 1-1.294 3.006A4.126 4.126 0 0 1 10.726 12Zm4.59 0a6.11 6.11 0 0 1-1.489 4.006 4.137 4.137 0 1 0 0-8.013A6.113 6.113 0 0 1 15.315 12Z" clip-rule="evenodd"></path></svg>`), MastercardSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MastercardSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MastercardSolid);
  validate_prop_bindings($$props, [], [], MastercardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "mastercard solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root388();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1388();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2388();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MastercardSolid = hmr(MastercardSolid, () => MastercardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MastercardSolid[HMR].source;
    set(MastercardSolid[HMR].source, module.default[HMR].original);
  });
}
var MastercardSolid_default = MastercardSolid;
mark_module_end(MastercardSolid);

// node_modules/flowbite-svelte-icons/dist/MergeCellsOutline.svelte
mark_module_start();
MergeCellsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MergeCellsOutline.svelte";
var root_1389 = add_locations(ns_template(`<title> </title>`), MergeCellsOutline[FILENAME], [[41, 4]]);
var root_2389 = add_locations(ns_template(`<desc> </desc>`), MergeCellsOutline[FILENAME], [[44, 4]]);
var root389 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 18v2H4V4h6v2m4 12v2h6V4h-6v2m-6.49543 8.4954L10 12m0 0L7.50457 9.50457M10 12H4.05191m12.50199 2.5539L14 12m0 0 2.5539-2.55392M14 12h5.8319"></path></svg>`), MergeCellsOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MergeCellsOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MergeCellsOutline);
  validate_prop_bindings($$props, [], [], MergeCellsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "merge cells outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root389();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1389();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2389();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MergeCellsOutline = hmr(MergeCellsOutline, () => MergeCellsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MergeCellsOutline[HMR].source;
    set(MergeCellsOutline[HMR].source, module.default[HMR].original);
  });
}
var MergeCellsOutline_default = MergeCellsOutline;
mark_module_end(MergeCellsOutline);

// node_modules/flowbite-svelte-icons/dist/MergeOrSplitOutline.svelte
mark_module_start();
MergeOrSplitOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MergeOrSplitOutline.svelte";
var root_1390 = add_locations(ns_template(`<title> </title>`), MergeOrSplitOutline[FILENAME], [[41, 4]]);
var root_2390 = add_locations(ns_template(`<desc> </desc>`), MergeOrSplitOutline[FILENAME], [[44, 4]]);
var root390 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.5045 14.4954 21 12m0 0-2.4955-2.49542M21 12h-5.9481m-9.49798 2.5539L3 12m0 0 2.55392-2.55392M3 12h5.83192m.16807 7V5H15v14H8.99999Z"></path></svg>`), MergeOrSplitOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MergeOrSplitOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MergeOrSplitOutline);
  validate_prop_bindings($$props, [], [], MergeOrSplitOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "merge or split outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root390();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1390();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2390();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MergeOrSplitOutline = hmr(MergeOrSplitOutline, () => MergeOrSplitOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MergeOrSplitOutline[HMR].source;
    set(MergeOrSplitOutline[HMR].source, module.default[HMR].original);
  });
}
var MergeOrSplitOutline_default = MergeOrSplitOutline;
mark_module_end(MergeOrSplitOutline);

// node_modules/flowbite-svelte-icons/dist/MessageCaptionOutline.svelte
mark_module_start();
MessageCaptionOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessageCaptionOutline.svelte";
var root_1391 = add_locations(ns_template(`<title> </title>`), MessageCaptionOutline[FILENAME], [[41, 4]]);
var root_2391 = add_locations(ns_template(`<desc> </desc>`), MessageCaptionOutline[FILENAME], [[44, 4]]);
var root391 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 9h5m3 0h2M7 12h2m3 0h5M5 5h14a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-6.616a1 1 0 0 0-.67.257l-2.88 2.592A.5.5 0 0 1 8 18.477V17a1 1 0 0 0-1-1H5a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), MessageCaptionOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MessageCaptionOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MessageCaptionOutline);
  validate_prop_bindings($$props, [], [], MessageCaptionOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "message caption outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root391();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1391();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2391();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MessageCaptionOutline = hmr(MessageCaptionOutline, () => MessageCaptionOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessageCaptionOutline[HMR].source;
    set(MessageCaptionOutline[HMR].source, module.default[HMR].original);
  });
}
var MessageCaptionOutline_default = MessageCaptionOutline;
mark_module_end(MessageCaptionOutline);

// node_modules/flowbite-svelte-icons/dist/MessageCaptionSolid.svelte
mark_module_start();
MessageCaptionSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessageCaptionSolid.svelte";
var root_1392 = add_locations(ns_template(`<title> </title>`), MessageCaptionSolid[FILENAME], [[39, 4]]);
var root_2392 = add_locations(ns_template(`<desc> </desc>`), MessageCaptionSolid[FILENAME], [[42, 4]]);
var root392 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M3 6a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-6.616l-2.88 2.592C8.537 20.461 7 19.776 7 18.477V17H5a2 2 0 0 1-2-2V6Zm4 2a1 1 0 0 0 0 2h5a1 1 0 1 0 0-2H7Zm8 0a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2h-2Zm-8 3a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2H7Zm5 0a1 1 0 1 0 0 2h5a1 1 0 1 0 0-2h-5Z" clip-rule="evenodd"></path></svg>`), MessageCaptionSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MessageCaptionSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MessageCaptionSolid);
  validate_prop_bindings($$props, [], [], MessageCaptionSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "message caption solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root392();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1392();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2392();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MessageCaptionSolid = hmr(MessageCaptionSolid, () => MessageCaptionSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessageCaptionSolid[HMR].source;
    set(MessageCaptionSolid[HMR].source, module.default[HMR].original);
  });
}
var MessageCaptionSolid_default = MessageCaptionSolid;
mark_module_end(MessageCaptionSolid);

// node_modules/flowbite-svelte-icons/dist/MessageDotsOutline.svelte
mark_module_start();
MessageDotsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessageDotsOutline.svelte";
var root_1393 = add_locations(ns_template(`<title> </title>`), MessageDotsOutline[FILENAME], [[41, 4]]);
var root_2393 = add_locations(ns_template(`<desc> </desc>`), MessageDotsOutline[FILENAME], [[44, 4]]);
var root393 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 10.5h.01m-4.01 0h.01M8 10.5h.01M5 5h14a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-6.6a1 1 0 0 0-.69.275l-2.866 2.723A.5.5 0 0 1 8 18.635V17a1 1 0 0 0-1-1H5a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), MessageDotsOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MessageDotsOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MessageDotsOutline);
  validate_prop_bindings($$props, [], [], MessageDotsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "message dots outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root393();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1393();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2393();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MessageDotsOutline = hmr(MessageDotsOutline, () => MessageDotsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessageDotsOutline[HMR].source;
    set(MessageDotsOutline[HMR].source, module.default[HMR].original);
  });
}
var MessageDotsOutline_default = MessageDotsOutline;
mark_module_end(MessageDotsOutline);

// node_modules/flowbite-svelte-icons/dist/MessageDotsSolid.svelte
mark_module_start();
MessageDotsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessageDotsSolid.svelte";
var root_1394 = add_locations(ns_template(`<title> </title>`), MessageDotsSolid[FILENAME], [[39, 4]]);
var root_2394 = add_locations(ns_template(`<desc> </desc>`), MessageDotsSolid[FILENAME], [[42, 4]]);
var root394 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M3 5.983C3 4.888 3.895 4 5 4h14c1.105 0 2 .888 2 1.983v8.923a1.992 1.992 0 0 1-2 1.983h-6.6l-2.867 2.7c-.955.899-2.533.228-2.533-1.08v-1.62H5c-1.105 0-2-.888-2-1.983V5.983Zm5.706 3.809a1 1 0 1 0-1.412 1.417 1 1 0 1 0 1.412-1.417Zm2.585.002a1 1 0 1 1 .003 1.414 1 1 0 0 1-.003-1.414Zm5.415-.002a1 1 0 1 0-1.412 1.417 1 1 0 1 0 1.412-1.417Z" clip-rule="evenodd"></path></svg>`), MessageDotsSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MessageDotsSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MessageDotsSolid);
  validate_prop_bindings($$props, [], [], MessageDotsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "message dots solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root394();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1394();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2394();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MessageDotsSolid = hmr(MessageDotsSolid, () => MessageDotsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessageDotsSolid[HMR].source;
    set(MessageDotsSolid[HMR].source, module.default[HMR].original);
  });
}
var MessageDotsSolid_default = MessageDotsSolid;
mark_module_end(MessageDotsSolid);

// node_modules/flowbite-svelte-icons/dist/MessagesOutline.svelte
mark_module_start();
MessagesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessagesOutline.svelte";
var root_1395 = add_locations(ns_template(`<title> </title>`), MessagesOutline[FILENAME], [[41, 4]]);
var root_2395 = add_locations(ns_template(`<desc> </desc>`), MessagesOutline[FILENAME], [[44, 4]]);
var root395 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 17h6l3 3v-3h2V9h-2M4 4h11v8H9l-3 3v-3H4V4Z"></path></svg>`), MessagesOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MessagesOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MessagesOutline);
  validate_prop_bindings($$props, [], [], MessagesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "messages outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root395();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1395();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2395();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MessagesOutline = hmr(MessagesOutline, () => MessagesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessagesOutline[HMR].source;
    set(MessagesOutline[HMR].source, module.default[HMR].original);
  });
}
var MessagesOutline_default = MessagesOutline;
mark_module_end(MessagesOutline);

// node_modules/flowbite-svelte-icons/dist/MessagesSolid.svelte
mark_module_start();
MessagesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MessagesSolid.svelte";
var root_1396 = add_locations(ns_template(`<title> </title>`), MessagesSolid[FILENAME], [[39, 4]]);
var root_2396 = add_locations(ns_template(`<desc> </desc>`), MessagesSolid[FILENAME], [[42, 4]]);
var root396 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 3a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h1v2a1 1 0 0 0 1.707.707L9.414 13H15a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H4Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M8.023 17.215c.033-.03.066-.062.098-.094L10.243 15H15a3 3 0 0 0 3-3V8h2a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1h-1v2a1 1 0 0 1-1.707.707L14.586 18H9a1 1 0 0 1-.977-.785Z" clip-rule="evenodd"></path></svg>`), MessagesSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function MessagesSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MessagesSolid);
  validate_prop_bindings($$props, [], [], MessagesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "messages solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root396();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1396();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2396();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MessagesSolid = hmr(MessagesSolid, () => MessagesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MessagesSolid[HMR].source;
    set(MessagesSolid[HMR].source, module.default[HMR].original);
  });
}
var MessagesSolid_default = MessagesSolid;
mark_module_end(MessagesSolid);

// node_modules/flowbite-svelte-icons/dist/MicrophoneOutline.svelte
mark_module_start();
MicrophoneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicrophoneOutline.svelte";
var root_1397 = add_locations(ns_template(`<title> </title>`), MicrophoneOutline[FILENAME], [[41, 4]]);
var root_2397 = add_locations(ns_template(`<desc> </desc>`), MicrophoneOutline[FILENAME], [[44, 4]]);
var root397 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 9v3a5.006 5.006 0 0 1-5 5h-4a5.006 5.006 0 0 1-5-5V9m7 9v3m-3 0h6M11 3h2a3 3 0 0 1 3 3v5a3 3 0 0 1-3 3h-2a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3Z"></path></svg>`), MicrophoneOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MicrophoneOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MicrophoneOutline);
  validate_prop_bindings($$props, [], [], MicrophoneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "microphone outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root397();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1397();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2397();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MicrophoneOutline = hmr(MicrophoneOutline, () => MicrophoneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicrophoneOutline[HMR].source;
    set(MicrophoneOutline[HMR].source, module.default[HMR].original);
  });
}
var MicrophoneOutline_default = MicrophoneOutline;
mark_module_end(MicrophoneOutline);

// node_modules/flowbite-svelte-icons/dist/MicrophoneSlashOutline.svelte
mark_module_start();
MicrophoneSlashOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicrophoneSlashOutline.svelte";
var root_1398 = add_locations(ns_template(`<title> </title>`), MicrophoneSlashOutline[FILENAME], [[40, 4]]);
var root_2398 = add_locations(ns_template(`<desc> </desc>`), MicrophoneSlashOutline[FILENAME], [[43, 4]]);
var root398 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M19.97 9.012a1 1 0 1 0-2 0h2Zm-1 2.988 1 .001V12h-1Zm-8.962 4.98-.001 1h.001v-1Zm-3.52-1.46.708-.708-.707.707ZM5.029 12h-1v.001l1-.001Zm3.984 7.963a1 1 0 1 0 0 2v-2Zm5.975 2a1 1 0 0 0 0-2v2ZM7.017 8.017a1 1 0 1 0 2 0h-2Zm6.641 4.862a1 1 0 1 0 .667 1.886l-.667-1.886Zm-7.63-2.87a1 1 0 1 0-2 0h2Zm9.953 5.435a1 1 0 1 0 1 1.731l-1-1.731ZM12 16.979h1a1 1 0 0 0-1-1v1ZM5.736 4.322a1 1 0 0 0-1.414 1.414l1.414-1.414Zm12.528 15.356a1 1 0 0 0 1.414-1.414l-1.414 1.414ZM17.97 9.012V12h2V9.012h-2Zm0 2.987a3.985 3.985 0 0 1-1.168 2.813l1.415 1.414a5.985 5.985 0 0 0 1.753-4.225l-2-.002Zm-7.962 3.98a3.985 3.985 0 0 1-2.813-1.167l-1.414 1.414a5.985 5.985 0 0 0 4.225 1.753l.002-2Zm-2.813-1.167a3.985 3.985 0 0 1-1.167-2.813l-2 .002a5.985 5.985 0 0 0 1.753 4.225l1.414-1.414Zm3.808-10.775h1.992v-2h-1.992v2Zm1.992 0c1.097 0 1.987.89 1.987 1.988h2a3.988 3.988 0 0 0-3.987-3.988v2Zm1.987 1.988v4.98h2v-4.98h-2Zm-5.967 0c0-1.098.89-1.988 1.988-1.988v-2a3.988 3.988 0 0 0-3.988 3.988h2Zm-.004 15.938H12v-2H9.012v2Zm2.988 0h2.987v-2H12v2ZM9.016 8.017V6.025h-2v1.992h2Zm5.967 2.987a1.99 1.99 0 0 1-1.325 1.875l.667 1.886a3.989 3.989 0 0 0 2.658-3.76h-2ZM6.03 12v-1.992h-2V12h2Zm10.774 2.812a3.92 3.92 0 0 1-.823.632l1.002 1.731a5.982 5.982 0 0 0 1.236-.949l-1.415-1.414ZM4.322 5.736l13.942 13.942 1.414-1.414L5.736 4.322 4.322 5.736ZM12 15.98h-1.992v2H12v-2Zm-1 1v3.984h2V16.98h-2Z"></path></svg>`), MicrophoneSlashOutline[FILENAME], [[29, 0, [[45, 2]]]]);
function MicrophoneSlashOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MicrophoneSlashOutline);
  validate_prop_bindings($$props, [], [], MicrophoneSlashOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "microphone slash outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root398();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1398();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2398();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      color: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MicrophoneSlashOutline = hmr(MicrophoneSlashOutline, () => MicrophoneSlashOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicrophoneSlashOutline[HMR].source;
    set(MicrophoneSlashOutline[HMR].source, module.default[HMR].original);
  });
}
var MicrophoneSlashOutline_default = MicrophoneSlashOutline;
mark_module_end(MicrophoneSlashOutline);

// node_modules/flowbite-svelte-icons/dist/MicrophoneSlashSolid.svelte
mark_module_start();
MicrophoneSlashSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicrophoneSlashSolid.svelte";
var root_1399 = add_locations(ns_template(`<title> </title>`), MicrophoneSlashSolid[FILENAME], [[39, 4]]);
var root_2399 = add_locations(ns_template(`<desc> </desc>`), MicrophoneSlashSolid[FILENAME], [[42, 4]]);
var root399 = add_locations(ns_template(`<svg><!><!><path d="m15.506 14.097.994.995A3.989 3.989 0 0 0 17.975 12V9.011a.996.996 0 0 1 1.992 0v2.99a5.981 5.981 0 0 1-2.054 4.503l1.762 1.762a.996.996 0 1 1-1.408 1.408L4.325 5.733a.996.996 0 0 1 1.408-1.408L7.04 5.632a3.984 3.984 0 0 1 3.964-3.59h1.992c2.2 0 3.983 1.783 3.983 3.983v4.98a3.975 3.975 0 0 1-1.473 3.092ZM4.033 10.008a.996.996 0 1 1 1.992 0V12a3.99 3.99 0 0 0 3.984 3.984H12c.55 0 .996.446.996.996v2.988h1.992a.996.996 0 0 1 0 1.992H9.012a.996.996 0 0 1 0-1.992h1.992v-1.992h-.997a5.981 5.981 0 0 1-5.974-5.974v-1.993Z"></path></svg>`), MicrophoneSlashSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MicrophoneSlashSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MicrophoneSlashSolid);
  validate_prop_bindings($$props, [], [], MicrophoneSlashSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "microphone slash solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root399();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1399();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2399();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MicrophoneSlashSolid = hmr(MicrophoneSlashSolid, () => MicrophoneSlashSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicrophoneSlashSolid[HMR].source;
    set(MicrophoneSlashSolid[HMR].source, module.default[HMR].original);
  });
}
var MicrophoneSlashSolid_default = MicrophoneSlashSolid;
mark_module_end(MicrophoneSlashSolid);

// node_modules/flowbite-svelte-icons/dist/MicrophoneSolid.svelte
mark_module_start();
MicrophoneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MicrophoneSolid.svelte";
var root_1400 = add_locations(ns_template(`<title> </title>`), MicrophoneSolid[FILENAME], [[39, 4]]);
var root_2400 = add_locations(ns_template(`<desc> </desc>`), MicrophoneSolid[FILENAME], [[42, 4]]);
var root400 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 8a1 1 0 0 1 1 1v3a4.006 4.006 0 0 0 4 4h4a4.006 4.006 0 0 0 4-4V9a1 1 0 1 1 2 0v3.001A6.006 6.006 0 0 1 14.001 18H13v2h2a1 1 0 1 1 0 2H9a1 1 0 1 1 0-2h2v-2H9.999A6.006 6.006 0 0 1 4 12.001V9a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path><path d="M7 6a4 4 0 0 1 4-4h2a4 4 0 0 1 4 4v5a4 4 0 0 1-4 4h-2a4 4 0 0 1-4-4V6Z"></path></svg>`), MicrophoneSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 5]]]
]);
function MicrophoneSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MicrophoneSolid);
  validate_prop_bindings($$props, [], [], MicrophoneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "microphone solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root400();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1400();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2400();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MicrophoneSolid = hmr(MicrophoneSolid, () => MicrophoneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MicrophoneSolid[HMR].source;
    set(MicrophoneSolid[HMR].source, module.default[HMR].original);
  });
}
var MicrophoneSolid_default = MicrophoneSolid;
mark_module_end(MicrophoneSolid);

// node_modules/flowbite-svelte-icons/dist/MinimizeOutline.svelte
mark_module_start();
MinimizeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MinimizeOutline.svelte";
var root_1401 = add_locations(ns_template(`<title> </title>`), MinimizeOutline[FILENAME], [[41, 4]]);
var root_2401 = add_locations(ns_template(`<desc> </desc>`), MinimizeOutline[FILENAME], [[44, 4]]);
var root401 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 9h4m0 0V5m0 4L4 4m15 5h-4m0 0V5m0 4 5-5M5 15h4m0 0v4m0-4-5 5m15-5h-4m0 0v4m0-4 5 5"></path></svg>`), MinimizeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MinimizeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MinimizeOutline);
  validate_prop_bindings($$props, [], [], MinimizeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "minimize outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root401();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1401();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2401();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MinimizeOutline = hmr(MinimizeOutline, () => MinimizeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MinimizeOutline[HMR].source;
    set(MinimizeOutline[HMR].source, module.default[HMR].original);
  });
}
var MinimizeOutline_default = MinimizeOutline;
mark_module_end(MinimizeOutline);

// node_modules/flowbite-svelte-icons/dist/MinusOutline.svelte
mark_module_start();
MinusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MinusOutline.svelte";
var root_1402 = add_locations(ns_template(`<title> </title>`), MinusOutline[FILENAME], [[41, 4]]);
var root_2402 = add_locations(ns_template(`<desc> </desc>`), MinusOutline[FILENAME], [[44, 4]]);
var root402 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12h14"></path></svg>`), MinusOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MinusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MinusOutline);
  validate_prop_bindings($$props, [], [], MinusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "minus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root402();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1402();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2402();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MinusOutline = hmr(MinusOutline, () => MinusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MinusOutline[HMR].source;
    set(MinusOutline[HMR].source, module.default[HMR].original);
  });
}
var MinusOutline_default = MinusOutline;
mark_module_end(MinusOutline);

// node_modules/flowbite-svelte-icons/dist/MobilePhoneOutline.svelte
mark_module_start();
MobilePhoneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MobilePhoneOutline.svelte";
var root_1403 = add_locations(ns_template(`<title> </title>`), MobilePhoneOutline[FILENAME], [[41, 4]]);
var root_2403 = add_locations(ns_template(`<desc> </desc>`), MobilePhoneOutline[FILENAME], [[44, 4]]);
var root403 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 15h12M6 6h12m-6 12h.01M7 21h10a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v16a1 1 0 0 0 1 1Z"></path></svg>`), MobilePhoneOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MobilePhoneOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MobilePhoneOutline);
  validate_prop_bindings($$props, [], [], MobilePhoneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "mobile phone outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root403();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1403();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2403();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MobilePhoneOutline = hmr(MobilePhoneOutline, () => MobilePhoneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MobilePhoneOutline[HMR].source;
    set(MobilePhoneOutline[HMR].source, module.default[HMR].original);
  });
}
var MobilePhoneOutline_default = MobilePhoneOutline;
mark_module_end(MobilePhoneOutline);

// node_modules/flowbite-svelte-icons/dist/MobilePhoneSolid.svelte
mark_module_start();
MobilePhoneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MobilePhoneSolid.svelte";
var root_1404 = add_locations(ns_template(`<title> </title>`), MobilePhoneSolid[FILENAME], [[39, 4]]);
var root_2404 = add_locations(ns_template(`<desc> </desc>`), MobilePhoneSolid[FILENAME], [[42, 4]]);
var root404 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 4a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V4Zm12 12V5H7v11h10Zm-5 1a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H12Z" clip-rule="evenodd"></path></svg>`), MobilePhoneSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MobilePhoneSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MobilePhoneSolid);
  validate_prop_bindings($$props, [], [], MobilePhoneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "mobile phone solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root404();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1404();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2404();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MobilePhoneSolid = hmr(MobilePhoneSolid, () => MobilePhoneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MobilePhoneSolid[HMR].source;
    set(MobilePhoneSolid[HMR].source, module.default[HMR].original);
  });
}
var MobilePhoneSolid_default = MobilePhoneSolid;
mark_module_end(MobilePhoneSolid);

// node_modules/flowbite-svelte-icons/dist/MongoDbSolid.svelte
mark_module_start();
MongoDbSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MongoDbSolid.svelte";
var root_1405 = add_locations(ns_template(`<title> </title>`), MongoDbSolid[FILENAME], [[39, 4]]);
var root_2405 = add_locations(ns_template(`<desc> </desc>`), MongoDbSolid[FILENAME], [[42, 4]]);
var root405 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" fill-rule="evenodd" d="M7.29395 11.8039c0-3.96638 2.13959-6.41723 3.53335-8.01378.6733-.7712 1.1725-1.34306 1.1725-1.79012 0 .44706.4993 1.01892 1.1725 1.79013 1.3938 1.59654 3.5334 4.04739 3.5334 8.01377 0 4.3266-2.7501 6.9507-4.0764 7.7654L12.3701 22h-.7071l-.2906-2.4295c-1.3255-.8132-4.07845-3.4378-4.07845-7.7666Zm4.06395 6.7007.6419-9.44578.649 9.44578-.649.7503-.6419-.7503Z" clip-rule="evenodd"></path></svg>`), MongoDbSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MongoDbSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MongoDbSolid);
  validate_prop_bindings($$props, [], [], MongoDbSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "mongo db solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root405();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1405();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2405();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MongoDbSolid = hmr(MongoDbSolid, () => MongoDbSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MongoDbSolid[HMR].source;
    set(MongoDbSolid[HMR].source, module.default[HMR].original);
  });
}
var MongoDbSolid_default = MongoDbSolid;
mark_module_end(MongoDbSolid);

// node_modules/flowbite-svelte-icons/dist/MoonOutline.svelte
mark_module_start();
MoonOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MoonOutline.svelte";
var root_1406 = add_locations(ns_template(`<title> </title>`), MoonOutline[FILENAME], [[41, 4]]);
var root_2406 = add_locations(ns_template(`<desc> </desc>`), MoonOutline[FILENAME], [[44, 4]]);
var root406 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 21a9 9 0 0 1-.5-17.986V3c-.354.966-.5 1.911-.5 3a9 9 0 0 0 9 9c.239 0 .254.018.488 0A9.004 9.004 0 0 1 12 21Z"></path></svg>`), MoonOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function MoonOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MoonOutline);
  validate_prop_bindings($$props, [], [], MoonOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "moon outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root406();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1406();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2406();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MoonOutline = hmr(MoonOutline, () => MoonOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MoonOutline[HMR].source;
    set(MoonOutline[HMR].source, module.default[HMR].original);
  });
}
var MoonOutline_default = MoonOutline;
mark_module_end(MoonOutline);

// node_modules/flowbite-svelte-icons/dist/MoonSolid.svelte
mark_module_start();
MoonSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/MoonSolid.svelte";
var root_1407 = add_locations(ns_template(`<title> </title>`), MoonSolid[FILENAME], [[39, 4]]);
var root_2407 = add_locations(ns_template(`<desc> </desc>`), MoonSolid[FILENAME], [[42, 4]]);
var root407 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M11.675 2.015a.998.998 0 0 0-.403.011C6.09 2.4 2 6.722 2 12c0 5.523 4.477 10 10 10 4.356 0 8.058-2.784 9.43-6.667a1 1 0 0 0-1.02-1.33c-.08.006-.105.005-.127.005h-.001l-.028-.002A5.227 5.227 0 0 0 20 14a8 8 0 0 1-8-8c0-.952.121-1.752.404-2.558a.996.996 0 0 0 .096-.428V3a1 1 0 0 0-.825-.985Z" clip-rule="evenodd"></path></svg>`), MoonSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function MoonSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, MoonSolid);
  validate_prop_bindings($$props, [], [], MoonSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "moon solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root407();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1407();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2407();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  MoonSolid = hmr(MoonSolid, () => MoonSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = MoonSolid[HMR].source;
    set(MoonSolid[HMR].source, module.default[HMR].original);
  });
}
var MoonSolid_default = MoonSolid;
mark_module_end(MoonSolid);

// node_modules/flowbite-svelte-icons/dist/NewspaperOutline.svelte
mark_module_start();
NewspaperOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/NewspaperOutline.svelte";
var root_1408 = add_locations(ns_template(`<title> </title>`), NewspaperOutline[FILENAME], [[41, 4]]);
var root_2408 = add_locations(ns_template(`<desc> </desc>`), NewspaperOutline[FILENAME], [[44, 4]]);
var root408 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M19 7h1v12a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h11.5M7 14h6m-6 3h6m0-10h.5m-.5 3h.5M7 7h3v3H7V7Z"></path></svg>`), NewspaperOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function NewspaperOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, NewspaperOutline);
  validate_prop_bindings($$props, [], [], NewspaperOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "newspaper outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root408();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1408();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2408();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NewspaperOutline = hmr(NewspaperOutline, () => NewspaperOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NewspaperOutline[HMR].source;
    set(NewspaperOutline[HMR].source, module.default[HMR].original);
  });
}
var NewspaperOutline_default = NewspaperOutline;
mark_module_end(NewspaperOutline);

// node_modules/flowbite-svelte-icons/dist/NewspaperSolid.svelte
mark_module_start();
NewspaperSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/NewspaperSolid.svelte";
var root_1409 = add_locations(ns_template(`<title> </title>`), NewspaperSolid[FILENAME], [[39, 4]]);
var root_2409 = add_locations(ns_template(`<desc> </desc>`), NewspaperSolid[FILENAME], [[42, 4]]);
var root409 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11.5c.07 0 .14-.007.207-.021.095.014.193.021.293.021h2a2 2 0 0 0 2-2V7a1 1 0 0 0-1-1h-1a1 1 0 1 0 0 2v11h-2V5a2 2 0 0 0-2-2H5Zm7 4a1 1 0 0 1 1-1h.5a1 1 0 1 1 0 2H13a1 1 0 0 1-1-1Zm0 3a1 1 0 0 1 1-1h.5a1 1 0 1 1 0 2H13a1 1 0 0 1-1-1Zm-6 4a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H7a1 1 0 0 1-1-1Zm0 3a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H7a1 1 0 0 1-1-1ZM7 6a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1H7Zm1 3V8h1v1H8Z" clip-rule="evenodd"></path></svg>`), NewspaperSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function NewspaperSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, NewspaperSolid);
  validate_prop_bindings($$props, [], [], NewspaperSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "newspaper solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root409();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1409();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2409();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NewspaperSolid = hmr(NewspaperSolid, () => NewspaperSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NewspaperSolid[HMR].source;
    set(NewspaperSolid[HMR].source, module.default[HMR].original);
  });
}
var NewspaperSolid_default = NewspaperSolid;
mark_module_end(NewspaperSolid);

// node_modules/flowbite-svelte-icons/dist/NpmSolid.svelte
mark_module_start();
NpmSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/NpmSolid.svelte";
var root_1410 = add_locations(ns_template(`<title> </title>`), NpmSolid[FILENAME], [[40, 4]]);
var root_2410 = add_locations(ns_template(`<desc> </desc>`), NpmSolid[FILENAME], [[43, 4]]);
var root410 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 3.87H4v16h8v-13h5v13h3v-16h-8Z"></path></svg>`), NpmSolid[FILENAME], [[30, 0, [[45, 2]]]]);
function NpmSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, NpmSolid);
  validate_prop_bindings($$props, [], [], NpmSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "npm solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root410();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1410();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2410();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  NpmSolid = hmr(NpmSolid, () => NpmSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = NpmSolid[HMR].source;
    set(NpmSolid[HMR].source, module.default[HMR].original);
  });
}
var NpmSolid_default = NpmSolid;
mark_module_end(NpmSolid);

// node_modules/flowbite-svelte-icons/dist/ObjectsColumnOutline.svelte
mark_module_start();
ObjectsColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ObjectsColumnOutline.svelte";
var root_1411 = add_locations(ns_template(`<title> </title>`), ObjectsColumnOutline[FILENAME], [[41, 4]]);
var root_2411 = add_locations(ns_template(`<desc> </desc>`), ObjectsColumnOutline[FILENAME], [[44, 4]]);
var root411 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M4 5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V5Zm16 14a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2ZM4 13a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-6Zm16-2a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v6Z"></path></svg>`), ObjectsColumnOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ObjectsColumnOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ObjectsColumnOutline);
  validate_prop_bindings($$props, [], [], ObjectsColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "objects column outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root411();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1411();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2411();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ObjectsColumnOutline = hmr(ObjectsColumnOutline, () => ObjectsColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ObjectsColumnOutline[HMR].source;
    set(ObjectsColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var ObjectsColumnOutline_default = ObjectsColumnOutline;
mark_module_end(ObjectsColumnOutline);

// node_modules/flowbite-svelte-icons/dist/ObjectsColumnSolid.svelte
mark_module_start();
ObjectsColumnSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ObjectsColumnSolid.svelte";
var root_1412 = add_locations(ns_template(`<title> </title>`), ObjectsColumnSolid[FILENAME], [[39, 4]]);
var root_2412 = add_locations(ns_template(`<desc> </desc>`), ObjectsColumnSolid[FILENAME], [[42, 4]]);
var root412 = add_locations(ns_template(`<svg><!><!><path d="M5 3a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2H5Zm14 18a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h4ZM5 11a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2H5Zm14 2a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h4Z"></path></svg>`), ObjectsColumnSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ObjectsColumnSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ObjectsColumnSolid);
  validate_prop_bindings($$props, [], [], ObjectsColumnSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "objects column solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root412();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1412();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2412();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ObjectsColumnSolid = hmr(ObjectsColumnSolid, () => ObjectsColumnSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ObjectsColumnSolid[HMR].source;
    set(ObjectsColumnSolid[HMR].source, module.default[HMR].original);
  });
}
var ObjectsColumnSolid_default = ObjectsColumnSolid;
mark_module_end(ObjectsColumnSolid);

// node_modules/flowbite-svelte-icons/dist/OpenDoorOutline.svelte
mark_module_start();
OpenDoorOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OpenDoorOutline.svelte";
var root_1413 = add_locations(ns_template(`<title> </title>`), OpenDoorOutline[FILENAME], [[41, 4]]);
var root_2413 = add_locations(ns_template(`<desc> </desc>`), OpenDoorOutline[FILENAME], [[44, 4]]);
var root413 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18 18V6h-5v12h5Zm0 0h2M4 18h2.5m3.5-5.5V12M6 6l7-2v16l-7-2V6Z"></path></svg>`), OpenDoorOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function OpenDoorOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, OpenDoorOutline);
  validate_prop_bindings($$props, [], [], OpenDoorOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "open door outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root413();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1413();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2413();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OpenDoorOutline = hmr(OpenDoorOutline, () => OpenDoorOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OpenDoorOutline[HMR].source;
    set(OpenDoorOutline[HMR].source, module.default[HMR].original);
  });
}
var OpenDoorOutline_default = OpenDoorOutline;
mark_module_end(OpenDoorOutline);

// node_modules/flowbite-svelte-icons/dist/OpenDoorSolid.svelte
mark_module_start();
OpenDoorSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OpenDoorSolid.svelte";
var root_1414 = add_locations(ns_template(`<title> </title>`), OpenDoorSolid[FILENAME], [[39, 4]]);
var root_2414 = add_locations(ns_template(`<desc> </desc>`), OpenDoorSolid[FILENAME], [[42, 4]]);
var root414 = add_locations(ns_template(`<svg><!><!><path d="M14 19V5h4a1 1 0 0 1 1 1v11h1a1 1 0 0 1 0 2h-6Z"></path><path fill-rule="evenodd" d="M12 4.571a1 1 0 0 0-1.275-.961l-5 1.428A1 1 0 0 0 5 6v11H4a1 1 0 0 0 0 2h1.86l4.865 1.39A1 1 0 0 0 12 19.43V4.57ZM10 11a1 1 0 0 1 1 1v.5a1 1 0 0 1-2 0V12a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path></svg>`), OpenDoorSolid[FILENAME], [
  [29, 0, [[44, 2], [45, 2]]]
]);
function OpenDoorSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, OpenDoorSolid);
  validate_prop_bindings($$props, [], [], OpenDoorSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "open door solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root414();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1414();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2414();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OpenDoorSolid = hmr(OpenDoorSolid, () => OpenDoorSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OpenDoorSolid[HMR].source;
    set(OpenDoorSolid[HMR].source, module.default[HMR].original);
  });
}
var OpenDoorSolid_default = OpenDoorSolid;
mark_module_end(OpenDoorSolid);

// node_modules/flowbite-svelte-icons/dist/OrderedListOutline.svelte
mark_module_start();
OrderedListOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OrderedListOutline.svelte";
var root_1415 = add_locations(ns_template(`<title> </title>`), OrderedListOutline[FILENAME], [[41, 4]]);
var root_2415 = add_locations(ns_template(`<desc> </desc>`), OrderedListOutline[FILENAME], [[44, 4]]);
var root415 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 6h8m-8 6h8m-8 6h8M4 16a2 2 0 1 1 3.321 1.5L4 20h5M4 5l2-1v6m-2 0h4"></path></svg>`), OrderedListOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function OrderedListOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, OrderedListOutline);
  validate_prop_bindings($$props, [], [], OrderedListOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "ordered list outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root415();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1415();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2415();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OrderedListOutline = hmr(OrderedListOutline, () => OrderedListOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OrderedListOutline[HMR].source;
    set(OrderedListOutline[HMR].source, module.default[HMR].original);
  });
}
var OrderedListOutline_default = OrderedListOutline;
mark_module_end(OrderedListOutline);

// node_modules/flowbite-svelte-icons/dist/OutdentOutline.svelte
mark_module_start();
OutdentOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OutdentOutline.svelte";
var root_1416 = add_locations(ns_template(`<title> </title>`), OutdentOutline[FILENAME], [[41, 4]]);
var root_2416 = add_locations(ns_template(`<desc> </desc>`), OutdentOutline[FILENAME], [[44, 4]]);
var root416 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 6h12M6 18h12m-5-8h5m-5 4h5M9.5 9v6L6 12l3.5-3Z"></path></svg>`), OutdentOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function OutdentOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, OutdentOutline);
  validate_prop_bindings($$props, [], [], OutdentOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "outdent outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root416();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1416();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2416();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OutdentOutline = hmr(OutdentOutline, () => OutdentOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OutdentOutline[HMR].source;
    set(OutdentOutline[HMR].source, module.default[HMR].original);
  });
}
var OutdentOutline_default = OutdentOutline;
mark_module_end(OutdentOutline);

// node_modules/flowbite-svelte-icons/dist/OutdentSolid.svelte
mark_module_start();
OutdentSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/OutdentSolid.svelte";
var root_1417 = add_locations(ns_template(`<title> </title>`), OutdentSolid[FILENAME], [[39, 4]]);
var root_2417 = add_locations(ns_template(`<desc> </desc>`), OutdentSolid[FILENAME], [[42, 4]]);
var root417 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 6a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm0 12a1 1 0 0 1 1-1h12a1 1 0 1 1 0 2H6a1 1 0 0 1-1-1Zm3.85-9.76A1 1 0 0 1 10.5 9v6a1 1 0 0 1-1.65.76l-3.5-3a1 1 0 0 1 0-1.52l3.5-3ZM12 10a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Zm0 4a1 1 0 0 1 1-1h5a1 1 0 1 1 0 2h-5a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), OutdentSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function OutdentSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, OutdentSolid);
  validate_prop_bindings($$props, [], [], OutdentSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "outdent solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root417();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1417();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2417();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  OutdentSolid = hmr(OutdentSolid, () => OutdentSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = OutdentSolid[HMR].source;
    set(OutdentSolid[HMR].source, module.default[HMR].original);
  });
}
var OutdentSolid_default = OutdentSolid;
mark_module_end(OutdentSolid);

// node_modules/flowbite-svelte-icons/dist/PaletteOutline.svelte
mark_module_start();
PaletteOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaletteOutline.svelte";
var root_1418 = add_locations(ns_template(`<title> </title>`), PaletteOutline[FILENAME], [[41, 4]]);
var root_2418 = add_locations(ns_template(`<desc> </desc>`), PaletteOutline[FILENAME], [[44, 4]]);
var root418 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 7h.01m3.486 1.513h.01m-6.978 0h.01M6.99 12H7m9 4h2.706a1.957 1.957 0 0 0 1.883-1.325A9 9 0 1 0 3.043 12.89 9.1 9.1 0 0 0 8.2 20.1a8.62 8.62 0 0 0 3.769.9 2.013 2.013 0 0 0 2.03-2v-.857A2.036 2.036 0 0 1 16 16Z"></path></svg>`), PaletteOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PaletteOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PaletteOutline);
  validate_prop_bindings($$props, [], [], PaletteOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "palette outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root418();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1418();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2418();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaletteOutline = hmr(PaletteOutline, () => PaletteOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaletteOutline[HMR].source;
    set(PaletteOutline[HMR].source, module.default[HMR].original);
  });
}
var PaletteOutline_default = PaletteOutline;
mark_module_end(PaletteOutline);

// node_modules/flowbite-svelte-icons/dist/PaletteSolid.svelte
mark_module_start();
PaletteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaletteSolid.svelte";
var root_1419 = add_locations(ns_template(`<title> </title>`), PaletteSolid[FILENAME], [[39, 4]]);
var root_2419 = add_locations(ns_template(`<desc> </desc>`), PaletteSolid[FILENAME], [[42, 4]]);
var root419 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2h-1v3a1 1 0 1 1-2 0v-3h-1v3a1 1 0 1 1-2 0v-3h-1v3a1 1 0 1 1-2 0v-3H7a1 1 0 1 1 0-2h3v-1H7a1 1 0 1 1 0-2h3V8H7a1 1 0 0 1 0-2h3V5a2 2 0 0 0-2-2H5Z" clip-rule="evenodd"></path></svg>`), PaletteSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function PaletteSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PaletteSolid);
  validate_prop_bindings($$props, [], [], PaletteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "palette solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root419();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1419();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2419();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaletteSolid = hmr(PaletteSolid, () => PaletteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaletteSolid[HMR].source;
    set(PaletteSolid[HMR].source, module.default[HMR].original);
  });
}
var PaletteSolid_default = PaletteSolid;
mark_module_end(PaletteSolid);

// node_modules/flowbite-svelte-icons/dist/PaperClipOutline.svelte
mark_module_start();
PaperClipOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaperClipOutline.svelte";
var root_1420 = add_locations(ns_template(`<title> </title>`), PaperClipOutline[FILENAME], [[41, 4]]);
var root_2420 = add_locations(ns_template(`<desc> </desc>`), PaperClipOutline[FILENAME], [[44, 4]]);
var root420 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 8v8a5 5 0 1 0 10 0V6.5a3.5 3.5 0 1 0-7 0V15a2 2 0 0 0 4 0V8"></path></svg>`), PaperClipOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PaperClipOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PaperClipOutline);
  validate_prop_bindings($$props, [], [], PaperClipOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "paper clip outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root420();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1420();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2420();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaperClipOutline = hmr(PaperClipOutline, () => PaperClipOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaperClipOutline[HMR].source;
    set(PaperClipOutline[HMR].source, module.default[HMR].original);
  });
}
var PaperClipOutline_default = PaperClipOutline;
mark_module_end(PaperClipOutline);

// node_modules/flowbite-svelte-icons/dist/PaperPlaneOutline.svelte
mark_module_start();
PaperPlaneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaperPlaneOutline.svelte";
var root_1421 = add_locations(ns_template(`<title> </title>`), PaperPlaneOutline[FILENAME], [[41, 4]]);
var root_2421 = add_locations(ns_template(`<desc> </desc>`), PaperPlaneOutline[FILENAME], [[44, 4]]);
var root421 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m12 18-7 3 7-18 7 18-7-3Zm0 0v-5"></path></svg>`), PaperPlaneOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PaperPlaneOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PaperPlaneOutline);
  validate_prop_bindings($$props, [], [], PaperPlaneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "paper plane outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root421();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1421();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2421();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaperPlaneOutline = hmr(PaperPlaneOutline, () => PaperPlaneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaperPlaneOutline[HMR].source;
    set(PaperPlaneOutline[HMR].source, module.default[HMR].original);
  });
}
var PaperPlaneOutline_default = PaperPlaneOutline;
mark_module_end(PaperPlaneOutline);

// node_modules/flowbite-svelte-icons/dist/PaperPlaneSolid.svelte
mark_module_start();
PaperPlaneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PaperPlaneSolid.svelte";
var root_1422 = add_locations(ns_template(`<title> </title>`), PaperPlaneSolid[FILENAME], [[39, 4]]);
var root_2422 = add_locations(ns_template(`<desc> </desc>`), PaperPlaneSolid[FILENAME], [[42, 4]]);
var root422 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 2a1 1 0 0 1 .932.638l7 18a1 1 0 0 1-1.326 1.281L13 19.517V13a1 1 0 1 0-2 0v6.517l-5.606 2.402a1 1 0 0 1-1.326-1.281l7-18A1 1 0 0 1 12 2Z" clip-rule="evenodd"></path></svg>`), PaperPlaneSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function PaperPlaneSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PaperPlaneSolid);
  validate_prop_bindings($$props, [], [], PaperPlaneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "paper plane solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root422();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1422();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2422();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PaperPlaneSolid = hmr(PaperPlaneSolid, () => PaperPlaneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PaperPlaneSolid[HMR].source;
    set(PaperPlaneSolid[HMR].source, module.default[HMR].original);
  });
}
var PaperPlaneSolid_default = PaperPlaneSolid;
mark_module_end(PaperPlaneSolid);

// node_modules/flowbite-svelte-icons/dist/ParagraphOutline.svelte
mark_module_start();
ParagraphOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ParagraphOutline.svelte";
var root_1423 = add_locations(ns_template(`<title> </title>`), ParagraphOutline[FILENAME], [[41, 4]]);
var root_2423 = add_locations(ns_template(`<desc> </desc>`), ParagraphOutline[FILENAME], [[44, 4]]);
var root423 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5v7m0 7v-7m4-7v14m3-14H8.5A3.5 3.5 0 0 0 5 8.5v0A3.5 3.5 0 0 0 8.5 12H12"></path></svg>`), ParagraphOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ParagraphOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ParagraphOutline);
  validate_prop_bindings($$props, [], [], ParagraphOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "paragraph outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root423();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1423();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2423();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ParagraphOutline = hmr(ParagraphOutline, () => ParagraphOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ParagraphOutline[HMR].source;
    set(ParagraphOutline[HMR].source, module.default[HMR].original);
  });
}
var ParagraphOutline_default = ParagraphOutline;
mark_module_end(ParagraphOutline);

// node_modules/flowbite-svelte-icons/dist/ParagraphSolid.svelte
mark_module_start();
ParagraphSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ParagraphSolid.svelte";
var root_1424 = add_locations(ns_template(`<title> </title>`), ParagraphSolid[FILENAME], [[39, 4]]);
var root_2424 = add_locations(ns_template(`<desc> </desc>`), ParagraphSolid[FILENAME], [[42, 4]]);
var root424 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8.5 4a4.5 4.5 0 0 0 0 9H11v6a1 1 0 1 0 2 0V6h2v13a1 1 0 1 0 2 0V6h2a1 1 0 1 0 0-2H8.5Z" clip-rule="evenodd"></path></svg>`), ParagraphSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ParagraphSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ParagraphSolid);
  validate_prop_bindings($$props, [], [], ParagraphSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "paragraph solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root424();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1424();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2424();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ParagraphSolid = hmr(ParagraphSolid, () => ParagraphSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ParagraphSolid[HMR].source;
    set(ParagraphSolid[HMR].source, module.default[HMR].original);
  });
}
var ParagraphSolid_default = ParagraphSolid;
mark_module_end(ParagraphSolid);

// node_modules/flowbite-svelte-icons/dist/PauseOutline.svelte
mark_module_start();
PauseOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PauseOutline.svelte";
var root_1425 = add_locations(ns_template(`<title> </title>`), PauseOutline[FILENAME], [[41, 4]]);
var root_2425 = add_locations(ns_template(`<desc> </desc>`), PauseOutline[FILENAME], [[44, 4]]);
var root425 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 6H8a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Zm7 0h-1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Z"></path></svg>`), PauseOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PauseOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PauseOutline);
  validate_prop_bindings($$props, [], [], PauseOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "pause outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root425();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1425();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2425();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PauseOutline = hmr(PauseOutline, () => PauseOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PauseOutline[HMR].source;
    set(PauseOutline[HMR].source, module.default[HMR].original);
  });
}
var PauseOutline_default = PauseOutline;
mark_module_end(PauseOutline);

// node_modules/flowbite-svelte-icons/dist/PauseSolid.svelte
mark_module_start();
PauseSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PauseSolid.svelte";
var root_1426 = add_locations(ns_template(`<title> </title>`), PauseSolid[FILENAME], [[39, 4]]);
var root_2426 = add_locations(ns_template(`<desc> </desc>`), PauseSolid[FILENAME], [[42, 4]]);
var root426 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2H8Zm7 0a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-1Z" clip-rule="evenodd"></path></svg>`), PauseSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function PauseSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PauseSolid);
  validate_prop_bindings($$props, [], [], PauseSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "pause solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root426();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1426();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2426();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PauseSolid = hmr(PauseSolid, () => PauseSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PauseSolid[HMR].source;
    set(PauseSolid[HMR].source, module.default[HMR].original);
  });
}
var PauseSolid_default = PauseSolid;
mark_module_end(PauseSolid);

// node_modules/flowbite-svelte-icons/dist/PenNibOutline.svelte
mark_module_start();
PenNibOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PenNibOutline.svelte";
var root_1427 = add_locations(ns_template(`<title> </title>`), PenNibOutline[FILENAME], [[41, 4]]);
var root_2427 = add_locations(ns_template(`<desc> </desc>`), PenNibOutline[FILENAME], [[44, 4]]);
var root427 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m4.988 19.012 5.41-5.41m2.366-6.424 4.058 4.058-2.03 5.41L5.3 20 4 18.701l3.355-9.494 5.41-2.029Zm4.626 4.625L12.197 6.61 14.807 4 20 9.194l-2.61 2.61Z"></path></svg>`), PenNibOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PenNibOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PenNibOutline);
  validate_prop_bindings($$props, [], [], PenNibOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "pen nib outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root427();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1427();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2427();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PenNibOutline = hmr(PenNibOutline, () => PenNibOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PenNibOutline[HMR].source;
    set(PenNibOutline[HMR].source, module.default[HMR].original);
  });
}
var PenNibOutline_default = PenNibOutline;
mark_module_end(PenNibOutline);

// node_modules/flowbite-svelte-icons/dist/PenNibSolid.svelte
mark_module_start();
PenNibSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PenNibSolid.svelte";
var root_1428 = add_locations(ns_template(`<title> </title>`), PenNibSolid[FILENAME], [[39, 4]]);
var root_2428 = add_locations(ns_template(`<desc> </desc>`), PenNibSolid[FILENAME], [[42, 4]]);
var root428 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M15.514 3.293a1 1 0 0 0-1.415 0L12.151 5.24a.93.93 0 0 1 .056.052l6.5 6.5a.97.97 0 0 1 .052.056L20.707 9.9a1 1 0 0 0 0-1.415l-5.193-5.193ZM7.004 8.27l3.892-1.46 6.293 6.293-1.46 3.893a1 1 0 0 1-.603.591l-9.494 3.355a1 1 0 0 1-.98-.18l6.452-6.453a1 1 0 0 0-1.414-1.414l-6.453 6.452a1 1 0 0 1-.18-.98l3.355-9.494a1 1 0 0 1 .591-.603Z" clip-rule="evenodd"></path></svg>`), PenNibSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function PenNibSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PenNibSolid);
  validate_prop_bindings($$props, [], [], PenNibSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "pen nib solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root428();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1428();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2428();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PenNibSolid = hmr(PenNibSolid, () => PenNibSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PenNibSolid[HMR].source;
    set(PenNibSolid[HMR].source, module.default[HMR].original);
  });
}
var PenNibSolid_default = PenNibSolid;
mark_module_end(PenNibSolid);

// node_modules/flowbite-svelte-icons/dist/PenOutline.svelte
mark_module_start();
PenOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PenOutline.svelte";
var root_1429 = add_locations(ns_template(`<title> </title>`), PenOutline[FILENAME], [[41, 4]]);
var root_2429 = add_locations(ns_template(`<desc> </desc>`), PenOutline[FILENAME], [[44, 4]]);
var root429 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10.779 17.779 4.36 19.918 6.5 13.5m4.279 4.279 8.364-8.643a3.027 3.027 0 0 0-2.14-5.165 3.03 3.03 0 0 0-2.14.886L6.5 13.5m4.279 4.279L6.499 13.5m2.14 2.14 6.213-6.504M12.75 7.04 17 11.28"></path></svg>`), PenOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PenOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PenOutline);
  validate_prop_bindings($$props, [], [], PenOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "pen outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root429();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1429();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2429();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PenOutline = hmr(PenOutline, () => PenOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PenOutline[HMR].source;
    set(PenOutline[HMR].source, module.default[HMR].original);
  });
}
var PenOutline_default = PenOutline;
mark_module_end(PenOutline);

// node_modules/flowbite-svelte-icons/dist/PenSolid.svelte
mark_module_start();
PenSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PenSolid.svelte";
var root_1430 = add_locations(ns_template(`<title> </title>`), PenSolid[FILENAME], [[39, 4]]);
var root_2430 = add_locations(ns_template(`<desc> </desc>`), PenSolid[FILENAME], [[42, 4]]);
var root430 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M14 4.182A4.136 4.136 0 0 1 16.9 3c1.087 0 2.13.425 2.899 1.182A4.01 4.01 0 0 1 21 7.037c0 1.068-.43 2.092-1.194 2.849L18.5 11.214l-5.8-5.71 1.287-1.31.012-.012Zm-2.717 2.763L6.186 12.13l2.175 2.141 5.063-5.218-2.141-2.108Zm-6.25 6.886-1.98 5.849a.992.992 0 0 0 .245 1.026 1.03 1.03 0 0 0 1.043.242L10.282 19l-5.25-5.168Zm6.954 4.01 5.096-5.186-2.218-2.183-5.063 5.218 2.185 2.15Z" clip-rule="evenodd"></path></svg>`), PenSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function PenSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PenSolid);
  validate_prop_bindings($$props, [], [], PenSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "pen solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root430();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1430();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2430();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PenSolid = hmr(PenSolid, () => PenSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PenSolid[HMR].source;
    set(PenSolid[HMR].source, module.default[HMR].original);
  });
}
var PenSolid_default = PenSolid;
mark_module_end(PenSolid);

// node_modules/flowbite-svelte-icons/dist/PhoneHangupOutline.svelte
mark_module_start();
PhoneHangupOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PhoneHangupOutline.svelte";
var root_1431 = add_locations(ns_template(`<title> </title>`), PhoneHangupOutline[FILENAME], [[41, 4]]);
var root_2431 = add_locations(ns_template(`<desc> </desc>`), PhoneHangupOutline[FILENAME], [[44, 4]]);
var root431 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5.693 16.013H7.31a1.685 1.685 0 0 0 1.685-1.684v-.645A1.684 1.684 0 0 1 10.679 12h2.647a1.686 1.686 0 0 1 1.686 1.686v.646c0 .446.178.875.494 1.19.316.317.693.495 1.14.495h1.685a1.556 1.556 0 0 0 1.597-1.016c.078-.214.107-.776.088-1.002.014-4.415-3.571-6.003-8-6.004-4.427 0-8.014 1.585-8.01 5.996-.02.227.009.79.087 1.003a1.558 1.558 0 0 0 1.6 1.02Z"></path></svg>`), PhoneHangupOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PhoneHangupOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PhoneHangupOutline);
  validate_prop_bindings($$props, [], [], PhoneHangupOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "phone hangup outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root431();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1431();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2431();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PhoneHangupOutline = hmr(PhoneHangupOutline, () => PhoneHangupOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PhoneHangupOutline[HMR].source;
    set(PhoneHangupOutline[HMR].source, module.default[HMR].original);
  });
}
var PhoneHangupOutline_default = PhoneHangupOutline;
mark_module_end(PhoneHangupOutline);

// node_modules/flowbite-svelte-icons/dist/PhoneHangupSolid.svelte
mark_module_start();
PhoneHangupSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PhoneHangupSolid.svelte";
var root_1432 = add_locations(ns_template(`<title> </title>`), PhoneHangupSolid[FILENAME], [[39, 4]]);
var root_2432 = add_locations(ns_template(`<desc> </desc>`), PhoneHangupSolid[FILENAME], [[42, 4]]);
var root432 = add_locations(ns_template(`<svg><!><!><path d="M12.017 6.995c-2.306 0-4.534.408-6.215 1.507-1.737 1.135-2.788 2.944-2.797 5.451a4.8 4.8 0 0 0 .01.62c.015.193.047.512.138.763a2.557 2.557 0 0 0 2.579 1.677H7.31a2.685 2.685 0 0 0 2.685-2.684v-.645a.684.684 0 0 1 .684-.684h2.647a.686.686 0 0 1 .686.687v.645c0 .712.284 1.395.787 1.898.478.478 1.101.787 1.847.787h1.647a2.555 2.555 0 0 0 2.575-1.674c.09-.25.123-.57.137-.763.015-.2.022-.433.01-.617-.002-2.508-1.049-4.32-2.785-5.458-1.68-1.1-3.907-1.51-6.213-1.51Z"></path></svg>`), PhoneHangupSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function PhoneHangupSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PhoneHangupSolid);
  validate_prop_bindings($$props, [], [], PhoneHangupSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "phone hangup solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root432();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1432();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2432();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PhoneHangupSolid = hmr(PhoneHangupSolid, () => PhoneHangupSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PhoneHangupSolid[HMR].source;
    set(PhoneHangupSolid[HMR].source, module.default[HMR].original);
  });
}
var PhoneHangupSolid_default = PhoneHangupSolid;
mark_module_end(PhoneHangupSolid);

// node_modules/flowbite-svelte-icons/dist/PhoneOutline.svelte
mark_module_start();
PhoneOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PhoneOutline.svelte";
var root_1433 = add_locations(ns_template(`<title> </title>`), PhoneOutline[FILENAME], [[41, 4]]);
var root_2433 = add_locations(ns_template(`<desc> </desc>`), PhoneOutline[FILENAME], [[44, 4]]);
var root433 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.427 14.768 17.2 13.542a1.733 1.733 0 0 0-2.45 0l-.613.613a1.732 1.732 0 0 1-2.45 0l-1.838-1.84a1.735 1.735 0 0 1 0-2.452l.612-.613a1.735 1.735 0 0 0 0-2.452L9.237 5.572a1.6 1.6 0 0 0-2.45 0c-3.223 3.2-1.702 6.896 1.519 10.117 3.22 3.221 6.914 4.745 10.12 1.535a1.601 1.601 0 0 0 0-2.456Z"></path></svg>`), PhoneOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PhoneOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PhoneOutline);
  validate_prop_bindings($$props, [], [], PhoneOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "phone outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root433();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1433();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2433();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PhoneOutline = hmr(PhoneOutline, () => PhoneOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PhoneOutline[HMR].source;
    set(PhoneOutline[HMR].source, module.default[HMR].original);
  });
}
var PhoneOutline_default = PhoneOutline;
mark_module_end(PhoneOutline);

// node_modules/flowbite-svelte-icons/dist/PhoneSolid.svelte
mark_module_start();
PhoneSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PhoneSolid.svelte";
var root_1434 = add_locations(ns_template(`<title> </title>`), PhoneSolid[FILENAME], [[39, 4]]);
var root_2434 = add_locations(ns_template(`<desc> </desc>`), PhoneSolid[FILENAME], [[42, 4]]);
var root434 = add_locations(ns_template(`<svg><!><!><path d="M7.978 4a2.553 2.553 0 0 0-1.926.877C4.233 6.7 3.699 8.751 4.153 10.814c.44 1.995 1.778 3.893 3.456 5.572 1.68 1.679 3.577 3.018 5.57 3.459 2.062.456 4.115-.073 5.94-1.885a2.556 2.556 0 0 0 .001-3.861l-1.21-1.21a2.689 2.689 0 0 0-3.802 0l-.617.618a.806.806 0 0 1-1.14 0l-1.854-1.855a.807.807 0 0 1 0-1.14l.618-.62a2.692 2.692 0 0 0 0-3.803l-1.21-1.211A2.555 2.555 0 0 0 7.978 4Z"></path></svg>`), PhoneSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function PhoneSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PhoneSolid);
  validate_prop_bindings($$props, [], [], PhoneSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "phone solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root434();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1434();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2434();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PhoneSolid = hmr(PhoneSolid, () => PhoneSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PhoneSolid[HMR].source;
    set(PhoneSolid[HMR].source, module.default[HMR].original);
  });
}
var PhoneSolid_default = PhoneSolid;
mark_module_end(PhoneSolid);

// node_modules/flowbite-svelte-icons/dist/PlayOutline.svelte
mark_module_start();
PlayOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PlayOutline.svelte";
var root_1435 = add_locations(ns_template(`<title> </title>`), PlayOutline[FILENAME], [[41, 4]]);
var root_2435 = add_locations(ns_template(`<desc> </desc>`), PlayOutline[FILENAME], [[44, 4]]);
var root435 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 18V6l8 6-8 6Z"></path></svg>`), PlayOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PlayOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PlayOutline);
  validate_prop_bindings($$props, [], [], PlayOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "play outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root435();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1435();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2435();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PlayOutline = hmr(PlayOutline, () => PlayOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PlayOutline[HMR].source;
    set(PlayOutline[HMR].source, module.default[HMR].original);
  });
}
var PlayOutline_default = PlayOutline;
mark_module_end(PlayOutline);

// node_modules/flowbite-svelte-icons/dist/PlaySolid.svelte
mark_module_start();
PlaySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PlaySolid.svelte";
var root_1436 = add_locations(ns_template(`<title> </title>`), PlaySolid[FILENAME], [[39, 4]]);
var root_2436 = add_locations(ns_template(`<desc> </desc>`), PlaySolid[FILENAME], [[42, 4]]);
var root436 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8.6 5.2A1 1 0 0 0 7 6v12a1 1 0 0 0 1.6.8l8-6a1 1 0 0 0 0-1.6l-8-6Z" clip-rule="evenodd"></path></svg>`), PlaySolid[FILENAME], [[29, 0, [[44, 2]]]]);
function PlaySolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PlaySolid);
  validate_prop_bindings($$props, [], [], PlaySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "play solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root436();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1436();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2436();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PlaySolid = hmr(PlaySolid, () => PlaySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PlaySolid[HMR].source;
    set(PlaySolid[HMR].source, module.default[HMR].original);
  });
}
var PlaySolid_default = PlaySolid;
mark_module_end(PlaySolid);

// node_modules/flowbite-svelte-icons/dist/PlusOutline.svelte
mark_module_start();
PlusOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PlusOutline.svelte";
var root_1437 = add_locations(ns_template(`<title> </title>`), PlusOutline[FILENAME], [[41, 4]]);
var root_2437 = add_locations(ns_template(`<desc> </desc>`), PlusOutline[FILENAME], [[44, 4]]);
var root437 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12h14m-7 7V5"></path></svg>`), PlusOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PlusOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PlusOutline);
  validate_prop_bindings($$props, [], [], PlusOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "plus outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root437();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1437();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2437();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PlusOutline = hmr(PlusOutline, () => PlusOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PlusOutline[HMR].source;
    set(PlusOutline[HMR].source, module.default[HMR].original);
  });
}
var PlusOutline_default = PlusOutline;
mark_module_end(PlusOutline);

// node_modules/flowbite-svelte-icons/dist/PrinterOutline.svelte
mark_module_start();
PrinterOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PrinterOutline.svelte";
var root_1438 = add_locations(ns_template(`<title> </title>`), PrinterOutline[FILENAME], [[41, 4]]);
var root_2438 = add_locations(ns_template(`<desc> </desc>`), PrinterOutline[FILENAME], [[44, 4]]);
var root438 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M16.444 18H19a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h2.556M17 11V5a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v6h10ZM7 15h10v4a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1v-4Z"></path></svg>`), PrinterOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function PrinterOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PrinterOutline);
  validate_prop_bindings($$props, [], [], PrinterOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "printer outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root438();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1438();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2438();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PrinterOutline = hmr(PrinterOutline, () => PrinterOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PrinterOutline[HMR].source;
    set(PrinterOutline[HMR].source, module.default[HMR].original);
  });
}
var PrinterOutline_default = PrinterOutline;
mark_module_end(PrinterOutline);

// node_modules/flowbite-svelte-icons/dist/PrinterSolid.svelte
mark_module_start();
PrinterSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/PrinterSolid.svelte";
var root_1439 = add_locations(ns_template(`<title> </title>`), PrinterSolid[FILENAME], [[39, 4]]);
var root_2439 = add_locations(ns_template(`<desc> </desc>`), PrinterSolid[FILENAME], [[42, 4]]);
var root439 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 3a2 2 0 0 0-2 2v3h12V5a2 2 0 0 0-2-2H8Zm-3 7a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h1v-4a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v4h1a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H5Zm4 11a1 1 0 0 1-1-1v-4h8v4a1 1 0 0 1-1 1H9Z" clip-rule="evenodd"></path></svg>`), PrinterSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function PrinterSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, PrinterSolid);
  validate_prop_bindings($$props, [], [], PrinterSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "printer solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root439();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1439();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2439();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PrinterSolid = hmr(PrinterSolid, () => PrinterSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PrinterSolid[HMR].source;
    set(PrinterSolid[HMR].source, module.default[HMR].original);
  });
}
var PrinterSolid_default = PrinterSolid;
mark_module_end(PrinterSolid);

// node_modules/flowbite-svelte-icons/dist/ProfileCardOutline.svelte
mark_module_start();
ProfileCardOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ProfileCardOutline.svelte";
var root_1440 = add_locations(ns_template(`<title> </title>`), ProfileCardOutline[FILENAME], [[41, 4]]);
var root_2440 = add_locations(ns_template(`<desc> </desc>`), ProfileCardOutline[FILENAME], [[44, 4]]);
var root440 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 9h3m-3 3h3m-3 3h3m-6 1c-.306-.613-.933-1-1.618-1H7.618c-.685 0-1.312.387-1.618 1M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Zm7 5a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg>`), ProfileCardOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ProfileCardOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ProfileCardOutline);
  validate_prop_bindings($$props, [], [], ProfileCardOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "profile card outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root440();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1440();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2440();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ProfileCardOutline = hmr(ProfileCardOutline, () => ProfileCardOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ProfileCardOutline[HMR].source;
    set(ProfileCardOutline[HMR].source, module.default[HMR].original);
  });
}
var ProfileCardOutline_default = ProfileCardOutline;
mark_module_end(ProfileCardOutline);

// node_modules/flowbite-svelte-icons/dist/ProfileCardSolid.svelte
mark_module_start();
ProfileCardSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ProfileCardSolid.svelte";
var root_1441 = add_locations(ns_template(`<title> </title>`), ProfileCardSolid[FILENAME], [[39, 4]]);
var root_2441 = add_locations(ns_template(`<desc> </desc>`), ProfileCardSolid[FILENAME], [[42, 4]]);
var root441 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4Zm10 5a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm0 3a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm0 3a1 1 0 0 1 1-1h3a1 1 0 1 1 0 2h-3a1 1 0 0 1-1-1Zm-8-5a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm1.942 4a3 3 0 0 0-2.847 2.051l-.044.133-.004.012c-.042.126-.055.167-.042.195.006.013.02.023.038.039.032.025.08.064.146.155A1 1 0 0 0 6 17h6a1 1 0 0 0 .811-.415.713.713 0 0 1 .146-.155c.019-.016.031-.026.038-.04.014-.027 0-.068-.042-.194l-.004-.012-.044-.133A3 3 0 0 0 10.059 14H7.942Z" clip-rule="evenodd"></path></svg>`), ProfileCardSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ProfileCardSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ProfileCardSolid);
  validate_prop_bindings($$props, [], [], ProfileCardSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "profile card solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root441();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1441();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2441();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ProfileCardSolid = hmr(ProfileCardSolid, () => ProfileCardSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ProfileCardSolid[HMR].source;
    set(ProfileCardSolid[HMR].source, module.default[HMR].original);
  });
}
var ProfileCardSolid_default = ProfileCardSolid;
mark_module_end(ProfileCardSolid);

// node_modules/flowbite-svelte-icons/dist/QrCodeOutline.svelte
mark_module_start();
QrCodeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QrCodeOutline.svelte";
var root_1442 = add_locations(ns_template(`<title> </title>`), QrCodeOutline[FILENAME], [[41, 4]]);
var root_2442 = add_locations(ns_template(`<desc> </desc>`), QrCodeOutline[FILENAME], [[44, 4]]);
var root442 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M4 4h6v6H4V4Zm10 10h6v6h-6v-6Zm0-10h6v6h-6V4Zm-4 10h.01v.01H10V14Zm0 4h.01v.01H10V18Zm-3 2h.01v.01H7V20Zm0-4h.01v.01H7V16Zm-3 2h.01v.01H4V18Zm0-4h.01v.01H4V14Z"></path><path stroke="currentColor" stroke-linejoin="round" d="M7 7h.01v.01H7V7Zm10 10h.01v.01H17V17Z"></path></svg>`), QrCodeOutline[FILENAME], [
  [30, 0, [[46, 2], [52, 2]]]
]);
function QrCodeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, QrCodeOutline);
  validate_prop_bindings($$props, [], [], QrCodeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "qr code outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root442();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1442();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2442();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  var path_1 = sibling(path);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
    set_attribute(path_1, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  QrCodeOutline = hmr(QrCodeOutline, () => QrCodeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QrCodeOutline[HMR].source;
    set(QrCodeOutline[HMR].source, module.default[HMR].original);
  });
}
var QrCodeOutline_default = QrCodeOutline;
mark_module_end(QrCodeOutline);

// node_modules/flowbite-svelte-icons/dist/QuestionCircleOutline.svelte
mark_module_start();
QuestionCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QuestionCircleOutline.svelte";
var root_1443 = add_locations(ns_template(`<title> </title>`), QuestionCircleOutline[FILENAME], [[41, 4]]);
var root_2443 = add_locations(ns_template(`<desc> </desc>`), QuestionCircleOutline[FILENAME], [[44, 4]]);
var root443 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.529 9.988a2.502 2.502 0 1 1 5 .191A2.441 2.441 0 0 1 12 12.582V14m-.01 3.008H12M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg>`), QuestionCircleOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function QuestionCircleOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, QuestionCircleOutline);
  validate_prop_bindings($$props, [], [], QuestionCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "question circle outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root443();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1443();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2443();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  QuestionCircleOutline = hmr(QuestionCircleOutline, () => QuestionCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QuestionCircleOutline[HMR].source;
    set(QuestionCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var QuestionCircleOutline_default = QuestionCircleOutline;
mark_module_end(QuestionCircleOutline);

// node_modules/flowbite-svelte-icons/dist/QuestionCircleSolid.svelte
mark_module_start();
QuestionCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QuestionCircleSolid.svelte";
var root_1444 = add_locations(ns_template(`<title> </title>`), QuestionCircleSolid[FILENAME], [[39, 4]]);
var root_2444 = add_locations(ns_template(`<desc> </desc>`), QuestionCircleSolid[FILENAME], [[42, 4]]);
var root444 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12Zm9.008-3.018a1.502 1.502 0 0 1 2.522 1.159v.024a1.44 1.44 0 0 1-1.493 1.418 1 1 0 0 0-1.037.999V14a1 1 0 1 0 2 0v-.539a3.44 3.44 0 0 0 2.529-3.256 3.502 3.502 0 0 0-7-.255 1 1 0 0 0 2 .076c.014-.398.187-.774.48-1.044Zm.982 7.026a1 1 0 1 0 0 2H12a1 1 0 1 0 0-2h-.01Z" clip-rule="evenodd"></path></svg>`), QuestionCircleSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function QuestionCircleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, QuestionCircleSolid);
  validate_prop_bindings($$props, [], [], QuestionCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "question circle solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root444();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1444();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2444();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  QuestionCircleSolid = hmr(QuestionCircleSolid, () => QuestionCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QuestionCircleSolid[HMR].source;
    set(QuestionCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var QuestionCircleSolid_default = QuestionCircleSolid;
mark_module_end(QuestionCircleSolid);

// node_modules/flowbite-svelte-icons/dist/QuoteOutline.svelte
mark_module_start();
QuoteOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QuoteOutline.svelte";
var root_1445 = add_locations(ns_template(`<title> </title>`), QuoteOutline[FILENAME], [[41, 4]]);
var root_2445 = add_locations(ns_template(`<desc> </desc>`), QuoteOutline[FILENAME], [[44, 4]]);
var root445 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M10 11V8a1 1 0 0 0-1-1H6a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1Zm0 0v2a4 4 0 0 1-4 4H5m14-6V8a1 1 0 0 0-1-1h-3a1 1 0 0 0-1 1v3a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1Zm0 0v2a4 4 0 0 1-4 4h-1"></path></svg>`), QuoteOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function QuoteOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, QuoteOutline);
  validate_prop_bindings($$props, [], [], QuoteOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "quote outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root445();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1445();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2445();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  QuoteOutline = hmr(QuoteOutline, () => QuoteOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QuoteOutline[HMR].source;
    set(QuoteOutline[HMR].source, module.default[HMR].original);
  });
}
var QuoteOutline_default = QuoteOutline;
mark_module_end(QuoteOutline);

// node_modules/flowbite-svelte-icons/dist/QuoteSolid.svelte
mark_module_start();
QuoteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/QuoteSolid.svelte";
var root_1446 = add_locations(ns_template(`<title> </title>`), QuoteSolid[FILENAME], [[39, 4]]);
var root_2446 = add_locations(ns_template(`<desc> </desc>`), QuoteSolid[FILENAME], [[42, 4]]);
var root446 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M6 6a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a3 3 0 0 1-3 3H5a1 1 0 1 0 0 2h1a5 5 0 0 0 5-5V8a2 2 0 0 0-2-2H6Zm9 0a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h3a3 3 0 0 1-3 3h-1a1 1 0 1 0 0 2h1a5 5 0 0 0 5-5V8a2 2 0 0 0-2-2h-3Z" clip-rule="evenodd"></path></svg>`), QuoteSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function QuoteSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, QuoteSolid);
  validate_prop_bindings($$props, [], [], QuoteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "quote solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root446();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1446();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2446();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  QuoteSolid = hmr(QuoteSolid, () => QuoteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QuoteSolid[HMR].source;
    set(QuoteSolid[HMR].source, module.default[HMR].original);
  });
}
var QuoteSolid_default = QuoteSolid;
mark_module_end(QuoteSolid);

// node_modules/flowbite-svelte-icons/dist/ReactSolid.svelte
mark_module_start();
ReactSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReactSolid.svelte";
var root_1447 = add_locations(ns_template(`<title> </title>`), ReactSolid[FILENAME], [[39, 4]]);
var root_2447 = add_locations(ns_template(`<desc> </desc>`), ReactSolid[FILENAME], [[42, 4]]);
var root447 = add_locations(ns_template(`<svg><!><!><path d="M21.718 12c0-1.429-1.339-2.681-3.467-3.5.029-.18.077-.37.1-.545.217-2.058-.273-3.543-1.379-4.182-1.235-.714-2.983-.186-4.751 1.239C10.45 3.589 8.7 3.061 7.468 3.773c-1.107.639-1.6 2.124-1.379 4.182.018.175.067.365.095.545-2.127.819-3.466 2.071-3.466 3.5 0 1.429 1.339 2.681 3.466 3.5-.028.18-.077.37-.095.545-.218 2.058.272 3.543 1.379 4.182.376.213.803.322 1.235.316a5.987 5.987 0 0 0 3.514-1.56 5.992 5.992 0 0 0 3.515 1.56 2.44 2.44 0 0 0 1.236-.316c1.106-.639 1.6-2.124 1.379-4.182-.019-.175-.067-.365-.1-.545 2.132-.819 3.471-2.071 3.471-3.5Zm-6.01-7.548a1.5 1.5 0 0 1 .76.187c.733.424 1.055 1.593.884 3.212-.012.106-.043.222-.058.33-.841-.243-1.7-.418-2.57-.523a16.165 16.165 0 0 0-1.747-1.972 4.9 4.9 0 0 1 2.731-1.234Zm-7.917 8.781c.172.34.335.68.529 1.017.194.337.395.656.6.969a14.09 14.09 0 0 1-1.607-.376 14.38 14.38 0 0 1 .478-1.61Zm-.479-4.076a14.085 14.085 0 0 1 1.607-.376c-.205.313-.405.634-.6.969-.195.335-.357.677-.529 1.017-.19-.527-.35-1.064-.478-1.61ZM8.3 12a19.32 19.32 0 0 1 .888-1.75c.33-.568.69-1.118 1.076-1.65.619-.061 1.27-.1 1.954-.1.684 0 1.333.035 1.952.1a19.63 19.63 0 0 1 1.079 1.654c.325.567.621 1.15.887 1.746a18.869 18.869 0 0 1-1.953 3.403 19.218 19.218 0 0 1-3.931 0 20.169 20.169 0 0 1-1.066-1.653A19.324 19.324 0 0 1 8.3 12Zm7.816 2.25c.2-.337.358-.677.53-1.017.191.527.35 1.065.478 1.611a14.48 14.48 0 0 1-1.607.376c.202-.314.404-.635.597-.97h.002Zm.53-3.483c-.172-.34-.335-.68-.53-1.017a20.214 20.214 0 0 0-.6-.97c.542.095 1.078.22 1.606.376a14.111 14.111 0 0 1-.478 1.611h.002ZM12.217 6.34c.4.375.777.773 1.13 1.193-.37-.02-.746-.033-1.129-.033s-.76.013-1.131.033c.353-.42.73-.817 1.13-1.193Zm-4.249-1.7a1.5 1.5 0 0 1 .76-.187 4.9 4.9 0 0 1 2.729 1.233A16.253 16.253 0 0 0 9.71 7.658c-.87.105-1.728.28-2.569.524-.015-.109-.047-.225-.058-.331-.171-1.619.151-2.787.885-3.211ZM3.718 12c0-.9.974-1.83 2.645-2.506.218.857.504 1.695.856 2.506-.352.811-.638 1.65-.856 2.506C4.692 13.83 3.718 12.9 3.718 12Zm4.25 7.361c-.734-.423-1.056-1.593-.885-3.212.011-.106.043-.222.058-.331.84.243 1.697.418 2.564.524a16.37 16.37 0 0 0 1.757 1.982c-1.421 1.109-2.714 1.488-3.494 1.037Zm3.11-2.895c.374.021.753.034 1.14.034.387 0 .765-.013 1.139-.034a14.4 14.4 0 0 1-1.14 1.215 14.248 14.248 0 0 1-1.139-1.215Zm5.39 2.895c-.782.451-2.075.072-3.5-1.038a16.248 16.248 0 0 0 1.757-1.981 16.41 16.41 0 0 0 2.565-.523c.015.108.046.224.058.33.175 1.619-.148 2.789-.88 3.212Zm1.6-4.854A16.563 16.563 0 0 0 17.216 12c.352-.812.638-1.65.856-2.507 1.671.677 2.646 1.607 2.646 2.507 0 .9-.975 1.83-2.646 2.507h-.004Z"></path><path d="M12.215 13.773a1.792 1.792 0 1 0-1.786-1.8v.006a1.787 1.787 0 0 0 1.786 1.794Z"></path></svg>`), ReactSolid[FILENAME], [
  [29, 0, [[44, 2], [46, 5]]]
]);
function ReactSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ReactSolid);
  validate_prop_bindings($$props, [], [], ReactSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "react solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root447();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1447();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2447();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ReactSolid = hmr(ReactSolid, () => ReactSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReactSolid[HMR].source;
    set(ReactSolid[HMR].source, module.default[HMR].original);
  });
}
var ReactSolid_default = ReactSolid;
mark_module_end(ReactSolid);

// node_modules/flowbite-svelte-icons/dist/ReceiptOutline.svelte
mark_module_start();
ReceiptOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReceiptOutline.svelte";
var root_1448 = add_locations(ns_template(`<title> </title>`), ReceiptOutline[FILENAME], [[41, 4]]);
var root_2448 = add_locations(ns_template(`<desc> </desc>`), ReceiptOutline[FILENAME], [[44, 4]]);
var root448 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 8h6m-6 4h6m-6 4h6M6 3v18l2-2 2 2 2-2 2 2 2-2 2 2V3l-2 2-2-2-2 2-2-2-2 2-2-2Z"></path></svg>`), ReceiptOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ReceiptOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ReceiptOutline);
  validate_prop_bindings($$props, [], [], ReceiptOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "receipt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root448();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1448();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2448();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ReceiptOutline = hmr(ReceiptOutline, () => ReceiptOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReceiptOutline[HMR].source;
    set(ReceiptOutline[HMR].source, module.default[HMR].original);
  });
}
var ReceiptOutline_default = ReceiptOutline;
mark_module_end(ReceiptOutline);

// node_modules/flowbite-svelte-icons/dist/ReceiptSolid.svelte
mark_module_start();
ReceiptSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReceiptSolid.svelte";
var root_1449 = add_locations(ns_template(`<title> </title>`), ReceiptSolid[FILENAME], [[39, 4]]);
var root_2449 = add_locations(ns_template(`<desc> </desc>`), ReceiptSolid[FILENAME], [[42, 4]]);
var root449 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5.617 2.076a1 1 0 0 1 1.09.217L8 3.586l1.293-1.293a1 1 0 0 1 1.414 0L12 3.586l1.293-1.293a1 1 0 0 1 1.414 0L16 3.586l1.293-1.293A1 1 0 0 1 19 3v18a1 1 0 0 1-1.707.707L16 20.414l-1.293 1.293a1 1 0 0 1-1.414 0L12 20.414l-1.293 1.293a1 1 0 0 1-1.414 0L8 20.414l-1.293 1.293A1 1 0 0 1 5 21V3a1 1 0 0 1 .617-.924ZM9 7a1 1 0 0 0 0 2h6a1 1 0 1 0 0-2H9Zm0 4a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Zm0 4a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2H9Z" clip-rule="evenodd"></path></svg>`), ReceiptSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ReceiptSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ReceiptSolid);
  validate_prop_bindings($$props, [], [], ReceiptSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "receipt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root449();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1449();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2449();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ReceiptSolid = hmr(ReceiptSolid, () => ReceiptSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReceiptSolid[HMR].source;
    set(ReceiptSolid[HMR].source, module.default[HMR].original);
  });
}
var ReceiptSolid_default = ReceiptSolid;
mark_module_end(ReceiptSolid);

// node_modules/flowbite-svelte-icons/dist/RectangleListOutline.svelte
mark_module_start();
RectangleListOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RectangleListOutline.svelte";
var root_1450 = add_locations(ns_template(`<title> </title>`), RectangleListOutline[FILENAME], [[41, 4]]);
var root_2450 = add_locations(ns_template(`<desc> </desc>`), RectangleListOutline[FILENAME], [[44, 4]]);
var root450 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 9h6m-6 3h6m-6 3h6M6.996 9h.01m-.01 3h.01m-.01 3h.01M4 5h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Z"></path></svg>`), RectangleListOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function RectangleListOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, RectangleListOutline);
  validate_prop_bindings($$props, [], [], RectangleListOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "rectangle list outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root450();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1450();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2450();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RectangleListOutline = hmr(RectangleListOutline, () => RectangleListOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RectangleListOutline[HMR].source;
    set(RectangleListOutline[HMR].source, module.default[HMR].original);
  });
}
var RectangleListOutline_default = RectangleListOutline;
mark_module_end(RectangleListOutline);

// node_modules/flowbite-svelte-icons/dist/RectangleListSolid.svelte
mark_module_start();
RectangleListSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RectangleListSolid.svelte";
var root_1451 = add_locations(ns_template(`<title> </title>`), RectangleListSolid[FILENAME], [[39, 4]]);
var root_2451 = add_locations(ns_template(`<desc> </desc>`), RectangleListSolid[FILENAME], [[42, 4]]);
var root451 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6Zm4.996 2a1 1 0 0 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM11 8a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Zm-4.004 3a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM11 11a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Zm-4.004 3a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01ZM11 14a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z" clip-rule="evenodd"></path></svg>`), RectangleListSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function RectangleListSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, RectangleListSolid);
  validate_prop_bindings($$props, [], [], RectangleListSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "rectangle list solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root451();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1451();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2451();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RectangleListSolid = hmr(RectangleListSolid, () => RectangleListSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RectangleListSolid[HMR].source;
    set(RectangleListSolid[HMR].source, module.default[HMR].original);
  });
}
var RectangleListSolid_default = RectangleListSolid;
mark_module_end(RectangleListSolid);

// node_modules/flowbite-svelte-icons/dist/RedditSolid.svelte
mark_module_start();
RedditSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RedditSolid.svelte";
var root_1452 = add_locations(ns_template(`<title> </title>`), RedditSolid[FILENAME], [[39, 4]]);
var root_2452 = add_locations(ns_template(`<desc> </desc>`), RedditSolid[FILENAME], [[42, 4]]);
var root452 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M12.008 16.521a3.84 3.84 0 0 0 2.47-.77v.04a.281.281 0 0 0 .005-.396.281.281 0 0 0-.395-.005 3.291 3.291 0 0 1-2.09.61 3.266 3.266 0 0 1-2.081-.63.27.27 0 0 0-.38.381 3.84 3.84 0 0 0 2.47.77Z"></path><path fill="currentColor" fill-rule="evenodd" d="M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Zm-4.845-1.407A1.463 1.463 0 0 1 18.67 12a1.46 1.46 0 0 1-.808 1.33c.01.146.01.293 0 .44 0 2.242-2.61 4.061-5.829 4.061s-5.83-1.821-5.83-4.061a3.25 3.25 0 0 1 0-.44 1.458 1.458 0 0 1-.457-2.327 1.458 1.458 0 0 1 2.063-.064 7.163 7.163 0 0 1 3.9-1.23l.738-3.47v-.006a.31.31 0 0 1 .37-.236l2.452.49a1 1 0 1 1-.132.611l-2.14-.45-.649 3.12a7.11 7.11 0 0 1 3.85 1.23c.259-.246.6-.393.957-.405Z" clip-rule="evenodd"></path><path fill="currentColor" d="M15.305 13a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm-4.625 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>`), RedditSolid[FILENAME], [
  [
    29,
    0,
    [[44, 2], [48, 2], [54, 2]]
  ]
]);
function RedditSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, RedditSolid);
  validate_prop_bindings($$props, [], [], RedditSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "reddit solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root452();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1452();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2452();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(3);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RedditSolid = hmr(RedditSolid, () => RedditSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RedditSolid[HMR].source;
    set(RedditSolid[HMR].source, module.default[HMR].original);
  });
}
var RedditSolid_default = RedditSolid;
mark_module_end(RedditSolid);

// node_modules/flowbite-svelte-icons/dist/RedoOutline.svelte
mark_module_start();
RedoOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RedoOutline.svelte";
var root_1453 = add_locations(ns_template(`<title> </title>`), RedoOutline[FILENAME], [[41, 4]]);
var root_2453 = add_locations(ns_template(`<desc> </desc>`), RedoOutline[FILENAME], [[44, 4]]);
var root453 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M21 9H8a5 5 0 0 0 0 10h9m4-10-4-4m4 4-4 4"></path></svg>`), RedoOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function RedoOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, RedoOutline);
  validate_prop_bindings($$props, [], [], RedoOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "redo outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root453();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1453();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2453();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RedoOutline = hmr(RedoOutline, () => RedoOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RedoOutline[HMR].source;
    set(RedoOutline[HMR].source, module.default[HMR].original);
  });
}
var RedoOutline_default = RedoOutline;
mark_module_end(RedoOutline);

// node_modules/flowbite-svelte-icons/dist/RefreshOutline.svelte
mark_module_start();
RefreshOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RefreshOutline.svelte";
var root_1454 = add_locations(ns_template(`<title> </title>`), RefreshOutline[FILENAME], [[41, 4]]);
var root_2454 = add_locations(ns_template(`<desc> </desc>`), RefreshOutline[FILENAME], [[44, 4]]);
var root454 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17.651 7.65a7.131 7.131 0 0 0-12.68 3.15M18.001 4v4h-4m-7.652 8.35a7.13 7.13 0 0 0 12.68-3.15M6 20v-4h4"></path></svg>`), RefreshOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function RefreshOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, RefreshOutline);
  validate_prop_bindings($$props, [], [], RefreshOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "refresh outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root454();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1454();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2454();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RefreshOutline = hmr(RefreshOutline, () => RefreshOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RefreshOutline[HMR].source;
    set(RefreshOutline[HMR].source, module.default[HMR].original);
  });
}
var RefreshOutline_default = RefreshOutline;
mark_module_end(RefreshOutline);

// node_modules/flowbite-svelte-icons/dist/ReplyAllOutline.svelte
mark_module_start();
ReplyAllOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReplyAllOutline.svelte";
var root_1455 = add_locations(ns_template(`<title> </title>`), ReplyAllOutline[FILENAME], [[41, 4]]);
var root_2455 = add_locations(ns_template(`<desc> </desc>`), ReplyAllOutline[FILENAME], [[44, 4]]);
var root455 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.757 6 3.24 10.95a1.05 1.05 0 0 0 0 1.549l5.611 5.088m5.73-3.214v1.615a.948.948 0 0 1-1.524.845l-5.108-4.251a1.1 1.1 0 0 1 0-1.646l5.108-4.251a.95.95 0 0 1 1.524.846v1.7c3.312 0 6 2.979 6 6.654v1.329a.7.7 0 0 1-1.345.353 5.174 5.174 0 0 0-4.652-3.191l-.003-.003Z"></path></svg>`), ReplyAllOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ReplyAllOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ReplyAllOutline);
  validate_prop_bindings($$props, [], [], ReplyAllOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "reply all outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root455();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1455();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2455();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ReplyAllOutline = hmr(ReplyAllOutline, () => ReplyAllOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReplyAllOutline[HMR].source;
    set(ReplyAllOutline[HMR].source, module.default[HMR].original);
  });
}
var ReplyAllOutline_default = ReplyAllOutline;
mark_module_end(ReplyAllOutline);

// node_modules/flowbite-svelte-icons/dist/ReplyAllSolid.svelte
mark_module_start();
ReplyAllSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReplyAllSolid.svelte";
var root_1456 = add_locations(ns_template(`<title> </title>`), ReplyAllSolid[FILENAME], [[39, 4]]);
var root_2456 = add_locations(ns_template(`<desc> </desc>`), ReplyAllSolid[FILENAME], [[42, 4]]);
var root456 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9.484 6.743c.41-.368.443-1 .077-1.41a.99.99 0 0 0-1.405-.078L2.67 10.203l-.007.006A2.048 2.048 0 0 0 2 11.721a2.058 2.058 0 0 0 .662 1.51l5.584 5.09a.99.99 0 0 0 1.405-.07 1.003 1.003 0 0 0-.07-1.412l-5.577-5.082a.05.05 0 0 1 0-.072l5.48-4.942Zm6.543 9.199v-.42a4.168 4.168 0 0 1 2.715 2.415c.154.382.44.695.806.88a1.683 1.683 0 0 0 2.167-.571c.214-.322.312-.707.279-1.092V15.88c0-3.77-2.526-7.039-5.966-7.573V7.57a1.957 1.957 0 0 0-.994-1.838 1.931 1.931 0 0 0-2.153.184L7.8 10.164a.753.753 0 0 0-.012.011l-.011.01a2.098 2.098 0 0 0-.703 1.57 2.108 2.108 0 0 0 .726 1.59l5.08 4.25a1.933 1.933 0 0 0 2.929-.614c.167-.32.242-.68.218-1.04Z" clip-rule="evenodd"></path></svg>`), ReplyAllSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ReplyAllSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ReplyAllSolid);
  validate_prop_bindings($$props, [], [], ReplyAllSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "reply all solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root456();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1456();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2456();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ReplyAllSolid = hmr(ReplyAllSolid, () => ReplyAllSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReplyAllSolid[HMR].source;
    set(ReplyAllSolid[HMR].source, module.default[HMR].original);
  });
}
var ReplyAllSolid_default = ReplyAllSolid;
mark_module_end(ReplyAllSolid);

// node_modules/flowbite-svelte-icons/dist/ReplyOutline.svelte
mark_module_start();
ReplyOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReplyOutline.svelte";
var root_1457 = add_locations(ns_template(`<title> </title>`), ReplyOutline[FILENAME], [[41, 4]]);
var root_2457 = add_locations(ns_template(`<desc> </desc>`), ReplyOutline[FILENAME], [[44, 4]]);
var root457 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14.5 8.046H11V6.119c0-.921-.9-1.446-1.524-.894l-5.108 4.49a1.2 1.2 0 0 0 0 1.739l5.108 4.49c.624.556 1.524.027 1.524-.893v-1.928h2a3.023 3.023 0 0 1 3 3.046V19a5.593 5.593 0 0 0-1.5-10.954Z"></path></svg>`), ReplyOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ReplyOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ReplyOutline);
  validate_prop_bindings($$props, [], [], ReplyOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "reply outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root457();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1457();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2457();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ReplyOutline = hmr(ReplyOutline, () => ReplyOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReplyOutline[HMR].source;
    set(ReplyOutline[HMR].source, module.default[HMR].original);
  });
}
var ReplyOutline_default = ReplyOutline;
mark_module_end(ReplyOutline);

// node_modules/flowbite-svelte-icons/dist/ReplySolid.svelte
mark_module_start();
ReplySolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ReplySolid.svelte";
var root_1458 = add_locations(ns_template(`<title> </title>`), ReplySolid[FILENAME], [[39, 4]]);
var root_2458 = add_locations(ns_template(`<desc> </desc>`), ReplySolid[FILENAME], [[42, 4]]);
var root458 = add_locations(ns_template(`<svg><!><!><path d="M14.502 7.046h-2.5v-.928a2.122 2.122 0 0 0-1.199-1.954 1.827 1.827 0 0 0-1.984.311L3.71 8.965a2.2 2.2 0 0 0 0 3.24L8.82 16.7a1.829 1.829 0 0 0 1.985.31 2.121 2.121 0 0 0 1.199-1.959v-.928h1a2.025 2.025 0 0 1 1.999 2.047V19a1 1 0 0 0 1.275.961 6.59 6.59 0 0 0 4.662-7.22 6.593 6.593 0 0 0-6.437-5.695Z"></path></svg>`), ReplySolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ReplySolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ReplySolid);
  validate_prop_bindings($$props, [], [], ReplySolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "reply solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root458();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1458();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2458();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ReplySolid = hmr(ReplySolid, () => ReplySolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ReplySolid[HMR].source;
    set(ReplySolid[HMR].source, module.default[HMR].original);
  });
}
var ReplySolid_default = ReplySolid;
mark_module_end(ReplySolid);

// node_modules/flowbite-svelte-icons/dist/RestoreWindowOutline.svelte
mark_module_start();
RestoreWindowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RestoreWindowOutline.svelte";
var root_1459 = add_locations(ns_template(`<title> </title>`), RestoreWindowOutline[FILENAME], [[41, 4]]);
var root_2459 = add_locations(ns_template(`<desc> </desc>`), RestoreWindowOutline[FILENAME], [[44, 4]]);
var root459 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 11.5h13m-13 0V18a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1v-6.5m-13 0V9a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v2.5M9 5h11a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1h-1"></path></svg>`), RestoreWindowOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function RestoreWindowOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, RestoreWindowOutline);
  validate_prop_bindings($$props, [], [], RestoreWindowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "restore window outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root459();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1459();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2459();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RestoreWindowOutline = hmr(RestoreWindowOutline, () => RestoreWindowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RestoreWindowOutline[HMR].source;
    set(RestoreWindowOutline[HMR].source, module.default[HMR].original);
  });
}
var RestoreWindowOutline_default = RestoreWindowOutline;
mark_module_end(RestoreWindowOutline);

// node_modules/flowbite-svelte-icons/dist/RocketOutline.svelte
mark_module_start();
RocketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RocketOutline.svelte";
var root_1460 = add_locations(ns_template(`<title> </title>`), RocketOutline[FILENAME], [[41, 4]]);
var root_2460 = add_locations(ns_template(`<desc> </desc>`), RocketOutline[FILENAME], [[44, 4]]);
var root460 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m10.051 8.102-3.778.322-1.994 1.994a.94.94 0 0 0 .533 1.6l2.698.316m8.39 1.617-.322 3.78-1.994 1.994a.94.94 0 0 1-1.595-.533l-.4-2.652m8.166-11.174a1.366 1.366 0 0 0-1.12-1.12c-1.616-.279-4.906-.623-6.38.853-1.671 1.672-5.211 8.015-6.31 10.023a.932.932 0 0 0 .162 1.111l.828.835.833.832a.932.932 0 0 0 1.111.163c2.008-1.102 8.35-4.642 10.021-6.312 1.475-1.478 1.133-4.77.855-6.385Zm-2.961 3.722a1.88 1.88 0 1 1-3.76 0 1.88 1.88 0 0 1 3.76 0Z"></path></svg>`), RocketOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function RocketOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, RocketOutline);
  validate_prop_bindings($$props, [], [], RocketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "rocket outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root460();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1460();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2460();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RocketOutline = hmr(RocketOutline, () => RocketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RocketOutline[HMR].source;
    set(RocketOutline[HMR].source, module.default[HMR].original);
  });
}
var RocketOutline_default = RocketOutline;
mark_module_end(RocketOutline);

// node_modules/flowbite-svelte-icons/dist/RocketSolid.svelte
mark_module_start();
RocketSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RocketSolid.svelte";
var root_1461 = add_locations(ns_template(`<title> </title>`), RocketSolid[FILENAME], [[39, 4]]);
var root_2461 = add_locations(ns_template(`<desc> </desc>`), RocketSolid[FILENAME], [[42, 4]]);
var root461 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M20.337 3.664c.213.212.354.486.404.782.294 1.711.657 5.195-.906 6.76-1.77 1.768-8.485 5.517-10.611 6.683a.987.987 0 0 1-1.176-.173l-.882-.88-.877-.884a.988.988 0 0 1-.173-1.177c1.165-2.126 4.913-8.841 6.682-10.611 1.562-1.563 5.046-1.198 6.757-.904.296.05.57.191.782.404ZM5.407 7.576l4-.341-2.69 4.48-2.857-.334a.996.996 0 0 1-.565-1.694l2.112-2.111Zm11.357 7.02-.34 4-2.111 2.113a.996.996 0 0 1-1.69-.565l-.422-2.807 4.563-2.74Zm.84-6.21a1.99 1.99 0 1 1-3.98 0 1.99 1.99 0 0 1 3.98 0Z" clip-rule="evenodd"></path></svg>`), RocketSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function RocketSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, RocketSolid);
  validate_prop_bindings($$props, [], [], RocketSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "rocket solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root461();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1461();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2461();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RocketSolid = hmr(RocketSolid, () => RocketSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RocketSolid[HMR].source;
    set(RocketSolid[HMR].source, module.default[HMR].original);
  });
}
var RocketSolid_default = RocketSolid;
mark_module_end(RocketSolid);

// node_modules/flowbite-svelte-icons/dist/RulerCombinedOutline.svelte
mark_module_start();
RulerCombinedOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/RulerCombinedOutline.svelte";
var root_1462 = add_locations(ns_template(`<title> </title>`), RulerCombinedOutline[FILENAME], [[41, 4]]);
var root_2462 = add_locations(ns_template(`<desc> </desc>`), RulerCombinedOutline[FILENAME], [[44, 4]]);
var root462 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 7H7m2 3H7m2 3H7m4 2v2m3-2v2m3-2v2M4 5v14a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-3a1 1 0 0 0-1-1h-9a1 1 0 0 1-1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1Z"></path></svg>`), RulerCombinedOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function RulerCombinedOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, RulerCombinedOutline);
  validate_prop_bindings($$props, [], [], RulerCombinedOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "ruler combined outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root462();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1462();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2462();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  RulerCombinedOutline = hmr(RulerCombinedOutline, () => RulerCombinedOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = RulerCombinedOutline[HMR].source;
    set(RulerCombinedOutline[HMR].source, module.default[HMR].original);
  });
}
var RulerCombinedOutline_default = RulerCombinedOutline;
mark_module_end(RulerCombinedOutline);

// node_modules/flowbite-svelte-icons/dist/SalePercentOutline.svelte
mark_module_start();
SalePercentOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SalePercentOutline.svelte";
var root_1463 = add_locations(ns_template(`<title> </title>`), SalePercentOutline[FILENAME], [[41, 4]]);
var root_2463 = add_locations(ns_template(`<desc> </desc>`), SalePercentOutline[FILENAME], [[44, 4]]);
var root463 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8.891 15.107 15.11 8.89m-5.183-.52h.01m3.089 7.254h.01M14.08 3.902a2.849 2.849 0 0 0 2.176.902 2.845 2.845 0 0 1 2.94 2.94 2.849 2.849 0 0 0 .901 2.176 2.847 2.847 0 0 1 0 4.16 2.848 2.848 0 0 0-.901 2.175 2.843 2.843 0 0 1-2.94 2.94 2.848 2.848 0 0 0-2.176.902 2.847 2.847 0 0 1-4.16 0 2.85 2.85 0 0 0-2.176-.902 2.845 2.845 0 0 1-2.94-2.94 2.848 2.848 0 0 0-.901-2.176 2.848 2.848 0 0 1 0-4.16 2.849 2.849 0 0 0 .901-2.176 2.845 2.845 0 0 1 2.941-2.94 2.849 2.849 0 0 0 2.176-.901 2.847 2.847 0 0 1 4.159 0Z"></path></svg>`), SalePercentOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function SalePercentOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SalePercentOutline);
  validate_prop_bindings($$props, [], [], SalePercentOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "sale percent outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root463();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1463();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2463();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SalePercentOutline = hmr(SalePercentOutline, () => SalePercentOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SalePercentOutline[HMR].source;
    set(SalePercentOutline[HMR].source, module.default[HMR].original);
  });
}
var SalePercentOutline_default = SalePercentOutline;
mark_module_end(SalePercentOutline);

// node_modules/flowbite-svelte-icons/dist/SalePercentSolid.svelte
mark_module_start();
SalePercentSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SalePercentSolid.svelte";
var root_1464 = add_locations(ns_template(`<title> </title>`), SalePercentSolid[FILENAME], [[39, 4]]);
var root_2464 = add_locations(ns_template(`<desc> </desc>`), SalePercentSolid[FILENAME], [[42, 4]]);
var root464 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M20.29 8.567c.133.323.334.613.59.85v.002a3.536 3.536 0 0 1 0 5.166 2.442 2.442 0 0 0-.776 1.868 3.534 3.534 0 0 1-3.651 3.653 2.483 2.483 0 0 0-1.87.776 3.537 3.537 0 0 1-5.164 0 2.44 2.44 0 0 0-1.87-.776 3.533 3.533 0 0 1-3.653-3.654 2.44 2.44 0 0 0-.775-1.868 3.537 3.537 0 0 1 0-5.166 2.44 2.44 0 0 0 .775-1.87 3.55 3.55 0 0 1 1.033-2.62 3.594 3.594 0 0 1 2.62-1.032 2.401 2.401 0 0 0 1.87-.775 3.535 3.535 0 0 1 5.165 0 2.444 2.444 0 0 0 1.869.775 3.532 3.532 0 0 1 3.652 3.652c-.012.35.051.697.184 1.02ZM9.927 7.371a1 1 0 1 0 0 2h.01a1 1 0 0 0 0-2h-.01Zm5.889 2.226a1 1 0 0 0-1.414-1.415L8.184 14.4a1 1 0 0 0 1.414 1.414l6.218-6.217Zm-2.79 5.028a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2h-.01Z" clip-rule="evenodd"></path></svg>`), SalePercentSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function SalePercentSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SalePercentSolid);
  validate_prop_bindings($$props, [], [], SalePercentSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "sale percent solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root464();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1464();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2464();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SalePercentSolid = hmr(SalePercentSolid, () => SalePercentSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SalePercentSolid[HMR].source;
    set(SalePercentSolid[HMR].source, module.default[HMR].original);
  });
}
var SalePercentSolid_default = SalePercentSolid;
mark_module_end(SalePercentSolid);

// node_modules/flowbite-svelte-icons/dist/ScaleBalancedOutline.svelte
mark_module_start();
ScaleBalancedOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ScaleBalancedOutline.svelte";
var root_1465 = add_locations(ns_template(`<title> </title>`), ScaleBalancedOutline[FILENAME], [[41, 4]]);
var root_2465 = add_locations(ns_template(`<desc> </desc>`), ScaleBalancedOutline[FILENAME], [[44, 4]]);
var root465 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5.5 21h13M12 21V7m0 0a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm2-1.8c3.073.661 2.467 2.8 5 2.8M5 8c3.359 0 2.192-2.115 5.012-2.793M7 9.556V7.75m0 1.806-1.95 4.393a.773.773 0 0 0 .37.962.785.785 0 0 0 .362.089h2.436a.785.785 0 0 0 .643-.335.776.776 0 0 0 .09-.716L7 9.556Zm10 0V7.313m0 2.243-1.95 4.393a.773.773 0 0 0 .37.962.786.786 0 0 0 .362.089h2.436a.785.785 0 0 0 .643-.335.775.775 0 0 0 .09-.716L17 9.556Z"></path></svg>`), ScaleBalancedOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ScaleBalancedOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ScaleBalancedOutline);
  validate_prop_bindings($$props, [], [], ScaleBalancedOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "scale balanced outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root465();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1465();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2465();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ScaleBalancedOutline = hmr(ScaleBalancedOutline, () => ScaleBalancedOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ScaleBalancedOutline[HMR].source;
    set(ScaleBalancedOutline[HMR].source, module.default[HMR].original);
  });
}
var ScaleBalancedOutline_default = ScaleBalancedOutline;
mark_module_end(ScaleBalancedOutline);

// node_modules/flowbite-svelte-icons/dist/ScaleBalancedSolid.svelte
mark_module_start();
ScaleBalancedSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ScaleBalancedSolid.svelte";
var root_1466 = add_locations(ns_template(`<title> </title>`), ScaleBalancedSolid[FILENAME], [[39, 4]]);
var root_2466 = add_locations(ns_template(`<desc> </desc>`), ScaleBalancedSolid[FILENAME], [[42, 4]]);
var root466 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 4a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm-2.952.462c-.483.19-.868.432-1.19.71-.363.315-.638.677-.831.93l-.106.14c-.21.268-.36.418-.574.527C6.125 6.883 5.74 7 5 7a1 1 0 0 0 0 2c.364 0 .696-.022 1-.067v.41l-1.864 4.2a1.774 1.774 0 0 0 .821 2.255c.255.133.538.202.825.202h2.436a1.786 1.786 0 0 0 1.768-1.558 1.774 1.774 0 0 0-.122-.899L8 9.343V8.028c.2-.188.36-.38.495-.553.062-.079.118-.15.168-.217.185-.24.311-.406.503-.571a1.89 1.89 0 0 1 .24-.177A3.01 3.01 0 0 0 11 7.829V20H5.5a1 1 0 1 0 0 2h13a1 1 0 1 0 0-2H13V7.83a3.01 3.01 0 0 0 1.63-1.387c.206.091.373.19.514.29.31.219.532.465.811.78l.025.027.02.023v1.78l-1.864 4.2a1.774 1.774 0 0 0 .821 2.255c.255.133.538.202.825.202h2.436a1.785 1.785 0 0 0 1.768-1.558 1.773 1.773 0 0 0-.122-.899L18 9.343v-.452c.302.072.633.109 1 .109a1 1 0 1 0 0-2c-.48 0-.731-.098-.899-.2-.2-.12-.363-.293-.651-.617l-.024-.026c-.267-.3-.622-.7-1.127-1.057a5.152 5.152 0 0 0-1.355-.678 3.001 3.001 0 0 0-5.896.04Z" clip-rule="evenodd"></path></svg>`), ScaleBalancedSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ScaleBalancedSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ScaleBalancedSolid);
  validate_prop_bindings($$props, [], [], ScaleBalancedSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "scale balanced solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root466();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1466();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2466();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ScaleBalancedSolid = hmr(ScaleBalancedSolid, () => ScaleBalancedSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ScaleBalancedSolid[HMR].source;
    set(ScaleBalancedSolid[HMR].source, module.default[HMR].original);
  });
}
var ScaleBalancedSolid_default = ScaleBalancedSolid;
mark_module_end(ScaleBalancedSolid);

// node_modules/flowbite-svelte-icons/dist/SearchOutline.svelte
mark_module_start();
SearchOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SearchOutline.svelte";
var root_1467 = add_locations(ns_template(`<title> </title>`), SearchOutline[FILENAME], [[41, 4]]);
var root_2467 = add_locations(ns_template(`<desc> </desc>`), SearchOutline[FILENAME], [[44, 4]]);
var root467 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m21 21-3.5-3.5M17 10a7 7 0 1 1-14 0 7 7 0 0 1 14 0Z"></path></svg>`), SearchOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function SearchOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SearchOutline);
  validate_prop_bindings($$props, [], [], SearchOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "search outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root467();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1467();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2467();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SearchOutline = hmr(SearchOutline, () => SearchOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SearchOutline[HMR].source;
    set(SearchOutline[HMR].source, module.default[HMR].original);
  });
}
var SearchOutline_default = SearchOutline;
mark_module_end(SearchOutline);

// node_modules/flowbite-svelte-icons/dist/SearchSolid.svelte
mark_module_start();
SearchSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SearchSolid.svelte";
var root_1468 = add_locations(ns_template(`<title> </title>`), SearchSolid[FILENAME], [[39, 4]]);
var root_2468 = add_locations(ns_template(`<desc> </desc>`), SearchSolid[FILENAME], [[42, 4]]);
var root468 = add_locations(ns_template(`<svg><!><!><path d="M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"></path><path fill-rule="evenodd" d="M21.707 21.707a1 1 0 0 1-1.414 0l-3.5-3.5a1 1 0 0 1 1.414-1.414l3.5 3.5a1 1 0 0 1 0 1.414Z" clip-rule="evenodd"></path></svg>`), SearchSolid[FILENAME], [
  [29, 0, [[44, 2], [45, 2]]]
]);
function SearchSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SearchSolid);
  validate_prop_bindings($$props, [], [], SearchSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "search solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root468();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1468();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2468();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SearchSolid = hmr(SearchSolid, () => SearchSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SearchSolid[HMR].source;
    set(SearchSolid[HMR].source, module.default[HMR].original);
  });
}
var SearchSolid_default = SearchSolid;
mark_module_end(SearchSolid);

// node_modules/flowbite-svelte-icons/dist/ServerOutline.svelte
mark_module_start();
ServerOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ServerOutline.svelte";
var root_1469 = add_locations(ns_template(`<title> </title>`), ServerOutline[FILENAME], [[41, 4]]);
var root_2469 = add_locations(ns_template(`<desc> </desc>`), ServerOutline[FILENAME], [[44, 4]]);
var root469 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 12a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1M5 12h14M5 12a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1m-2 3h.01M14 15h.01M17 9h.01M14 9h.01"></path></svg>`), ServerOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ServerOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ServerOutline);
  validate_prop_bindings($$props, [], [], ServerOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "server outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root469();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1469();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2469();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ServerOutline = hmr(ServerOutline, () => ServerOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ServerOutline[HMR].source;
    set(ServerOutline[HMR].source, module.default[HMR].original);
  });
}
var ServerOutline_default = ServerOutline;
mark_module_end(ServerOutline);

// node_modules/flowbite-svelte-icons/dist/ServerSolid.svelte
mark_module_start();
ServerSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ServerSolid.svelte";
var root_1470 = add_locations(ns_template(`<title> </title>`), ServerSolid[FILENAME], [[39, 4]]);
var root_2470 = add_locations(ns_template(`<desc> </desc>`), ServerSolid[FILENAME], [[42, 4]]);
var root470 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 5a2 2 0 0 0-2 2v3a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1V7a2 2 0 0 0-2-2H5Zm9 2a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H14Zm3 0a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H17ZM3 17v-3a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Zm11-2a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H14Zm3 0a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H17Z" clip-rule="evenodd"></path></svg>`), ServerSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ServerSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ServerSolid);
  validate_prop_bindings($$props, [], [], ServerSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "server solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root470();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1470();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2470();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ServerSolid = hmr(ServerSolid, () => ServerSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ServerSolid[HMR].source;
    set(ServerSolid[HMR].source, module.default[HMR].original);
  });
}
var ServerSolid_default = ServerSolid;
mark_module_end(ServerSolid);

// node_modules/flowbite-svelte-icons/dist/ShareAllOutline.svelte
mark_module_start();
ShareAllOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShareAllOutline.svelte";
var root_1471 = add_locations(ns_template(`<title> </title>`), ShareAllOutline[FILENAME], [[41, 4]]);
var root_2471 = add_locations(ns_template(`<desc> </desc>`), ShareAllOutline[FILENAME], [[44, 4]]);
var root471 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m15.141 6 5.518 4.95a1.05 1.05 0 0 1 0 1.549l-5.612 5.088m-6.154-3.214v1.615a.95.95 0 0 0 1.525.845l5.108-4.251a1.1 1.1 0 0 0 0-1.646l-5.108-4.251a.95.95 0 0 0-1.525.846v1.7c-3.312 0-6 2.979-6 6.654v1.329a.7.7 0 0 0 1.344.353 5.174 5.174 0 0 1 4.652-3.191l.004-.003Z"></path></svg>`), ShareAllOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ShareAllOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShareAllOutline);
  validate_prop_bindings($$props, [], [], ShareAllOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "share all outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root471();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1471();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2471();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShareAllOutline = hmr(ShareAllOutline, () => ShareAllOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShareAllOutline[HMR].source;
    set(ShareAllOutline[HMR].source, module.default[HMR].original);
  });
}
var ShareAllOutline_default = ShareAllOutline;
mark_module_end(ShareAllOutline);

// node_modules/flowbite-svelte-icons/dist/ShareAllSolid.svelte
mark_module_start();
ShareAllSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShareAllSolid.svelte";
var root_1472 = add_locations(ns_template(`<title> </title>`), ShareAllSolid[FILENAME], [[39, 4]]);
var root_2472 = add_locations(ns_template(`<desc> </desc>`), ShareAllSolid[FILENAME], [[42, 4]]);
var root472 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M14.516 6.743c-.41-.368-.443-1-.077-1.41a.99.99 0 0 1 1.405-.078l5.487 4.948.007.006A2.047 2.047 0 0 1 22 11.721a2.06 2.06 0 0 1-.662 1.51l-5.584 5.09a.99.99 0 0 1-1.404-.07 1.003 1.003 0 0 1 .068-1.412l5.578-5.082a.05.05 0 0 0 .015-.036.051.051 0 0 0-.015-.036l-5.48-4.942Zm-6.543 9.199v-.42a4.168 4.168 0 0 0-2.715 2.415c-.154.382-.44.695-.806.88a1.683 1.683 0 0 1-2.167-.571 1.705 1.705 0 0 1-.279-1.092V15.88c0-3.77 2.526-7.039 5.967-7.573V7.57a1.957 1.957 0 0 1 .993-1.838 1.931 1.931 0 0 1 2.153.184l5.08 4.248a.646.646 0 0 1 .012.011l.011.01a2.098 2.098 0 0 1 .703 1.57 2.108 2.108 0 0 1-.726 1.59l-5.08 4.25a1.933 1.933 0 0 1-2.929-.614 1.957 1.957 0 0 1-.217-1.04Z" clip-rule="evenodd"></path></svg>`), ShareAllSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ShareAllSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShareAllSolid);
  validate_prop_bindings($$props, [], [], ShareAllSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "share all solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root472();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1472();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2472();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShareAllSolid = hmr(ShareAllSolid, () => ShareAllSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShareAllSolid[HMR].source;
    set(ShareAllSolid[HMR].source, module.default[HMR].original);
  });
}
var ShareAllSolid_default = ShareAllSolid;
mark_module_end(ShareAllSolid);

// node_modules/flowbite-svelte-icons/dist/ShareNodesOutline.svelte
mark_module_start();
ShareNodesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShareNodesOutline.svelte";
var root_1473 = add_locations(ns_template(`<title> </title>`), ShareNodesOutline[FILENAME], [[41, 4]]);
var root_2473 = add_locations(ns_template(`<desc> </desc>`), ShareNodesOutline[FILENAME], [[44, 4]]);
var root473 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M7.926 10.898 15 7.727m-7.074 5.39L15 16.29M8 12a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Zm12 5.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Zm0-11a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Z"></path></svg>`), ShareNodesOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ShareNodesOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShareNodesOutline);
  validate_prop_bindings($$props, [], [], ShareNodesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "share nodes outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root473();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1473();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2473();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShareNodesOutline = hmr(ShareNodesOutline, () => ShareNodesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShareNodesOutline[HMR].source;
    set(ShareNodesOutline[HMR].source, module.default[HMR].original);
  });
}
var ShareNodesOutline_default = ShareNodesOutline;
mark_module_end(ShareNodesOutline);

// node_modules/flowbite-svelte-icons/dist/ShareNodesSolid.svelte
mark_module_start();
ShareNodesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShareNodesSolid.svelte";
var root_1474 = add_locations(ns_template(`<title> </title>`), ShareNodesSolid[FILENAME], [[39, 4]]);
var root_2474 = add_locations(ns_template(`<desc> </desc>`), ShareNodesSolid[FILENAME], [[42, 4]]);
var root474 = add_locations(ns_template(`<svg><!><!><path d="M17.5 3a3.5 3.5 0 0 0-3.456 4.06L8.143 9.704a3.5 3.5 0 1 0-.01 4.6l5.91 2.65a3.5 3.5 0 1 0 .863-1.805l-5.94-2.662a3.53 3.53 0 0 0 .002-.961l5.948-2.667A3.5 3.5 0 1 0 17.5 3Z"></path></svg>`), ShareNodesSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ShareNodesSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShareNodesSolid);
  validate_prop_bindings($$props, [], [], ShareNodesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "share nodes solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root474();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1474();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2474();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShareNodesSolid = hmr(ShareNodesSolid, () => ShareNodesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShareNodesSolid[HMR].source;
    set(ShareNodesSolid[HMR].source, module.default[HMR].original);
  });
}
var ShareNodesSolid_default = ShareNodesSolid;
mark_module_end(ShareNodesSolid);

// node_modules/flowbite-svelte-icons/dist/ShieldCheckOutline.svelte
mark_module_start();
ShieldCheckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShieldCheckOutline.svelte";
var root_1475 = add_locations(ns_template(`<title> </title>`), ShieldCheckOutline[FILENAME], [[41, 4]]);
var root_2475 = add_locations(ns_template(`<desc> </desc>`), ShieldCheckOutline[FILENAME], [[44, 4]]);
var root475 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9.5 11.5 11 13l4-3.5M12 20a16.405 16.405 0 0 1-5.092-5.804A16.694 16.694 0 0 1 5 6.666L12 4l7 2.667a16.695 16.695 0 0 1-1.908 7.529A16.406 16.406 0 0 1 12 20Z"></path></svg>`), ShieldCheckOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ShieldCheckOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShieldCheckOutline);
  validate_prop_bindings($$props, [], [], ShieldCheckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "shield check outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root475();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1475();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2475();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShieldCheckOutline = hmr(ShieldCheckOutline, () => ShieldCheckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShieldCheckOutline[HMR].source;
    set(ShieldCheckOutline[HMR].source, module.default[HMR].original);
  });
}
var ShieldCheckOutline_default = ShieldCheckOutline;
mark_module_end(ShieldCheckOutline);

// node_modules/flowbite-svelte-icons/dist/ShieldCheckSolid.svelte
mark_module_start();
ShieldCheckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShieldCheckSolid.svelte";
var root_1476 = add_locations(ns_template(`<title> </title>`), ShieldCheckSolid[FILENAME], [[39, 4]]);
var root_2476 = add_locations(ns_template(`<desc> </desc>`), ShieldCheckSolid[FILENAME], [[42, 4]]);
var root476 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M11.644 3.066a1 1 0 0 1 .712 0l7 2.666A1 1 0 0 1 20 6.68a17.694 17.694 0 0 1-2.023 7.98 17.406 17.406 0 0 1-5.402 6.158 1 1 0 0 1-1.15 0 17.405 17.405 0 0 1-5.403-6.157A17.695 17.695 0 0 1 4 6.68a1 1 0 0 1 .644-.949l7-2.666Zm4.014 7.187a1 1 0 0 0-1.316-1.506l-3.296 2.884-.839-.838a1 1 0 0 0-1.414 1.414l1.5 1.5a1 1 0 0 0 1.366.046l4-3.5Z" clip-rule="evenodd"></path></svg>`), ShieldCheckSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ShieldCheckSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShieldCheckSolid);
  validate_prop_bindings($$props, [], [], ShieldCheckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "shield check solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root476();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1476();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2476();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShieldCheckSolid = hmr(ShieldCheckSolid, () => ShieldCheckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShieldCheckSolid[HMR].source;
    set(ShieldCheckSolid[HMR].source, module.default[HMR].original);
  });
}
var ShieldCheckSolid_default = ShieldCheckSolid;
mark_module_end(ShieldCheckSolid);

// node_modules/flowbite-svelte-icons/dist/ShieldOutline.svelte
mark_module_start();
ShieldOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShieldOutline.svelte";
var root_1477 = add_locations(ns_template(`<title> </title>`), ShieldOutline[FILENAME], [[41, 4]]);
var root_2477 = add_locations(ns_template(`<desc> </desc>`), ShieldOutline[FILENAME], [[44, 4]]);
var root477 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 20a16.405 16.405 0 0 1-5.092-5.804A16.694 16.694 0 0 1 5 6.666L12 4l7 2.667a16.695 16.695 0 0 1-1.908 7.529A16.406 16.406 0 0 1 12 20Z"></path></svg>`), ShieldOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ShieldOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShieldOutline);
  validate_prop_bindings($$props, [], [], ShieldOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "shield outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root477();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1477();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2477();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShieldOutline = hmr(ShieldOutline, () => ShieldOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShieldOutline[HMR].source;
    set(ShieldOutline[HMR].source, module.default[HMR].original);
  });
}
var ShieldOutline_default = ShieldOutline;
mark_module_end(ShieldOutline);

// node_modules/flowbite-svelte-icons/dist/ShieldSolid.svelte
mark_module_start();
ShieldSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShieldSolid.svelte";
var root_1478 = add_locations(ns_template(`<title> </title>`), ShieldSolid[FILENAME], [[39, 4]]);
var root_2478 = add_locations(ns_template(`<desc> </desc>`), ShieldSolid[FILENAME], [[42, 4]]);
var root478 = add_locations(ns_template(`<svg><!><!><path d="M12.356 3.066a1 1 0 0 0-.712 0l-7 2.666A1 1 0 0 0 4 6.68a17.695 17.695 0 0 0 2.022 7.98 17.405 17.405 0 0 0 5.403 6.158 1 1 0 0 0 1.15 0 17.406 17.406 0 0 0 5.402-6.157A17.694 17.694 0 0 0 20 6.68a1 1 0 0 0-.644-.949l-7-2.666Z"></path></svg>`), ShieldSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ShieldSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShieldSolid);
  validate_prop_bindings($$props, [], [], ShieldSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "shield solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root478();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1478();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2478();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShieldSolid = hmr(ShieldSolid, () => ShieldSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShieldSolid[HMR].source;
    set(ShieldSolid[HMR].source, module.default[HMR].original);
  });
}
var ShieldSolid_default = ShieldSolid;
mark_module_end(ShieldSolid);

// node_modules/flowbite-svelte-icons/dist/ShoppingBagOutline.svelte
mark_module_start();
ShoppingBagOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShoppingBagOutline.svelte";
var root_1479 = add_locations(ns_template(`<title> </title>`), ShoppingBagOutline[FILENAME], [[41, 4]]);
var root_2479 = add_locations(ns_template(`<desc> </desc>`), ShoppingBagOutline[FILENAME], [[44, 4]]);
var root479 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M9 10V6a3 3 0 0 1 3-3v0a3 3 0 0 1 3 3v4m3-2 .917 11.923A1 1 0 0 1 17.92 21H6.08a1 1 0 0 1-.997-1.077L6 8h12Z"></path></svg>`), ShoppingBagOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ShoppingBagOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShoppingBagOutline);
  validate_prop_bindings($$props, [], [], ShoppingBagOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "shopping bag outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root479();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1479();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2479();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShoppingBagOutline = hmr(ShoppingBagOutline, () => ShoppingBagOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShoppingBagOutline[HMR].source;
    set(ShoppingBagOutline[HMR].source, module.default[HMR].original);
  });
}
var ShoppingBagOutline_default = ShoppingBagOutline;
mark_module_end(ShoppingBagOutline);

// node_modules/flowbite-svelte-icons/dist/ShoppingBagSolid.svelte
mark_module_start();
ShoppingBagSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShoppingBagSolid.svelte";
var root_1480 = add_locations(ns_template(`<title> </title>`), ShoppingBagSolid[FILENAME], [[39, 4]]);
var root_2480 = add_locations(ns_template(`<desc> </desc>`), ShoppingBagSolid[FILENAME], [[42, 4]]);
var root480 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M14 7h-4v3a1 1 0 0 1-2 0V7H6a1 1 0 0 0-.997.923l-.917 11.924A2 2 0 0 0 6.08 22h11.84a2 2 0 0 0 1.994-2.153l-.917-11.924A1 1 0 0 0 18 7h-2v3a1 1 0 1 1-2 0V7Zm-2-3a2 2 0 0 0-2 2v1H8V6a4 4 0 0 1 8 0v1h-2V6a2 2 0 0 0-2-2Z" clip-rule="evenodd"></path></svg>`), ShoppingBagSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ShoppingBagSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShoppingBagSolid);
  validate_prop_bindings($$props, [], [], ShoppingBagSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "shopping bag solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root480();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1480();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2480();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShoppingBagSolid = hmr(ShoppingBagSolid, () => ShoppingBagSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShoppingBagSolid[HMR].source;
    set(ShoppingBagSolid[HMR].source, module.default[HMR].original);
  });
}
var ShoppingBagSolid_default = ShoppingBagSolid;
mark_module_end(ShoppingBagSolid);

// node_modules/flowbite-svelte-icons/dist/ShuffleOutline.svelte
mark_module_start();
ShuffleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ShuffleOutline.svelte";
var root_1481 = add_locations(ns_template(`<title> </title>`), ShuffleOutline[FILENAME], [[41, 4]]);
var root_2481 = add_locations(ns_template(`<desc> </desc>`), ShuffleOutline[FILENAME], [[44, 4]]);
var root481 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13.484 9.166 15 7h5m0 0-3-3m3 3-3 3M4 17h4l1.577-2.253M4 7h4l7 10h5m0 0-3 3m3-3-3-3"></path></svg>`), ShuffleOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ShuffleOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ShuffleOutline);
  validate_prop_bindings($$props, [], [], ShuffleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "shuffle outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root481();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1481();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2481();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ShuffleOutline = hmr(ShuffleOutline, () => ShuffleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ShuffleOutline[HMR].source;
    set(ShuffleOutline[HMR].source, module.default[HMR].original);
  });
}
var ShuffleOutline_default = ShuffleOutline;
mark_module_end(ShuffleOutline);

// node_modules/flowbite-svelte-icons/dist/SortHorizontalOutline.svelte
mark_module_start();
SortHorizontalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SortHorizontalOutline.svelte";
var root_1482 = add_locations(ns_template(`<title> </title>`), SortHorizontalOutline[FILENAME], [[41, 4]]);
var root_2482 = add_locations(ns_template(`<desc> </desc>`), SortHorizontalOutline[FILENAME], [[44, 4]]);
var root482 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 16h13M4 16l4-4m-4 4 4 4M20 8H7m13 0-4 4m4-4-4-4"></path></svg>`), SortHorizontalOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function SortHorizontalOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SortHorizontalOutline);
  validate_prop_bindings($$props, [], [], SortHorizontalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "sort horizontal outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root482();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1482();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2482();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SortHorizontalOutline = hmr(SortHorizontalOutline, () => SortHorizontalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SortHorizontalOutline[HMR].source;
    set(SortHorizontalOutline[HMR].source, module.default[HMR].original);
  });
}
var SortHorizontalOutline_default = SortHorizontalOutline;
mark_module_end(SortHorizontalOutline);

// node_modules/flowbite-svelte-icons/dist/SortOutline.svelte
mark_module_start();
SortOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SortOutline.svelte";
var root_1483 = add_locations(ns_template(`<title> </title>`), SortOutline[FILENAME], [[41, 4]]);
var root_2483 = add_locations(ns_template(`<desc> </desc>`), SortOutline[FILENAME], [[44, 4]]);
var root483 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M8 20V10m0 10-3-3m3 3 3-3m5-13v10m0-10 3 3m-3-3-3 3"></path></svg>`), SortOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function SortOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SortOutline);
  validate_prop_bindings($$props, [], [], SortOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "sort outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root483();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1483();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2483();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SortOutline = hmr(SortOutline, () => SortOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SortOutline[HMR].source;
    set(SortOutline[HMR].source, module.default[HMR].original);
  });
}
var SortOutline_default = SortOutline;
mark_module_end(SortOutline);

// node_modules/flowbite-svelte-icons/dist/SplitCellsOutline.svelte
mark_module_start();
SplitCellsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SplitCellsOutline.svelte";
var root_1484 = add_locations(ns_template(`<title> </title>`), SplitCellsOutline[FILENAME], [[41, 4]]);
var root_2484 = add_locations(ns_template(`<desc> </desc>`), SplitCellsOutline[FILENAME], [[44, 4]]);
var root484 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M4 18v2h6V4H4v2m16 12v2h-6V4h6v2M6.49545 14.4954 4.00003 12m0 0 2.49542-2.49543M4.00003 12h5.94809m7.49798 2.5539L20 12m0 0-2.5539-2.55392M20 12h-5.8319"></path></svg>`), SplitCellsOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function SplitCellsOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SplitCellsOutline);
  validate_prop_bindings($$props, [], [], SplitCellsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "split cells outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root484();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1484();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2484();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SplitCellsOutline = hmr(SplitCellsOutline, () => SplitCellsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SplitCellsOutline[HMR].source;
    set(SplitCellsOutline[HMR].source, module.default[HMR].original);
  });
}
var SplitCellsOutline_default = SplitCellsOutline;
mark_module_end(SplitCellsOutline);

// node_modules/flowbite-svelte-icons/dist/StackoverflowSolid.svelte
mark_module_start();
StackoverflowSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StackoverflowSolid.svelte";
var root_1485 = add_locations(ns_template(`<title> </title>`), StackoverflowSolid[FILENAME], [[39, 4]]);
var root_2485 = add_locations(ns_template(`<desc> </desc>`), StackoverflowSolid[FILENAME], [[42, 4]]);
var root485 = add_locations(ns_template(`<svg><!><!><path d="M17 20v-5h2v6.988H3V15h1.98v5H17Z"></path><path d="m6.84 14.522 8.73 1.825.369-1.755-8.73-1.825-.369 1.755Zm1.155-4.323 8.083 3.764.739-1.617-8.083-3.787-.739 1.64Zm3.372-5.481L10.235 6.08l6.859 5.704 1.132-1.362-6.859-5.704ZM15.57 17H6.655v2h8.915v-2ZM12.861 3.111l6.193 6.415 1.414-1.415-6.43-6.177-1.177 1.177Z"></path></svg>`), StackoverflowSolid[FILENAME], [
  [29, 0, [[44, 2], [45, 2]]]
]);
function StackoverflowSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StackoverflowSolid);
  validate_prop_bindings($$props, [], [], StackoverflowSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "stackoverflow solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root485();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1485();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2485();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StackoverflowSolid = hmr(StackoverflowSolid, () => StackoverflowSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StackoverflowSolid[HMR].source;
    set(StackoverflowSolid[HMR].source, module.default[HMR].original);
  });
}
var StackoverflowSolid_default = StackoverflowSolid;
mark_module_end(StackoverflowSolid);

// node_modules/flowbite-svelte-icons/dist/StarHalfOutline.svelte
mark_module_start();
StarHalfOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarHalfOutline.svelte";
var root_1486 = add_locations(ns_template(`<title> </title>`), StarHalfOutline[FILENAME], [[41, 4]]);
var root_2486 = add_locations(ns_template(`<desc> </desc>`), StarHalfOutline[FILENAME], [[44, 4]]);
var root486 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" d="m12.25 20.825 4.247-2.436a1 1 0 0 0 .503-.867V4.03c0-.405-2.062 3.38-2.8 4.747a1 1 0 0 1-.807.523l-4.87.367c-.903.068-1.258 1.208-.55 1.776l3.576 2.878a1 1 0 0 1 .343 1.025l-1.11 4.366c-.217.856.701 1.553 1.468 1.113Z"></path></svg>`), StarHalfOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function StarHalfOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StarHalfOutline);
  validate_prop_bindings($$props, [], [], StarHalfOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "star half outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root486();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1486();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2486();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StarHalfOutline = hmr(StarHalfOutline, () => StarHalfOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarHalfOutline[HMR].source;
    set(StarHalfOutline[HMR].source, module.default[HMR].original);
  });
}
var StarHalfOutline_default = StarHalfOutline;
mark_module_end(StarHalfOutline);

// node_modules/flowbite-svelte-icons/dist/StarHalfSolid.svelte
mark_module_start();
StarHalfSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarHalfSolid.svelte";
var root_1487 = add_locations(ns_template(`<title> </title>`), StarHalfSolid[FILENAME], [[39, 4]]);
var root_2487 = add_locations(ns_template(`<desc> </desc>`), StarHalfSolid[FILENAME], [[42, 4]]);
var root487 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M13 4.024v-.005c0-.053.002-.353-.217-.632a1.013 1.013 0 0 0-1.176-.315c-.192.076-.315.193-.35.225-.052.05-.094.1-.122.134a4.358 4.358 0 0 0-.31.457c-.207.343-.484.84-.773 1.375a168.719 168.719 0 0 0-1.606 3.074h-.002l-4.599.367c-1.775.14-2.495 2.339-1.143 3.488L6.17 15.14l-1.06 4.406c-.412 1.72 1.472 3.078 2.992 2.157l3.94-2.388c.592-.359.958-.996.958-1.692v-13.6Zm-2.002 0v.025-.025Z" clip-rule="evenodd"></path></svg>`), StarHalfSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function StarHalfSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StarHalfSolid);
  validate_prop_bindings($$props, [], [], StarHalfSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "star half solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root487();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1487();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2487();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StarHalfSolid = hmr(StarHalfSolid, () => StarHalfSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarHalfSolid[HMR].source;
    set(StarHalfSolid[HMR].source, module.default[HMR].original);
  });
}
var StarHalfSolid_default = StarHalfSolid;
mark_module_end(StarHalfSolid);

// node_modules/flowbite-svelte-icons/dist/StarHalfStrokeOutline.svelte
mark_module_start();
StarHalfStrokeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarHalfStrokeOutline.svelte";
var root_1488 = add_locations(ns_template(`<title> </title>`), StarHalfStrokeOutline[FILENAME], [[41, 4]]);
var root_2488 = add_locations(ns_template(`<desc> </desc>`), StarHalfStrokeOutline[FILENAME], [[44, 4]]);
var root488 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" d="M12 4.392v14.832M8.476 9.38l-4.553.36c-.888.07-1.248 1.165-.572 1.737l3.47 2.934a.98.98 0 0 1 .322.98l-1.06 4.388c-.206.855.736 1.531 1.497 1.073l3.898-2.351c.32-.193.723-.193 1.044 0l3.898 2.351c.76.458 1.703-.218 1.497-1.073l-1.06-4.388a.982.982 0 0 1 .322-.98l3.47-2.934c.676-.572.316-1.667-.572-1.737l-4.553-.36a1 1 0 0 1-.845-.606l-1.754-4.165c-.342-.812-1.508-.812-1.85 0L9.321 8.774a1 1 0 0 1-.845.606Z"></path></svg>`), StarHalfStrokeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function StarHalfStrokeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StarHalfStrokeOutline);
  validate_prop_bindings($$props, [], [], StarHalfStrokeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "star half stroke outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root488();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1488();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2488();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StarHalfStrokeOutline = hmr(StarHalfStrokeOutline, () => StarHalfStrokeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarHalfStrokeOutline[HMR].source;
    set(StarHalfStrokeOutline[HMR].source, module.default[HMR].original);
  });
}
var StarHalfStrokeOutline_default = StarHalfStrokeOutline;
mark_module_end(StarHalfStrokeOutline);

// node_modules/flowbite-svelte-icons/dist/StarHalfStrokeSolid.svelte
mark_module_start();
StarHalfStrokeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarHalfStrokeSolid.svelte";
var root_1489 = add_locations(ns_template(`<title> </title>`), StarHalfStrokeSolid[FILENAME], [[39, 4]]);
var root_2489 = add_locations(ns_template(`<desc> </desc>`), StarHalfStrokeSolid[FILENAME], [[42, 4]]);
var root489 = add_locations(ns_template(`<svg><!><!><path d="m13.001 19.927 2.896 1.773c1.52.93 3.405-.442 2.992-2.179l-1.06-4.452 3.468-2.978c1.353-1.162.633-3.382-1.142-3.525L15.603 8.2l-1.754-4.226A1.973 1.973 0 0 0 13 3v16.927ZM10.999 3c-.36.205-.663.53-.848.974L8.397 8.2l-4.552.366c-1.775.143-2.495 2.363-1.142 3.525l3.468 2.978-1.06 4.452c-.413 1.737 1.472 3.11 2.992 2.178l2.896-1.773V3Z"></path></svg>`), StarHalfStrokeSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function StarHalfStrokeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StarHalfStrokeSolid);
  validate_prop_bindings($$props, [], [], StarHalfStrokeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "star half stroke solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root489();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1489();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2489();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StarHalfStrokeSolid = hmr(StarHalfStrokeSolid, () => StarHalfStrokeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarHalfStrokeSolid[HMR].source;
    set(StarHalfStrokeSolid[HMR].source, module.default[HMR].original);
  });
}
var StarHalfStrokeSolid_default = StarHalfStrokeSolid;
mark_module_end(StarHalfStrokeSolid);

// node_modules/flowbite-svelte-icons/dist/StarOutline.svelte
mark_module_start();
StarOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarOutline.svelte";
var root_1490 = add_locations(ns_template(`<title> </title>`), StarOutline[FILENAME], [[41, 4]]);
var root_2490 = add_locations(ns_template(`<desc> </desc>`), StarOutline[FILENAME], [[44, 4]]);
var root490 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" d="M11.083 5.104c.35-.8 1.485-.8 1.834 0l1.752 4.022a1 1 0 0 0 .84.597l4.463.342c.9.069 1.255 1.2.556 1.771l-3.33 2.723a1 1 0 0 0-.337 1.016l1.03 4.119c.214.858-.71 1.552-1.474 1.106l-3.913-2.281a1 1 0 0 0-1.008 0L7.583 20.8c-.764.446-1.688-.248-1.474-1.106l1.03-4.119A1 1 0 0 0 6.8 14.56l-3.33-2.723c-.698-.571-.342-1.702.557-1.771l4.462-.342a1 1 0 0 0 .84-.597l1.753-4.022Z"></path></svg>`), StarOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function StarOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StarOutline);
  validate_prop_bindings($$props, [], [], StarOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "star outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root490();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1490();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2490();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StarOutline = hmr(StarOutline, () => StarOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarOutline[HMR].source;
    set(StarOutline[HMR].source, module.default[HMR].original);
  });
}
var StarOutline_default = StarOutline;
mark_module_end(StarOutline);

// node_modules/flowbite-svelte-icons/dist/StarSolid.svelte
mark_module_start();
StarSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StarSolid.svelte";
var root_1491 = add_locations(ns_template(`<title> </title>`), StarSolid[FILENAME], [[39, 4]]);
var root_2491 = add_locations(ns_template(`<desc> </desc>`), StarSolid[FILENAME], [[42, 4]]);
var root491 = add_locations(ns_template(`<svg><!><!><path d="M13.849 4.22c-.684-1.626-3.014-1.626-3.698 0L8.397 8.387l-4.552.361c-1.775.14-2.495 2.331-1.142 3.477l3.468 2.937-1.06 4.392c-.413 1.713 1.472 3.067 2.992 2.149L12 19.35l3.897 2.354c1.52.918 3.405-.436 2.992-2.15l-1.06-4.39 3.468-2.938c1.353-1.146.633-3.336-1.142-3.477l-4.552-.36-1.754-4.17Z"></path></svg>`), StarSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function StarSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StarSolid);
  validate_prop_bindings($$props, [], [], StarSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "star solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root491();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1491();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2491();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StarSolid = hmr(StarSolid, () => StarSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StarSolid[HMR].source;
    set(StarSolid[HMR].source, module.default[HMR].original);
  });
}
var StarSolid_default = StarSolid;
mark_module_end(StarSolid);

// node_modules/flowbite-svelte-icons/dist/StopOutline.svelte
mark_module_start();
StopOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StopOutline.svelte";
var root_1492 = add_locations(ns_template(`<title> </title>`), StopOutline[FILENAME], [[41, 4]]);
var root_2492 = add_locations(ns_template(`<desc> </desc>`), StopOutline[FILENAME], [[44, 4]]);
var root492 = add_locations(ns_template(`<svg><!><!><rect width="12" height="12" x="6" y="6" stroke="currentColor" stroke-linejoin="round" rx="1"></rect></svg>`), StopOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function StopOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StopOutline);
  validate_prop_bindings($$props, [], [], StopOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "stop outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root492();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1492();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2492();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var rect = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(rect, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StopOutline = hmr(StopOutline, () => StopOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StopOutline[HMR].source;
    set(StopOutline[HMR].source, module.default[HMR].original);
  });
}
var StopOutline_default = StopOutline;
mark_module_end(StopOutline);

// node_modules/flowbite-svelte-icons/dist/StopSolid.svelte
mark_module_start();
StopSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StopSolid.svelte";
var root_1493 = add_locations(ns_template(`<title> </title>`), StopSolid[FILENAME], [[39, 4]]);
var root_2493 = add_locations(ns_template(`<desc> </desc>`), StopSolid[FILENAME], [[42, 4]]);
var root493 = add_locations(ns_template(`<svg><!><!><path d="M7 5a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2H7Z"></path></svg>`), StopSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function StopSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StopSolid);
  validate_prop_bindings($$props, [], [], StopSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "stop solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root493();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1493();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2493();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StopSolid = hmr(StopSolid, () => StopSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StopSolid[HMR].source;
    set(StopSolid[HMR].source, module.default[HMR].original);
  });
}
var StopSolid_default = StopSolid;
mark_module_end(StopSolid);

// node_modules/flowbite-svelte-icons/dist/StoreOutline.svelte
mark_module_start();
StoreOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StoreOutline.svelte";
var root_1494 = add_locations(ns_template(`<title> </title>`), StoreOutline[FILENAME], [[41, 4]]);
var root_2494 = add_locations(ns_template(`<desc> </desc>`), StoreOutline[FILENAME], [[44, 4]]);
var root494 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 12c.263 0 .524-.06.767-.175a2 2 0 0 0 .65-.491c.186-.21.333-.46.433-.734.1-.274.15-.568.15-.864a2.4 2.4 0 0 0 .586 1.591c.375.422.884.659 1.414.659.53 0 1.04-.237 1.414-.659A2.4 2.4 0 0 0 12 9.736a2.4 2.4 0 0 0 .586 1.591c.375.422.884.659 1.414.659.53 0 1.04-.237 1.414-.659A2.4 2.4 0 0 0 16 9.736c0 .295.052.588.152.861s.248.521.434.73a2 2 0 0 0 .649.488 1.809 1.809 0 0 0 1.53 0 2.03 2.03 0 0 0 .65-.488c.185-.209.332-.457.433-.73.1-.273.152-.566.152-.861 0-.974-1.108-3.85-1.618-5.121A.983.983 0 0 0 17.466 4H6.456a.986.986 0 0 0-.93.645C5.045 5.962 4 8.905 4 9.736c.023.59.241 1.148.611 1.567.37.418.865.667 1.389.697Zm0 0c.328 0 .651-.091.94-.266A2.1 2.1 0 0 0 7.66 11h.681a2.1 2.1 0 0 0 .718.734c.29.175.613.266.942.266.328 0 .651-.091.94-.266.29-.174.537-.427.719-.734h.681a2.1 2.1 0 0 0 .719.734c.289.175.612.266.94.266.329 0 .652-.091.942-.266.29-.174.536-.427.718-.734h.681c.183.307.43.56.719.734.29.174.613.266.941.266a1.819 1.819 0 0 0 1.06-.351M6 12a1.766 1.766 0 0 1-1.163-.476M5 12v7a1 1 0 0 0 1 1h2v-5h3v5h7a1 1 0 0 0 1-1v-7m-5 3v2h2v-2h-2Z"></path></svg>`), StoreOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function StoreOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StoreOutline);
  validate_prop_bindings($$props, [], [], StoreOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "store outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root494();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1494();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2494();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StoreOutline = hmr(StoreOutline, () => StoreOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StoreOutline[HMR].source;
    set(StoreOutline[HMR].source, module.default[HMR].original);
  });
}
var StoreOutline_default = StoreOutline;
mark_module_end(StoreOutline);

// node_modules/flowbite-svelte-icons/dist/StoreSolid.svelte
mark_module_start();
StoreSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/StoreSolid.svelte";
var root_1495 = add_locations(ns_template(`<title> </title>`), StoreSolid[FILENAME], [[39, 4]]);
var root_2495 = add_locations(ns_template(`<desc> </desc>`), StoreSolid[FILENAME], [[42, 4]]);
var root495 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5.535 7.677c.313-.98.687-2.023.926-2.677H17.46c.253.63.646 1.64.977 2.61.166.487.312.953.416 1.347.11.42.148.675.148.779 0 .18-.032.355-.09.515-.06.161-.144.3-.243.412-.1.111-.21.192-.324.245a.809.809 0 0 1-.686 0 1.004 1.004 0 0 1-.324-.245c-.1-.112-.183-.25-.242-.412a1.473 1.473 0 0 1-.091-.515 1 1 0 1 0-2 0 1.4 1.4 0 0 1-.333.927.896.896 0 0 1-.667.323.896.896 0 0 1-.667-.323A1.401 1.401 0 0 1 13 9.736a1 1 0 1 0-2 0 1.4 1.4 0 0 1-.333.927.896.896 0 0 1-.667.323.896.896 0 0 1-.667-.323A1.4 1.4 0 0 1 9 9.74v-.008a1 1 0 0 0-2 .003v.008a1.504 1.504 0 0 1-.18.712 1.22 1.22 0 0 1-.146.209l-.007.007a1.01 1.01 0 0 1-.325.248.82.82 0 0 1-.316.08.973.973 0 0 1-.563-.256 1.224 1.224 0 0 1-.102-.103A1.518 1.518 0 0 1 5 9.724v-.006a2.543 2.543 0 0 1 .029-.207c.024-.132.06-.296.11-.49.098-.385.237-.85.395-1.344ZM4 12.112a3.521 3.521 0 0 1-1-2.376c0-.349.098-.8.202-1.208.112-.441.264-.95.428-1.46.327-1.024.715-2.104.958-2.767A1.985 1.985 0 0 1 6.456 3h11.01c.803 0 1.539.481 1.844 1.243.258.641.67 1.697 1.019 2.72a22.3 22.3 0 0 1 .457 1.487c.114.433.214.903.214 1.286 0 .412-.072.821-.214 1.207A3.288 3.288 0 0 1 20 12.16V19a2 2 0 0 1-2 2h-6a1 1 0 0 1-1-1v-4H8v4a1 1 0 0 1-1 1H6a2 2 0 0 1-2-2v-6.888ZM13 15a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2Z" clip-rule="evenodd"></path></svg>`), StoreSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function StoreSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, StoreSolid);
  validate_prop_bindings($$props, [], [], StoreSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "store solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root495();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1495();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2495();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  StoreSolid = hmr(StoreSolid, () => StoreSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = StoreSolid[HMR].source;
    set(StoreSolid[HMR].source, module.default[HMR].original);
  });
}
var StoreSolid_default = StoreSolid;
mark_module_end(StoreSolid);

// node_modules/flowbite-svelte-icons/dist/SubscriptOutline.svelte
mark_module_start();
SubscriptOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SubscriptOutline.svelte";
var root_1496 = add_locations(ns_template(`<title> </title>`), SubscriptOutline[FILENAME], [[41, 4]]);
var root_2496 = add_locations(ns_template(`<desc> </desc>`), SubscriptOutline[FILENAME], [[44, 4]]);
var root496 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20 20h-4v-.5c1.0989-1.0329 3.75-2.5 3.75-3.5v-1.0001c0-.5523-.4477-.9999-1-.9999H17c-.5522 0-1 .4477-1 1M4.00004 4l9.12206 11.3932m0-11.3932L4 15.3932"></path></svg>`), SubscriptOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function SubscriptOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SubscriptOutline);
  validate_prop_bindings($$props, [], [], SubscriptOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "subscript outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root496();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1496();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2496();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SubscriptOutline = hmr(SubscriptOutline, () => SubscriptOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SubscriptOutline[HMR].source;
    set(SubscriptOutline[HMR].source, module.default[HMR].original);
  });
}
var SubscriptOutline_default = SubscriptOutline;
mark_module_end(SubscriptOutline);

// node_modules/flowbite-svelte-icons/dist/SunOutline.svelte
mark_module_start();
SunOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SunOutline.svelte";
var root_1497 = add_locations(ns_template(`<title> </title>`), SunOutline[FILENAME], [[41, 4]]);
var root_2497 = add_locations(ns_template(`<desc> </desc>`), SunOutline[FILENAME], [[44, 4]]);
var root497 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5V3m0 18v-2M7.05 7.05 5.636 5.636m12.728 12.728L16.95 16.95M5 12H3m18 0h-2M7.05 16.95l-1.414 1.414M18.364 5.636 16.95 7.05M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"></path></svg>`), SunOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function SunOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SunOutline);
  validate_prop_bindings($$props, [], [], SunOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "sun outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root497();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1497();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2497();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SunOutline = hmr(SunOutline, () => SunOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SunOutline[HMR].source;
    set(SunOutline[HMR].source, module.default[HMR].original);
  });
}
var SunOutline_default = SunOutline;
mark_module_end(SunOutline);

// node_modules/flowbite-svelte-icons/dist/SunSolid.svelte
mark_module_start();
SunSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SunSolid.svelte";
var root_1498 = add_locations(ns_template(`<title> </title>`), SunSolid[FILENAME], [[39, 4]]);
var root_2498 = add_locations(ns_template(`<desc> </desc>`), SunSolid[FILENAME], [[42, 4]]);
var root498 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M13 3a1 1 0 1 0-2 0v2a1 1 0 1 0 2 0V3ZM6.343 4.929A1 1 0 0 0 4.93 6.343l1.414 1.414a1 1 0 0 0 1.414-1.414L6.343 4.929Zm12.728 1.414a1 1 0 0 0-1.414-1.414l-1.414 1.414a1 1 0 0 0 1.414 1.414l1.414-1.414ZM12 7a5 5 0 1 0 0 10 5 5 0 0 0 0-10Zm-9 4a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2H3Zm16 0a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2h-2ZM7.757 17.657a1 1 0 1 0-1.414-1.414l-1.414 1.414a1 1 0 1 0 1.414 1.414l1.414-1.414Zm9.9-1.414a1 1 0 0 0-1.414 1.414l1.414 1.414a1 1 0 0 0 1.414-1.414l-1.414-1.414ZM13 19a1 1 0 1 0-2 0v2a1 1 0 1 0 2 0v-2Z" clip-rule="evenodd"></path></svg>`), SunSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function SunSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SunSolid);
  validate_prop_bindings($$props, [], [], SunSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "sun solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root498();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1498();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2498();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SunSolid = hmr(SunSolid, () => SunSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SunSolid[HMR].source;
    set(SunSolid[HMR].source, module.default[HMR].original);
  });
}
var SunSolid_default = SunSolid;
mark_module_end(SunSolid);

// node_modules/flowbite-svelte-icons/dist/SuperscriptOutline.svelte
mark_module_start();
SuperscriptOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SuperscriptOutline.svelte";
var root_1499 = add_locations(ns_template(`<title> </title>`), SuperscriptOutline[FILENAME], [[41, 4]]);
var root_2499 = add_locations(ns_template(`<desc> </desc>`), SuperscriptOutline[FILENAME], [[44, 4]]);
var root499 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M20 10h-4v-.5C17.0989 8.46711 19.75 7 19.75 6V4.99989c0-.55228-.4477-.99989-1-.99989H17c-.5523 0-1 .44772-1 1M4 7.30341l9.1221 11.39319m0-11.39319L4 18.6966"></path></svg>`), SuperscriptOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function SuperscriptOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SuperscriptOutline);
  validate_prop_bindings($$props, [], [], SuperscriptOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "superscript outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root499();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1499();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2499();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SuperscriptOutline = hmr(SuperscriptOutline, () => SuperscriptOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SuperscriptOutline[HMR].source;
    set(SuperscriptOutline[HMR].source, module.default[HMR].original);
  });
}
var SuperscriptOutline_default = SuperscriptOutline;
mark_module_end(SuperscriptOutline);

// node_modules/flowbite-svelte-icons/dist/SwatchbookOutline.svelte
mark_module_start();
SwatchbookOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SwatchbookOutline.svelte";
var root_1500 = add_locations(ns_template(`<title> </title>`), SwatchbookOutline[FILENAME], [[41, 4]]);
var root_2500 = add_locations(ns_template(`<desc> </desc>`), SwatchbookOutline[FILENAME], [[44, 4]]);
var root500 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M7.111 20A3.111 3.111 0 0 1 4 16.889v-12C4 4.398 4.398 4 4.889 4h4.444a.89.89 0 0 1 .89.889v12A3.111 3.111 0 0 1 7.11 20Zm0 0h12a.889.889 0 0 0 .889-.889v-4.444a.889.889 0 0 0-.889-.89h-4.389a.889.889 0 0 0-.62.253l-3.767 3.665a.933.933 0 0 0-.146.185c-.868 1.433-1.581 1.858-3.078 2.12Zm0-3.556h.009m7.933-10.927 3.143 3.143a.889.889 0 0 1 0 1.257l-7.974 7.974v-8.8l3.574-3.574a.889.889 0 0 1 1.257 0Z"></path></svg>`), SwatchbookOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function SwatchbookOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SwatchbookOutline);
  validate_prop_bindings($$props, [], [], SwatchbookOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "swatchbook outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root500();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1500();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2500();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SwatchbookOutline = hmr(SwatchbookOutline, () => SwatchbookOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SwatchbookOutline[HMR].source;
    set(SwatchbookOutline[HMR].source, module.default[HMR].original);
  });
}
var SwatchbookOutline_default = SwatchbookOutline;
mark_module_end(SwatchbookOutline);

// node_modules/flowbite-svelte-icons/dist/SwatchbookSolid.svelte
mark_module_start();
SwatchbookSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/SwatchbookSolid.svelte";
var root_1501 = add_locations(ns_template(`<title> </title>`), SwatchbookSolid[FILENAME], [[39, 4]]);
var root_2501 = add_locations(ns_template(`<desc> </desc>`), SwatchbookSolid[FILENAME], [[42, 4]]);
var root501 = add_locations(ns_template(`<svg><!><!><path d="M20 14h-2.722L11 20.278a5.511 5.511 0 0 1-.9.722H20a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1ZM9 3H4a1 1 0 0 0-1 1v13.5a3.5 3.5 0 1 0 7 0V4a1 1 0 0 0-1-1ZM6.5 18.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2ZM19.132 7.9 15.6 4.368a1 1 0 0 0-1.414 0L12 6.55v9.9l7.132-7.132a1 1 0 0 0 0-1.418Z"></path></svg>`), SwatchbookSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function SwatchbookSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, SwatchbookSolid);
  validate_prop_bindings($$props, [], [], SwatchbookSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "swatchbook solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root501();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1501();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2501();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  SwatchbookSolid = hmr(SwatchbookSolid, () => SwatchbookSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = SwatchbookSolid[HMR].source;
    set(SwatchbookSolid[HMR].source, module.default[HMR].original);
  });
}
var SwatchbookSolid_default = SwatchbookSolid;
mark_module_end(SwatchbookSolid);

// node_modules/flowbite-svelte-icons/dist/TShirtOutline.svelte
mark_module_start();
TShirtOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TShirtOutline.svelte";
var root_1502 = add_locations(ns_template(`<title> </title>`), TShirtOutline[FILENAME], [[41, 4]]);
var root_2502 = add_locations(ns_template(`<desc> </desc>`), TShirtOutline[FILENAME], [[44, 4]]);
var root502 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M9 5h-.16667c-.86548 0-1.70761.28071-2.4.8L3.5 8l2 3.5L8 10v9h8v-9l2.5 1.5 2-3.5-2.9333-2.2c-.6924-.51929-1.5346-.8-2.4-.8H15M9 5c0 1.5 1.5 3 3 3s3-1.5 3-3M9 5h6"></path></svg>`), TShirtOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TShirtOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TShirtOutline);
  validate_prop_bindings($$props, [], [], TShirtOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "t shirt outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root502();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1502();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2502();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TShirtOutline = hmr(TShirtOutline, () => TShirtOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TShirtOutline[HMR].source;
    set(TShirtOutline[HMR].source, module.default[HMR].original);
  });
}
var TShirtOutline_default = TShirtOutline;
mark_module_end(TShirtOutline);

// node_modules/flowbite-svelte-icons/dist/TShirtSolid.svelte
mark_module_start();
TShirtSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TShirtSolid.svelte";
var root_1503 = add_locations(ns_template(`<title> </title>`), TShirtSolid[FILENAME], [[39, 4]]);
var root_2503 = add_locations(ns_template(`<desc> </desc>`), TShirtSolid[FILENAME], [[42, 4]]);
var root503 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5.833 5a5 5 0 0 1 3-1h6.334a5 5 0 0 1 3 1L21.1 7.2a1 1 0 0 1 .268 1.296l-2 3.5a1 1 0 0 1-1.382.361l-.986-.59V19a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1v-7.234l-.985.591a1 1 0 0 1-1.383-.36l-2-3.5A1 1 0 0 1 2.9 7.2L5.833 5ZM14 5h-4c0 .425.223.933.645 1.355.422.423.93.645 1.355.645.425 0 .933-.222 1.355-.645.423-.422.645-.93.645-1.355Z" clip-rule="evenodd"></path></svg>`), TShirtSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TShirtSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TShirtSolid);
  validate_prop_bindings($$props, [], [], TShirtSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "t shirt solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root503();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1503();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2503();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TShirtSolid = hmr(TShirtSolid, () => TShirtSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TShirtSolid[HMR].source;
    set(TShirtSolid[HMR].source, module.default[HMR].original);
  });
}
var TShirtSolid_default = TShirtSolid;
mark_module_end(TShirtSolid);

// node_modules/flowbite-svelte-icons/dist/TableColumnOutline.svelte
mark_module_start();
TableColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TableColumnOutline.svelte";
var root_1504 = add_locations(ns_template(`<title> </title>`), TableColumnOutline[FILENAME], [[41, 4]]);
var root_2504 = add_locations(ns_template(`<desc> </desc>`), TableColumnOutline[FILENAME], [[44, 4]]);
var root504 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" d="M3 11h18m-9 0v8m-8 0h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), TableColumnOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TableColumnOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TableColumnOutline);
  validate_prop_bindings($$props, [], [], TableColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "table column outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root504();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1504();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2504();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableColumnOutline = hmr(TableColumnOutline, () => TableColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableColumnOutline[HMR].source;
    set(TableColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var TableColumnOutline_default = TableColumnOutline;
mark_module_end(TableColumnOutline);

// node_modules/flowbite-svelte-icons/dist/TableColumnSolid.svelte
mark_module_start();
TableColumnSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TableColumnSolid.svelte";
var root_1505 = add_locations(ns_template(`<title> </title>`), TableColumnSolid[FILENAME], [[39, 4]]);
var root_2505 = add_locations(ns_template(`<desc> </desc>`), TableColumnSolid[FILENAME], [[42, 4]]);
var root505 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4Zm0 8v6h7v-6H4Zm16 6h-7v-6h7v6Z" clip-rule="evenodd"></path></svg>`), TableColumnSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TableColumnSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TableColumnSolid);
  validate_prop_bindings($$props, [], [], TableColumnSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "table column solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root505();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1505();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2505();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableColumnSolid = hmr(TableColumnSolid, () => TableColumnSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableColumnSolid[HMR].source;
    set(TableColumnSolid[HMR].source, module.default[HMR].original);
  });
}
var TableColumnSolid_default = TableColumnSolid;
mark_module_end(TableColumnSolid);

// node_modules/flowbite-svelte-icons/dist/TableRowOutline.svelte
mark_module_start();
TableRowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TableRowOutline.svelte";
var root_1506 = add_locations(ns_template(`<title> </title>`), TableRowOutline[FILENAME], [[41, 4]]);
var root_2506 = add_locations(ns_template(`<desc> </desc>`), TableRowOutline[FILENAME], [[44, 4]]);
var root506 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" d="M3 11h18M3 15h18m-9-4v8m-8 0h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), TableRowOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TableRowOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TableRowOutline);
  validate_prop_bindings($$props, [], [], TableRowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "table row outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root506();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1506();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2506();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableRowOutline = hmr(TableRowOutline, () => TableRowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableRowOutline[HMR].source;
    set(TableRowOutline[HMR].source, module.default[HMR].original);
  });
}
var TableRowOutline_default = TableRowOutline;
mark_module_end(TableRowOutline);

// node_modules/flowbite-svelte-icons/dist/TableRowSolid.svelte
mark_module_start();
TableRowSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TableRowSolid.svelte";
var root_1507 = add_locations(ns_template(`<title> </title>`), TableRowSolid[FILENAME], [[39, 4]]);
var root_2507 = add_locations(ns_template(`<desc> </desc>`), TableRowSolid[FILENAME], [[42, 4]]);
var root507 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2 6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6Zm2 8v-2h7v2H4Zm0 2v2h7v-2H4Zm9 2h7v-2h-7v2Zm7-4v-2h-7v2h7Z" clip-rule="evenodd"></path></svg>`), TableRowSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TableRowSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TableRowSolid);
  validate_prop_bindings($$props, [], [], TableRowSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "table row solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root507();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1507();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2507();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TableRowSolid = hmr(TableRowSolid, () => TableRowSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TableRowSolid[HMR].source;
    set(TableRowSolid[HMR].source, module.default[HMR].original);
  });
}
var TableRowSolid_default = TableRowSolid;
mark_module_end(TableRowSolid);

// node_modules/flowbite-svelte-icons/dist/TabletOutline.svelte
mark_module_start();
TabletOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TabletOutline.svelte";
var root_1508 = add_locations(ns_template(`<title> </title>`), TabletOutline[FILENAME], [[41, 4]]);
var root_2508 = add_locations(ns_template(`<desc> </desc>`), TabletOutline[FILENAME], [[44, 4]]);
var root508 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M11 18h2M5.875 3h12.25c.483 0 .875.448.875 1v16c0 .552-.392 1-.875 1H5.875C5.392 21 5 20.552 5 20V4c0-.552.392-1 .875-1Z"></path></svg>`), TabletOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TabletOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TabletOutline);
  validate_prop_bindings($$props, [], [], TabletOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "tablet outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root508();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1508();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2508();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TabletOutline = hmr(TabletOutline, () => TabletOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TabletOutline[HMR].source;
    set(TabletOutline[HMR].source, module.default[HMR].original);
  });
}
var TabletOutline_default = TabletOutline;
mark_module_end(TabletOutline);

// node_modules/flowbite-svelte-icons/dist/TabletSolid.svelte
mark_module_start();
TabletSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TabletSolid.svelte";
var root_1509 = add_locations(ns_template(`<title> </title>`), TabletSolid[FILENAME], [[39, 4]]);
var root_2509 = add_locations(ns_template(`<desc> </desc>`), TabletSolid[FILENAME], [[42, 4]]);
var root509 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 4c0-.975.718-2 1.875-2h12.25C19.282 2 20 3.025 20 4v16c0 .975-.718 2-1.875 2H5.875C4.718 22 4 20.975 4 20V4Zm7 13a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2h-2Z" clip-rule="evenodd"></path></svg>`), TabletSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TabletSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TabletSolid);
  validate_prop_bindings($$props, [], [], TabletSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "tablet solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root509();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1509();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2509();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TabletSolid = hmr(TabletSolid, () => TabletSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TabletSolid[HMR].source;
    set(TabletSolid[HMR].source, module.default[HMR].original);
  });
}
var TabletSolid_default = TabletSolid;
mark_module_end(TabletSolid);

// node_modules/flowbite-svelte-icons/dist/TagOutline.svelte
mark_module_start();
TagOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TagOutline.svelte";
var root_1510 = add_locations(ns_template(`<title> </title>`), TagOutline[FILENAME], [[41, 4]]);
var root_2510 = add_locations(ns_template(`<desc> </desc>`), TagOutline[FILENAME], [[44, 4]]);
var root510 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.583 8.445h.01M10.86 19.71l-6.573-6.63a.993.993 0 0 1 0-1.4l7.329-7.394A.98.98 0 0 1 12.31 4l5.734.007A1.968 1.968 0 0 1 20 5.983v5.5a.992.992 0 0 1-.316.727l-7.44 7.5a.974.974 0 0 1-1.384.001Z"></path></svg>`), TagOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TagOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TagOutline);
  validate_prop_bindings($$props, [], [], TagOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "tag outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root510();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1510();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2510();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TagOutline = hmr(TagOutline, () => TagOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TagOutline[HMR].source;
    set(TagOutline[HMR].source, module.default[HMR].original);
  });
}
var TagOutline_default = TagOutline;
mark_module_end(TagOutline);

// node_modules/flowbite-svelte-icons/dist/TagSolid.svelte
mark_module_start();
TagSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TagSolid.svelte";
var root_1511 = add_locations(ns_template(`<title> </title>`), TagSolid[FILENAME], [[39, 4]]);
var root_2511 = add_locations(ns_template(`<desc> </desc>`), TagSolid[FILENAME], [[42, 4]]);
var root511 = add_locations(ns_template(`<svg><!><!><path d="M18.045 3.007 12.31 3a1.965 1.965 0 0 0-1.4.585l-7.33 7.394a2 2 0 0 0 0 2.805l6.573 6.631a1.957 1.957 0 0 0 1.4.585 1.965 1.965 0 0 0 1.4-.585l7.409-7.477A2 2 0 0 0 21 11.479v-5.5a2.972 2.972 0 0 0-2.955-2.972Zm-2.452 6.438a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>`), TagSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TagSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TagSolid);
  validate_prop_bindings($$props, [], [], TagSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "tag solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root511();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1511();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2511();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TagSolid = hmr(TagSolid, () => TagSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TagSolid[HMR].source;
    set(TagSolid[HMR].source, module.default[HMR].original);
  });
}
var TagSolid_default = TagSolid;
mark_module_end(TagSolid);

// node_modules/flowbite-svelte-icons/dist/TailwindSolid.svelte
mark_module_start();
TailwindSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TailwindSolid.svelte";
var root_1512 = add_locations(ns_template(`<title> </title>`), TailwindSolid[FILENAME], [[39, 4]]);
var root_2512 = add_locations(ns_template(`<desc> </desc>`), TailwindSolid[FILENAME], [[42, 4]]);
var root512 = add_locations(ns_template(`<svg><!><!><path d="M11.782 5.72a4.773 4.773 0 0 0-4.8 4.173 3.43 3.43 0 0 1 2.741-1.687c1.689 0 2.974 1.972 3.758 2.587a5.733 5.733 0 0 0 5.382.935c2-.638 2.934-2.865 3.137-3.921-.969 1.379-2.44 2.207-4.259 1.231-1.253-.673-2.19-3.438-5.959-3.318ZM6.8 11.979A4.772 4.772 0 0 0 2 16.151a3.431 3.431 0 0 1 2.745-1.687c1.689 0 2.974 1.972 3.758 2.587a5.733 5.733 0 0 0 5.382.935c2-.638 2.933-2.865 3.137-3.921-.97 1.379-2.44 2.208-4.259 1.231-1.253-.673-2.19-3.443-5.963-3.317Z"></path></svg>`), TailwindSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TailwindSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TailwindSolid);
  validate_prop_bindings($$props, [], [], TailwindSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "tailwind solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root512();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1512();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2512();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TailwindSolid = hmr(TailwindSolid, () => TailwindSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TailwindSolid[HMR].source;
    set(TailwindSolid[HMR].source, module.default[HMR].original);
  });
}
var TailwindSolid_default = TailwindSolid;
mark_module_end(TailwindSolid);

// node_modules/flowbite-svelte-icons/dist/TeddyBearOutline.svelte
mark_module_start();
TeddyBearOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TeddyBearOutline.svelte";
var root_1513 = add_locations(ns_template(`<title> </title>`), TeddyBearOutline[FILENAME], [[41, 4]]);
var root_2513 = add_locations(ns_template(`<desc> </desc>`), TeddyBearOutline[FILENAME], [[44, 4]]);
var root513 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7.5 15C6.11929 15 5 16.1193 5 17.5S6.11929 20 7.5 20s2.5-1.1193 2.5-2.5S8.88071 15 7.5 15Zm0 0 1.67693-4.1693m6.69787-3.82761C17.0117 7.00309 18 6.10457 18 5c0-1.10457-.9217-2-2.0586-2-.8963 0-1.6853.74312-1.9679 1.51992M8.12719 6.99544C7.00181 6.99544 6 6.10457 6 5s.9123-2 2.03768-2c.93446 0 1.70666.67806 1.94698 1.51992M14 18h-4m6-3-1.4578-3.8912m-6.63506 2.8789-.44889.1929C6.24889 14.5837 5 13.6836 5 12.4088c0-.8339.55278-1.5667 1.35457-1.7958L8.5 10m7.1055 3.9877.4133.1446c1.2127.4242 2.4812-.476 2.4812-1.7607 0-.8159-.5302-1.5371-1.309-1.7805l-1.7458-.5575M12 9.06243v-.01m-1.3779-1.55397v-.01m3.0337.01v-.01M16 8c0 2.2091-1.7909 4-4 4-2.20914 0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091 0 4 1.79086 4 4Zm3 9.5c0 1.3807-1.1193 2.5-2.5 2.5S14 18.8807 14 17.5s1.1193-2.5 2.5-2.5 2.5 1.1193 2.5 2.5Z"></path></svg>`), TeddyBearOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TeddyBearOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TeddyBearOutline);
  validate_prop_bindings($$props, [], [], TeddyBearOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "teddy bear outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root513();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1513();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2513();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TeddyBearOutline = hmr(TeddyBearOutline, () => TeddyBearOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TeddyBearOutline[HMR].source;
    set(TeddyBearOutline[HMR].source, module.default[HMR].original);
  });
}
var TeddyBearOutline_default = TeddyBearOutline;
mark_module_end(TeddyBearOutline);

// node_modules/flowbite-svelte-icons/dist/TeddyBearSolid.svelte
mark_module_start();
TeddyBearSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TeddyBearSolid.svelte";
var root_1514 = add_locations(ns_template(`<title> </title>`), TeddyBearSolid[FILENAME], [[39, 4]]);
var root_2514 = add_locations(ns_template(`<desc> </desc>`), TeddyBearSolid[FILENAME], [[42, 4]]);
var root514 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M10.451 3.244C9.911 2.514 9.052 2 8.038 2 6.378 2 5 3.326 5 5c0 1.315.88 2.36 2.004 2.787a5.082 5.082 0 0 0 .177 1.55L6.08 9.65a2.868 2.868 0 0 0-.802 5.145A3.5 3.5 0 1 0 10.663 19h2.674a3.5 3.5 0 1 0 5.11-4.409 2.865 2.865 0 0 0-.954-4.953l-.696-.223a5.002 5.002 0 0 0 .2-1.588l-.001-.031C18.128 7.367 19 6.311 19 5c0-1.684-1.397-3-3.059-3-1.005 0-1.841.554-2.384 1.247A4.996 4.996 0 0 0 12 3c-.54 0-1.061.086-1.549.244ZM8.685 4.257c-.49.435-.895.964-1.184 1.56C7.193 5.624 7 5.304 7 5c0-.535.447-1 1.038-1a.99.99 0 0 1 .647.257ZM17 5c0 .31-.19.63-.497.824a5.017 5.017 0 0 0-1.174-1.555c.197-.169.423-.269.612-.269C16.553 4 17 4.475 17 5Zm-2 12.5a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0Zm-9 0a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0Zm5.043-10.012a.5.5 0 0 0-1 0v.01a.5.5 0 0 0 1 0v-.01Zm3.023.01a.5.5 0 0 0-1 0v.01a.5.5 0 1 0 1 0v-.01ZM13 9.052a1 1 0 1 0-2 0v.01a1 1 0 1 0 2 0v-.01Z" clip-rule="evenodd"></path></svg>`), TeddyBearSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TeddyBearSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TeddyBearSolid);
  validate_prop_bindings($$props, [], [], TeddyBearSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "teddy bear solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root514();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1514();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2514();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TeddyBearSolid = hmr(TeddyBearSolid, () => TeddyBearSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TeddyBearSolid[HMR].source;
    set(TeddyBearSolid[HMR].source, module.default[HMR].original);
  });
}
var TeddyBearSolid_default = TeddyBearSolid;
mark_module_end(TeddyBearSolid);

// node_modules/flowbite-svelte-icons/dist/TerminalOutline.svelte
mark_module_start();
TerminalOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TerminalOutline.svelte";
var root_1515 = add_locations(ns_template(`<title> </title>`), TerminalOutline[FILENAME], [[41, 4]]);
var root_2515 = add_locations(ns_template(`<desc> </desc>`), TerminalOutline[FILENAME], [[44, 4]]);
var root515 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m8 9 3 3-3 3m5 0h3M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), TerminalOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TerminalOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TerminalOutline);
  validate_prop_bindings($$props, [], [], TerminalOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "terminal outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root515();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1515();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2515();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TerminalOutline = hmr(TerminalOutline, () => TerminalOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TerminalOutline[HMR].source;
    set(TerminalOutline[HMR].source, module.default[HMR].original);
  });
}
var TerminalOutline_default = TerminalOutline;
mark_module_end(TerminalOutline);

// node_modules/flowbite-svelte-icons/dist/TerminalSolid.svelte
mark_module_start();
TerminalSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TerminalSolid.svelte";
var root_1516 = add_locations(ns_template(`<title> </title>`), TerminalSolid[FILENAME], [[39, 4]]);
var root_2516 = add_locations(ns_template(`<desc> </desc>`), TerminalSolid[FILENAME], [[42, 4]]);
var root516 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M3 4a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H3Zm4.293 5.707a1 1 0 0 1 1.414-1.414l3 3a1 1 0 0 1 0 1.414l-3 3a1 1 0 0 1-1.414-1.414L9.586 12 7.293 9.707ZM13 14a1 1 0 1 0 0 2h3a1 1 0 1 0 0-2h-3Z" clip-rule="evenodd"></path></svg>`), TerminalSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TerminalSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TerminalSolid);
  validate_prop_bindings($$props, [], [], TerminalSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "terminal solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root516();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1516();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2516();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TerminalSolid = hmr(TerminalSolid, () => TerminalSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TerminalSolid[HMR].source;
    set(TerminalSolid[HMR].source, module.default[HMR].original);
  });
}
var TerminalSolid_default = TerminalSolid;
mark_module_end(TerminalSolid);

// node_modules/flowbite-svelte-icons/dist/TextSizeOutline.svelte
mark_module_start();
TextSizeOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TextSizeOutline.svelte";
var root_1517 = add_locations(ns_template(`<title> </title>`), TextSizeOutline[FILENAME], [[41, 4]]);
var root_2517 = add_locations(ns_template(`<desc> </desc>`), TextSizeOutline[FILENAME], [[44, 4]]);
var root517 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 6.2V5h11v1.2M8 5v14m-3 0h6m2-6.8V11h8v1.2M17 11v8m-1.5 0h3"></path></svg>`), TextSizeOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TextSizeOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TextSizeOutline);
  validate_prop_bindings($$props, [], [], TextSizeOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "text size outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root517();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1517();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2517();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TextSizeOutline = hmr(TextSizeOutline, () => TextSizeOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextSizeOutline[HMR].source;
    set(TextSizeOutline[HMR].source, module.default[HMR].original);
  });
}
var TextSizeOutline_default = TextSizeOutline;
mark_module_end(TextSizeOutline);

// node_modules/flowbite-svelte-icons/dist/TextSlashOutline.svelte
mark_module_start();
TextSlashOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TextSlashOutline.svelte";
var root_1518 = add_locations(ns_template(`<title> </title>`), TextSlashOutline[FILENAME], [[41, 4]]);
var root_2518 = add_locations(ns_template(`<desc> </desc>`), TextSlashOutline[FILENAME], [[44, 4]]);
var root518 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 6.2V5h12v1.2M7 19h6m.2-14-1.677 6.523M9.6 19l1.029-4M5 5l6.523 6.523M19 19l-7.477-7.477"></path></svg>`), TextSlashOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TextSlashOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TextSlashOutline);
  validate_prop_bindings($$props, [], [], TextSlashOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "text slash outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root518();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1518();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2518();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TextSlashOutline = hmr(TextSlashOutline, () => TextSlashOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextSlashOutline[HMR].source;
    set(TextSlashOutline[HMR].source, module.default[HMR].original);
  });
}
var TextSlashOutline_default = TextSlashOutline;
mark_module_end(TextSlashOutline);

// node_modules/flowbite-svelte-icons/dist/TextUnderlineOutline.svelte
mark_module_start();
TextUnderlineOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TextUnderlineOutline.svelte";
var root_1519 = add_locations(ns_template(`<title> </title>`), TextUnderlineOutline[FILENAME], [[41, 4]]);
var root_2519 = add_locations(ns_template(`<desc> </desc>`), TextUnderlineOutline[FILENAME], [[44, 4]]);
var root519 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 19h14M7.6 16l4.2979-10.92963c.0368-.09379.1674-.09379.2042 0L16.4 16m-8.8 0H6.5m1.1 0h1.65m7.15 0h-1.65m1.65 0h1.1m-8.33315-4h5.66025"></path></svg>`), TextUnderlineOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TextUnderlineOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TextUnderlineOutline);
  validate_prop_bindings($$props, [], [], TextUnderlineOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "text underline outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root519();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1519();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2519();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TextUnderlineOutline = hmr(TextUnderlineOutline, () => TextUnderlineOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TextUnderlineOutline[HMR].source;
    set(TextUnderlineOutline[HMR].source, module.default[HMR].original);
  });
}
var TextUnderlineOutline_default = TextUnderlineOutline;
mark_module_end(TextUnderlineOutline);

// node_modules/flowbite-svelte-icons/dist/ThumbsDownOutline.svelte
mark_module_start();
ThumbsDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbsDownOutline.svelte";
var root_1520 = add_locations(ns_template(`<title> </title>`), ThumbsDownOutline[FILENAME], [[41, 4]]);
var root_2520 = add_locations(ns_template(`<desc> </desc>`), ThumbsDownOutline[FILENAME], [[44, 4]]);
var root520 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 13c-.889.086-1.416.543-2.156 1.057a22.322 22.322 0 0 0-3.958 5.084 1.6 1.6 0 0 1-.582.628 1.549 1.549 0 0 1-1.466.087 1.587 1.587 0 0 1-.537-.406 1.666 1.666 0 0 1-.384-1.279l1.389-4.114M17 13h3V6.5A1.5 1.5 0 0 0 18.5 5v0A1.5 1.5 0 0 0 17 6.5V13Zm-6.5 1H5.585c-.286 0-.372-.014-.626-.15a1.797 1.797 0 0 1-.637-.572 1.873 1.873 0 0 1-.215-1.673l2.098-6.4C6.462 4.48 6.632 4 7.88 4c2.302 0 4.79.943 6.67 1.475"></path></svg>`), ThumbsDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ThumbsDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ThumbsDownOutline);
  validate_prop_bindings($$props, [], [], ThumbsDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "thumbs down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root520();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1520();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2520();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ThumbsDownOutline = hmr(ThumbsDownOutline, () => ThumbsDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbsDownOutline[HMR].source;
    set(ThumbsDownOutline[HMR].source, module.default[HMR].original);
  });
}
var ThumbsDownOutline_default = ThumbsDownOutline;
mark_module_end(ThumbsDownOutline);

// node_modules/flowbite-svelte-icons/dist/ThumbsDownSolid.svelte
mark_module_start();
ThumbsDownSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbsDownSolid.svelte";
var root_1521 = add_locations(ns_template(`<title> </title>`), ThumbsDownSolid[FILENAME], [[39, 4]]);
var root_2521 = add_locations(ns_template(`<desc> </desc>`), ThumbsDownSolid[FILENAME], [[42, 4]]);
var root521 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8.97 14.316H5.004c-.322 0-.64-.08-.925-.232a2.022 2.022 0 0 1-.717-.645 2.108 2.108 0 0 1-.242-1.883l2.36-7.201C5.769 3.54 5.96 3 7.365 3c2.072 0 4.276.678 6.156 1.256.473.145.925.284 1.35.404h.114v9.862a25.485 25.485 0 0 0-4.238 5.514c-.197.376-.516.67-.901.83a1.74 1.74 0 0 1-1.21.048 1.79 1.79 0 0 1-.96-.757 1.867 1.867 0 0 1-.269-1.211l1.562-4.63ZM19.822 14H17V6a2 2 0 1 1 4 0v6.823c0 .65-.527 1.177-1.177 1.177Z" clip-rule="evenodd"></path></svg>`), ThumbsDownSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ThumbsDownSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ThumbsDownSolid);
  validate_prop_bindings($$props, [], [], ThumbsDownSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "thumbs down solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root521();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1521();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2521();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ThumbsDownSolid = hmr(ThumbsDownSolid, () => ThumbsDownSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbsDownSolid[HMR].source;
    set(ThumbsDownSolid[HMR].source, module.default[HMR].original);
  });
}
var ThumbsDownSolid_default = ThumbsDownSolid;
mark_module_end(ThumbsDownSolid);

// node_modules/flowbite-svelte-icons/dist/ThumbsUpOutline.svelte
mark_module_start();
ThumbsUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbsUpOutline.svelte";
var root_1522 = add_locations(ns_template(`<title> </title>`), ThumbsUpOutline[FILENAME], [[41, 4]]);
var root_2522 = add_locations(ns_template(`<desc> </desc>`), ThumbsUpOutline[FILENAME], [[44, 4]]);
var root522 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M7 11c.889-.086 1.416-.543 2.156-1.057a22.323 22.323 0 0 0 3.958-5.084 1.6 1.6 0 0 1 .582-.628 1.549 1.549 0 0 1 1.466-.087c.205.095.388.233.537.406a1.64 1.64 0 0 1 .384 1.279l-1.388 4.114M7 11H4v6.5A1.5 1.5 0 0 0 5.5 19v0A1.5 1.5 0 0 0 7 17.5V11Zm6.5-1h4.915c.286 0 .372.014.626.15.254.135.472.332.637.572a1.874 1.874 0 0 1 .215 1.673l-2.098 6.4C17.538 19.52 17.368 20 16.12 20c-2.303 0-4.79-.943-6.67-1.475"></path></svg>`), ThumbsUpOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ThumbsUpOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ThumbsUpOutline);
  validate_prop_bindings($$props, [], [], ThumbsUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "thumbs up outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root522();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1522();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2522();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ThumbsUpOutline = hmr(ThumbsUpOutline, () => ThumbsUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbsUpOutline[HMR].source;
    set(ThumbsUpOutline[HMR].source, module.default[HMR].original);
  });
}
var ThumbsUpOutline_default = ThumbsUpOutline;
mark_module_end(ThumbsUpOutline);

// node_modules/flowbite-svelte-icons/dist/ThumbsUpSolid.svelte
mark_module_start();
ThumbsUpSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbsUpSolid.svelte";
var root_1523 = add_locations(ns_template(`<title> </title>`), ThumbsUpSolid[FILENAME], [[39, 4]]);
var root_2523 = add_locations(ns_template(`<desc> </desc>`), ThumbsUpSolid[FILENAME], [[42, 4]]);
var root523 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M15.03 9.684h3.965c.322 0 .64.08.925.232.286.153.532.374.717.645a2.109 2.109 0 0 1 .242 1.883l-2.36 7.201c-.288.814-.48 1.355-1.884 1.355-2.072 0-4.276-.677-6.157-1.256-.472-.145-.924-.284-1.348-.404h-.115V9.478a25.485 25.485 0 0 0 4.238-5.514 1.8 1.8 0 0 1 .901-.83 1.74 1.74 0 0 1 1.21-.048c.396.13.736.397.96.757.225.36.32.788.269 1.211l-1.562 4.63ZM4.177 10H7v8a2 2 0 1 1-4 0v-6.823C3 10.527 3.527 10 4.176 10Z" clip-rule="evenodd"></path></svg>`), ThumbsUpSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ThumbsUpSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ThumbsUpSolid);
  validate_prop_bindings($$props, [], [], ThumbsUpSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "thumbs up solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root523();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1523();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2523();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ThumbsUpSolid = hmr(ThumbsUpSolid, () => ThumbsUpSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbsUpSolid[HMR].source;
    set(ThumbsUpSolid[HMR].source, module.default[HMR].original);
  });
}
var ThumbsUpSolid_default = ThumbsUpSolid;
mark_module_end(ThumbsUpSolid);

// node_modules/flowbite-svelte-icons/dist/ThumbtackOutline.svelte
mark_module_start();
ThumbtackOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbtackOutline.svelte";
var root_1524 = add_locations(ns_template(`<title> </title>`), ThumbtackOutline[FILENAME], [[41, 4]]);
var root_2524 = add_locations(ns_template(`<desc> </desc>`), ThumbtackOutline[FILENAME], [[44, 4]]);
var root524 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M12.0001 20v-4M7.00012 4h9.99998M9.00012 5v5c0 .5523-.46939 1.0045-.94861 1.279-1.43433.8217-2.60135 3.245-2.25635 4.3653.07806.2535.35396.3557.61917.3557H17.5859c.2652 0 .5411-.1022.6192-.3557.3449-1.1204-.8221-3.5436-2.2564-4.3653-.4792-.2745-.9486-.7267-.9486-1.279V5c0-.55228-.4477-1-1-1h-4c-.55226 0-.99998.44772-.99998 1Z"></path></svg>`), ThumbtackOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ThumbtackOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ThumbtackOutline);
  validate_prop_bindings($$props, [], [], ThumbtackOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "thumbtack outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root524();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1524();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2524();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ThumbtackOutline = hmr(ThumbtackOutline, () => ThumbtackOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbtackOutline[HMR].source;
    set(ThumbtackOutline[HMR].source, module.default[HMR].original);
  });
}
var ThumbtackOutline_default = ThumbtackOutline;
mark_module_end(ThumbtackOutline);

// node_modules/flowbite-svelte-icons/dist/ThumbtackSolid.svelte
mark_module_start();
ThumbtackSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ThumbtackSolid.svelte";
var root_1525 = add_locations(ns_template(`<title> </title>`), ThumbtackSolid[FILENAME], [[39, 4]]);
var root_2525 = add_locations(ns_template(`<desc> </desc>`), ThumbtackSolid[FILENAME], [[42, 4]]);
var root525 = add_locations(ns_template(`<svg><!><!><path d="M8 5v4.997a.31.31 0 0 1-.068.113c-.08.098-.213.207-.378.301-.947.543-1.713 1.54-2.191 2.488A6.237 6.237 0 0 0 4.82 14.4c-.1.48-.138 1.031.018 1.539C5.12 16.846 6.02 17 6.414 17H11v3a1 1 0 1 0 2 0v-3h4.586c.395 0 1.295-.154 1.575-1.061.156-.508.118-1.059.017-1.539a6.241 6.241 0 0 0-.541-1.5c-.479-.95-1.244-1.946-2.191-2.489a1.393 1.393 0 0 1-.378-.301.309.309 0 0 1-.068-.113V5h1a1 1 0 1 0 0-2H7a1 1 0 1 0 0 2h1Z"></path></svg>`), ThumbtackSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ThumbtackSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ThumbtackSolid);
  validate_prop_bindings($$props, [], [], ThumbtackSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "thumbtack solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root525();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1525();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2525();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ThumbtackSolid = hmr(ThumbtackSolid, () => ThumbtackSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ThumbtackSolid[HMR].source;
    set(ThumbtackSolid[HMR].source, module.default[HMR].original);
  });
}
var ThumbtackSolid_default = ThumbtackSolid;
mark_module_end(ThumbtackSolid);

// node_modules/flowbite-svelte-icons/dist/TicketOutline.svelte
mark_module_start();
TicketOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TicketOutline.svelte";
var root_1526 = add_locations(ns_template(`<title> </title>`), TicketOutline[FILENAME], [[41, 4]]);
var root_2526 = add_locations(ns_template(`<desc> </desc>`), TicketOutline[FILENAME], [[44, 4]]);
var root526 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M18.5 12A2.5 2.5 0 0 1 21 9.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v2.5a2.5 2.5 0 0 1 0 5V17a1 1 0 0 0 1 1h16a1 1 0 0 0 1-1v-2.5a2.5 2.5 0 0 1-2.5-2.5Z"></path></svg>`), TicketOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TicketOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TicketOutline);
  validate_prop_bindings($$props, [], [], TicketOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "ticket outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root526();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1526();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2526();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TicketOutline = hmr(TicketOutline, () => TicketOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TicketOutline[HMR].source;
    set(TicketOutline[HMR].source, module.default[HMR].original);
  });
}
var TicketOutline_default = TicketOutline;
mark_module_end(TicketOutline);

// node_modules/flowbite-svelte-icons/dist/TicketSolid.svelte
mark_module_start();
TicketSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TicketSolid.svelte";
var root_1527 = add_locations(ns_template(`<title> </title>`), TicketSolid[FILENAME], [[39, 4]]);
var root_2527 = add_locations(ns_template(`<desc> </desc>`), TicketSolid[FILENAME], [[42, 4]]);
var root527 = add_locations(ns_template(`<svg><!><!><path d="M4 5a2 2 0 0 0-2 2v2.5a1 1 0 0 0 1 1 1.5 1.5 0 1 1 0 3 1 1 0 0 0-1 1V17a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2.5a1 1 0 0 0-1-1 1.5 1.5 0 1 1 0-3 1 1 0 0 0 1-1V7a2 2 0 0 0-2-2H4Z"></path></svg>`), TicketSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TicketSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TicketSolid);
  validate_prop_bindings($$props, [], [], TicketSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "ticket solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root527();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1527();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2527();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TicketSolid = hmr(TicketSolid, () => TicketSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TicketSolid[HMR].source;
    set(TicketSolid[HMR].source, module.default[HMR].original);
  });
}
var TicketSolid_default = TicketSolid;
mark_module_end(TicketSolid);

// node_modules/flowbite-svelte-icons/dist/ToggleHeaderCellOutline.svelte
mark_module_start();
ToggleHeaderCellOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ToggleHeaderCellOutline.svelte";
var root_1528 = add_locations(ns_template(`<title> </title>`), ToggleHeaderCellOutline[FILENAME], [[41, 4]]);
var root_2528 = add_locations(ns_template(`<desc> </desc>`), ToggleHeaderCellOutline[FILENAME], [[44, 4]]);
var root528 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h10M3 15v-4m0 4h9m-9-4V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v3M3 11h11m-2-.2079V19m3-4h1.9909M21 15c0 1.1046-.8954 2-2 2s-2-.8954-2-2 .8954-2 2-2 2 .8954 2 2Z"></path></svg>`), ToggleHeaderCellOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ToggleHeaderCellOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ToggleHeaderCellOutline);
  validate_prop_bindings($$props, [], [], ToggleHeaderCellOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "toggle header cell outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root528();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1528();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2528();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToggleHeaderCellOutline = hmr(ToggleHeaderCellOutline, () => ToggleHeaderCellOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToggleHeaderCellOutline[HMR].source;
    set(ToggleHeaderCellOutline[HMR].source, module.default[HMR].original);
  });
}
var ToggleHeaderCellOutline_default = ToggleHeaderCellOutline;
mark_module_end(ToggleHeaderCellOutline);

// node_modules/flowbite-svelte-icons/dist/ToggleHeaderColumnOutline.svelte
mark_module_start();
ToggleHeaderColumnOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ToggleHeaderColumnOutline.svelte";
var root_1529 = add_locations(ns_template(`<title> </title>`), ToggleHeaderColumnOutline[FILENAME], [[41, 4]]);
var root_2529 = add_locations(ns_template(`<desc> </desc>`), ToggleHeaderColumnOutline[FILENAME], [[44, 4]]);
var root529 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15 5v14m6-8h-6m6 4h-6m-9-3h1.99093M4 19h16c.5523 0 1-.4477 1-1V6c0-.55228-.4477-1-1-1H4c-.55228 0-1 .44772-1 1v12c0 .5523.44772 1 1 1Zm8-7c0 1.1046-.8954 2-2 2-1.10457 0-2-.8954-2-2s.89543-2 2-2c1.1046 0 2 .8954 2 2Z"></path></svg>`), ToggleHeaderColumnOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ToggleHeaderColumnOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ToggleHeaderColumnOutline);
  validate_prop_bindings($$props, [], [], ToggleHeaderColumnOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "toggle header column outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root529();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1529();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2529();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToggleHeaderColumnOutline = hmr(ToggleHeaderColumnOutline, () => ToggleHeaderColumnOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToggleHeaderColumnOutline[HMR].source;
    set(ToggleHeaderColumnOutline[HMR].source, module.default[HMR].original);
  });
}
var ToggleHeaderColumnOutline_default = ToggleHeaderColumnOutline;
mark_module_end(ToggleHeaderColumnOutline);

// node_modules/flowbite-svelte-icons/dist/ToggleHeaderRowOutline.svelte
mark_module_start();
ToggleHeaderRowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ToggleHeaderRowOutline.svelte";
var root_1530 = add_locations(ns_template(`<title> </title>`), ToggleHeaderRowOutline[FILENAME], [[41, 4]]);
var root_2530 = add_locations(ns_template(`<desc> </desc>`), ToggleHeaderRowOutline[FILENAME], [[44, 4]]);
var root530 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 15v3c0 .5523.44772 1 1 1h16c.5523 0 1-.4477 1-1v-3M3 15V6c0-.55228.44772-1 1-1h16c.5523 0 1 .44772 1 1v9M3 15h18M8 15v4m4-4v4m4-4v4m-7-9h1.9909M15 10c0 1.1046-.8954 2-2 2s-2-.8954-2-2c0-1.10457.8954-2 2-2s2 .89543 2 2Z"></path></svg>`), ToggleHeaderRowOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ToggleHeaderRowOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ToggleHeaderRowOutline);
  validate_prop_bindings($$props, [], [], ToggleHeaderRowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "toggle header row outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root530();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1530();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2530();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToggleHeaderRowOutline = hmr(ToggleHeaderRowOutline, () => ToggleHeaderRowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToggleHeaderRowOutline[HMR].source;
    set(ToggleHeaderRowOutline[HMR].source, module.default[HMR].original);
  });
}
var ToggleHeaderRowOutline_default = ToggleHeaderRowOutline;
mark_module_end(ToggleHeaderRowOutline);

// node_modules/flowbite-svelte-icons/dist/ToolsOutline.svelte
mark_module_start();
ToolsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ToolsOutline.svelte";
var root_1531 = add_locations(ns_template(`<title> </title>`), ToolsOutline[FILENAME], [[41, 4]]);
var root_2531 = add_locations(ns_template(`<desc> </desc>`), ToolsOutline[FILENAME], [[44, 4]]);
var root531 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linejoin="round" d="M7.58209 8.96025 9.8136 11.1917l-1.61782 1.6178c-1.08305-.1811-2.23623.1454-3.07364.9828-1.1208 1.1208-1.32697 2.8069-.62368 4.1363.14842.2806.42122.474.73509.5213.06726.0101.1347.0133.20136.0098-.00351.0666-.00036.1341.00977.2013.04724.3139.24069.5867.52125.7351 1.32944.7033 3.01552.4971 4.13627-.6237.8375-.8374 1.1639-1.9906.9829-3.0736l4.8107-4.8108c1.0831.1811 2.2363-.1454 3.0737-.9828 1.1208-1.1208 1.3269-2.80688.6237-4.13632-.1485-.28056-.4213-.474-.7351-.52125-.0673-.01012-.1347-.01327-.2014-.00977.0035-.06666.0004-.13409-.0098-.20136-.0472-.31386-.2406-.58666-.5212-.73508-1.3294-.70329-3.0155-.49713-4.1363.62367-.8374.83741-1.1639 1.9906-.9828 3.07365l-1.7788 1.77875-2.23152-2.23148-1.41419 1.41424Zm1.31056-3.1394c-.04235-.32684-.24303-.61183-.53647-.76186l-1.98183-1.0133c-.38619-.19746-.85564-.12345-1.16234.18326l-.86321.8632c-.3067.3067-.38072.77616-.18326 1.16235l1.0133 1.98182c.15004.29345.43503.49412.76187.53647l1.1127.14418c.3076.03985.61628-.06528.8356-.28461l.86321-.8632c.21932-.21932.32446-.52801.2846-.83561l-.14417-1.1127ZM19.4448 16.4052l-3.1186-3.1187c-.7811-.781-2.0474-.781-2.8285 0l-.1719.172c-.7811.781-.7811 2.0474 0 2.8284l3.1186 3.1187c.7811.781 2.0474.781 2.8285 0l.1719-.172c.7811-.781.7811-2.0474 0-2.8284Z"></path></svg>`), ToolsOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ToolsOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ToolsOutline);
  validate_prop_bindings($$props, [], [], ToolsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "tools outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root531();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1531();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2531();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ToolsOutline = hmr(ToolsOutline, () => ToolsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ToolsOutline[HMR].source;
    set(ToolsOutline[HMR].source, module.default[HMR].original);
  });
}
var ToolsOutline_default = ToolsOutline;
mark_module_end(ToolsOutline);

// node_modules/flowbite-svelte-icons/dist/TrackingOutline.svelte
mark_module_start();
TrackingOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TrackingOutline.svelte";
var root_1532 = add_locations(ns_template(`<title> </title>`), TrackingOutline[FILENAME], [[41, 4]]);
var root_2532 = add_locations(ns_template(`<desc> </desc>`), TrackingOutline[FILENAME], [[44, 4]]);
var root532 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M5 19h4m6 0h4m-6.9627-4.3843V8.63418L17 5.93918m-4.9298 2.66213L7.04175 5.93919M12 2.99719l5.033 2.90583v5.81168L12 14.6205l-5.03303-2.9058V5.90302L12 2.99719ZM14 19c0 1.1045-.8954 2-2 2s-2-.8955-2-2c0-1.1046.8954-2 2-2s2 .8954 2 2Z"></path></svg>`), TrackingOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TrackingOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TrackingOutline);
  validate_prop_bindings($$props, [], [], TrackingOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "tracking outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root532();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1532();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2532();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TrackingOutline = hmr(TrackingOutline, () => TrackingOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrackingOutline[HMR].source;
    set(TrackingOutline[HMR].source, module.default[HMR].original);
  });
}
var TrackingOutline_default = TrackingOutline;
mark_module_end(TrackingOutline);

// node_modules/flowbite-svelte-icons/dist/TrackingSolid.svelte
mark_module_start();
TrackingSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TrackingSolid.svelte";
var root_1533 = add_locations(ns_template(`<title> </title>`), TrackingSolid[FILENAME], [[39, 4]]);
var root_2533 = add_locations(ns_template(`<desc> </desc>`), TrackingSolid[FILENAME], [[42, 4]]);
var root533 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9.166 19.986A.915.915 0 0 1 9 20H5a1 1 0 1 1 0-2h4c.057 0 .112.005.166.014a3.001 3.001 0 0 1 5.668 0A.915.915 0 0 1 15 18h4a1 1 0 1 1 0 2h-4c-.056 0-.112-.005-.166-.014a3.001 3.001 0 0 1-5.668 0ZM11 19a1 1 0 1 1 2 0 1 1 0 0 1-2 0Z" clip-rule="evenodd"></path><path d="M11.5 2.131a1 1 0 0 1 1 0l4.601 2.657c-.06.018-.12.044-.179.075L12.08 7.475 6.946 4.76 11.5 2.131ZM5.967 6.505v5.21a1 1 0 0 0 .5.866l4.57 2.638V9.186l-5.07-2.681Zm7.07 8.671 4.496-2.595a1 1 0 0 0 .5-.866v-5.2a1 1 0 0 1-.161.108l-4.835 2.608v5.945Z"></path></svg>`), TrackingSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function TrackingSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TrackingSolid);
  validate_prop_bindings($$props, [], [], TrackingSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "tracking solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root533();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1533();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2533();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TrackingSolid = hmr(TrackingSolid, () => TrackingSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrackingSolid[HMR].source;
    set(TrackingSolid[HMR].source, module.default[HMR].original);
  });
}
var TrackingSolid_default = TrackingSolid;
mark_module_end(TrackingSolid);

// node_modules/flowbite-svelte-icons/dist/TrashBinOutline.svelte
mark_module_start();
TrashBinOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TrashBinOutline.svelte";
var root_1534 = add_locations(ns_template(`<title> </title>`), TrashBinOutline[FILENAME], [[41, 4]]);
var root_2534 = add_locations(ns_template(`<desc> </desc>`), TrashBinOutline[FILENAME], [[44, 4]]);
var root534 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M5 7h14m-9 3v8m4-8v8M10 3h4a1 1 0 0 1 1 1v3H9V4a1 1 0 0 1 1-1ZM6 7h12v13a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V7Z"></path></svg>`), TrashBinOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TrashBinOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TrashBinOutline);
  validate_prop_bindings($$props, [], [], TrashBinOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "trash bin outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root534();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1534();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2534();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TrashBinOutline = hmr(TrashBinOutline, () => TrashBinOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrashBinOutline[HMR].source;
    set(TrashBinOutline[HMR].source, module.default[HMR].original);
  });
}
var TrashBinOutline_default = TrashBinOutline;
mark_module_end(TrashBinOutline);

// node_modules/flowbite-svelte-icons/dist/TrashBinSolid.svelte
mark_module_start();
TrashBinSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TrashBinSolid.svelte";
var root_1535 = add_locations(ns_template(`<title> </title>`), TrashBinSolid[FILENAME], [[39, 4]]);
var root_2535 = add_locations(ns_template(`<desc> </desc>`), TrashBinSolid[FILENAME], [[42, 4]]);
var root535 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8.586 2.586A2 2 0 0 1 10 2h4a2 2 0 0 1 2 2v2h3a1 1 0 1 1 0 2v12a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V8a1 1 0 0 1 0-2h3V4a2 2 0 0 1 .586-1.414ZM10 6h4V4h-4v2Zm1 4a1 1 0 1 0-2 0v8a1 1 0 1 0 2 0v-8Zm4 0a1 1 0 1 0-2 0v8a1 1 0 1 0 2 0v-8Z" clip-rule="evenodd"></path></svg>`), TrashBinSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TrashBinSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TrashBinSolid);
  validate_prop_bindings($$props, [], [], TrashBinSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "trash bin solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root535();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1535();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2535();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TrashBinSolid = hmr(TrashBinSolid, () => TrashBinSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TrashBinSolid[HMR].source;
    set(TrashBinSolid[HMR].source, module.default[HMR].original);
  });
}
var TrashBinSolid_default = TrashBinSolid;
mark_module_end(TrashBinSolid);

// node_modules/flowbite-svelte-icons/dist/TruckClockOutline.svelte
mark_module_start();
TruckClockOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TruckClockOutline.svelte";
var root_1536 = add_locations(ns_template(`<title> </title>`), TruckClockOutline[FILENAME], [[41, 4]]);
var root_2536 = add_locations(ns_template(`<desc> </desc>`), TruckClockOutline[FILENAME], [[44, 4]]);
var root536 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13 7h6l2 4m-8-4v8H9m4-8V6c0-.26522-.1054-.51957-.2929-.70711C12.5196 5.10536 12.2652 5 12 5H4c-.26522 0-.51957.10536-.70711.29289C3.10536 5.48043 3 5.73478 3 6v9h2m14 0h2v-4m0 0h-5M8 8.66669V10l1.5 1.5m10 5c0 1.3807-1.1193 2.5-2.5 2.5s-2.5-1.1193-2.5-2.5S15.6193 14 17 14s2.5 1.1193 2.5 2.5Zm-10 0C9.5 17.8807 8.38071 19 7 19s-2.5-1.1193-2.5-2.5S5.61929 14 7 14s2.5 1.1193 2.5 2.5Z"></path></svg>`), TruckClockOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TruckClockOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TruckClockOutline);
  validate_prop_bindings($$props, [], [], TruckClockOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "truck clock outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root536();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1536();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2536();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TruckClockOutline = hmr(TruckClockOutline, () => TruckClockOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TruckClockOutline[HMR].source;
    set(TruckClockOutline[HMR].source, module.default[HMR].original);
  });
}
var TruckClockOutline_default = TruckClockOutline;
mark_module_end(TruckClockOutline);

// node_modules/flowbite-svelte-icons/dist/TruckClockSolid.svelte
mark_module_start();
TruckClockSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TruckClockSolid.svelte";
var root_1537 = add_locations(ns_template(`<title> </title>`), TruckClockSolid[FILENAME], [[39, 4]]);
var root_2537 = add_locations(ns_template(`<desc> </desc>`), TruckClockSolid[FILENAME], [[42, 4]]);
var root537 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M2.586 4.586A2 2 0 0 1 4 4h8a2 2 0 0 1 2 2h5a1 1 0 0 1 .894.553l2 4c.07.139.106.292.106.447v4a1 1 0 0 1-1 1h-.535a3.5 3.5 0 1 1-6.93 0h-3.07a3.5 3.5 0 1 1-6.93 0H3a1 1 0 0 1-1-1V6a2 2 0 0 1 .586-1.414ZM18.208 15.61a1.497 1.497 0 0 0-2.416 0 1.5 1.5 0 1 0 2.416 0Zm-10 0a1.498 1.498 0 0 0-2.416 0 1.5 1.5 0 1 0 2.416 0Zm5.79-7.612v2.02h5.396l-1-2.02h-4.396ZM9 8.667a1 1 0 1 0-2 0V10a1 1 0 0 0 .293.707l1.5 1.5a1 1 0 0 0 1.414-1.414L9 9.586v-.92Z" clip-rule="evenodd"></path></svg>`), TruckClockSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TruckClockSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TruckClockSolid);
  validate_prop_bindings($$props, [], [], TruckClockSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "truck clock solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root537();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1537();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2537();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TruckClockSolid = hmr(TruckClockSolid, () => TruckClockSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TruckClockSolid[HMR].source;
    set(TruckClockSolid[HMR].source, module.default[HMR].original);
  });
}
var TruckClockSolid_default = TruckClockSolid;
mark_module_end(TruckClockSolid);

// node_modules/flowbite-svelte-icons/dist/TruckOutline.svelte
mark_module_start();
TruckOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TruckOutline.svelte";
var root_1538 = add_locations(ns_template(`<title> </title>`), TruckOutline[FILENAME], [[41, 4]]);
var root_2538 = add_locations(ns_template(`<desc> </desc>`), TruckOutline[FILENAME], [[44, 4]]);
var root538 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M13 7h6l2 4m-8-4v8m0-8V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v9h2m8 0H9m4 0h2m4 0h2v-4m0 0h-5m3.5 5.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Zm-10 0a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Z"></path></svg>`), TruckOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function TruckOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TruckOutline);
  validate_prop_bindings($$props, [], [], TruckOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "truck outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root538();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1538();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2538();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TruckOutline = hmr(TruckOutline, () => TruckOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TruckOutline[HMR].source;
    set(TruckOutline[HMR].source, module.default[HMR].original);
  });
}
var TruckOutline_default = TruckOutline;
mark_module_end(TruckOutline);

// node_modules/flowbite-svelte-icons/dist/TruckSolid.svelte
mark_module_start();
TruckSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TruckSolid.svelte";
var root_1539 = add_locations(ns_template(`<title> </title>`), TruckSolid[FILENAME], [[39, 4]]);
var root_2539 = add_locations(ns_template(`<desc> </desc>`), TruckSolid[FILENAME], [[42, 4]]);
var root539 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v9a1 1 0 0 0 1 1h.535a3.5 3.5 0 1 0 6.93 0h3.07a3.5 3.5 0 1 0 6.93 0H21a1 1 0 0 0 1-1v-4a.999.999 0 0 0-.106-.447l-2-4A1 1 0 0 0 19 6h-5a2 2 0 0 0-2-2H4Zm14.192 11.59.016.02a1.5 1.5 0 1 1-.016-.021Zm-10 0 .016.02a1.5 1.5 0 1 1-.016-.021Zm5.806-5.572v-2.02h4.396l1 2.02h-5.396Z" clip-rule="evenodd"></path></svg>`), TruckSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TruckSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TruckSolid);
  validate_prop_bindings($$props, [], [], TruckSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "truck solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root539();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1539();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2539();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TruckSolid = hmr(TruckSolid, () => TruckSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TruckSolid[HMR].source;
    set(TruckSolid[HMR].source, module.default[HMR].original);
  });
}
var TruckSolid_default = TruckSolid;
mark_module_end(TruckSolid);

// node_modules/flowbite-svelte-icons/dist/TwitterSolid.svelte
mark_module_start();
TwitterSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/TwitterSolid.svelte";
var root_1540 = add_locations(ns_template(`<title> </title>`), TwitterSolid[FILENAME], [[39, 4]]);
var root_2540 = add_locations(ns_template(`<desc> </desc>`), TwitterSolid[FILENAME], [[42, 4]]);
var root540 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M22 5.892a8.178 8.178 0 0 1-2.355.635 4.074 4.074 0 0 0 1.8-2.235 8.343 8.343 0 0 1-2.605.981A4.13 4.13 0 0 0 15.85 4a4.068 4.068 0 0 0-4.1 4.038c0 .31.035.618.105.919A11.705 11.705 0 0 1 3.4 4.734a4.006 4.006 0 0 0 1.268 5.392 4.165 4.165 0 0 1-1.859-.5v.05A4.057 4.057 0 0 0 6.1 13.635a4.192 4.192 0 0 1-1.856.07 4.108 4.108 0 0 0 3.831 2.807A8.36 8.36 0 0 1 2 18.184 11.732 11.732 0 0 0 8.291 20 11.502 11.502 0 0 0 19.964 8.5c0-.177 0-.349-.012-.523A8.143 8.143 0 0 0 22 5.892Z" clip-rule="evenodd"></path></svg>`), TwitterSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function TwitterSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, TwitterSolid);
  validate_prop_bindings($$props, [], [], TwitterSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "twitter solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root540();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1540();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2540();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  TwitterSolid = hmr(TwitterSolid, () => TwitterSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = TwitterSolid[HMR].source;
    set(TwitterSolid[HMR].source, module.default[HMR].original);
  });
}
var TwitterSolid_default = TwitterSolid;
mark_module_end(TwitterSolid);

// node_modules/flowbite-svelte-icons/dist/UndoOutline.svelte
mark_module_start();
UndoOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UndoOutline.svelte";
var root_1541 = add_locations(ns_template(`<title> </title>`), UndoOutline[FILENAME], [[41, 4]]);
var root_2541 = add_locations(ns_template(`<desc> </desc>`), UndoOutline[FILENAME], [[44, 4]]);
var root541 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M3 9h13a5 5 0 0 1 0 10H7M3 9l4-4M3 9l4 4"></path></svg>`), UndoOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UndoOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UndoOutline);
  validate_prop_bindings($$props, [], [], UndoOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "undo outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root541();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1541();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2541();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UndoOutline = hmr(UndoOutline, () => UndoOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UndoOutline[HMR].source;
    set(UndoOutline[HMR].source, module.default[HMR].original);
  });
}
var UndoOutline_default = UndoOutline;
mark_module_end(UndoOutline);

// node_modules/flowbite-svelte-icons/dist/UploadOutline.svelte
mark_module_start();
UploadOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UploadOutline.svelte";
var root_1542 = add_locations(ns_template(`<title> </title>`), UploadOutline[FILENAME], [[41, 4]]);
var root_2542 = add_locations(ns_template(`<desc> </desc>`), UploadOutline[FILENAME], [[44, 4]]);
var root542 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 5v9m-5 0H5a1 1 0 0 0-1 1v4a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-4a1 1 0 0 0-1-1h-2M8 9l4-5 4 5m1 8h.01"></path></svg>`), UploadOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UploadOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UploadOutline);
  validate_prop_bindings($$props, [], [], UploadOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "upload outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root542();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1542();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2542();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UploadOutline = hmr(UploadOutline, () => UploadOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UploadOutline[HMR].source;
    set(UploadOutline[HMR].source, module.default[HMR].original);
  });
}
var UploadOutline_default = UploadOutline;
mark_module_end(UploadOutline);

// node_modules/flowbite-svelte-icons/dist/UploadSolid.svelte
mark_module_start();
UploadSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UploadSolid.svelte";
var root_1543 = add_locations(ns_template(`<title> </title>`), UploadSolid[FILENAME], [[39, 4]]);
var root_2543 = add_locations(ns_template(`<desc> </desc>`), UploadSolid[FILENAME], [[42, 4]]);
var root543 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 3a1 1 0 0 1 .78.375l4 5a1 1 0 1 1-1.56 1.25L13 6.85V14a1 1 0 1 1-2 0V6.85L8.78 9.626a1 1 0 1 1-1.56-1.25l4-5A1 1 0 0 1 12 3ZM9 14v-1H5a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2h-4v1a3 3 0 1 1-6 0Zm8 2a1 1 0 1 0 0 2h.01a1 1 0 1 0 0-2H17Z" clip-rule="evenodd"></path></svg>`), UploadSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UploadSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UploadSolid);
  validate_prop_bindings($$props, [], [], UploadSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "upload solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root543();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1543();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2543();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UploadSolid = hmr(UploadSolid, () => UploadSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UploadSolid[HMR].source;
    set(UploadSolid[HMR].source, module.default[HMR].original);
  });
}
var UploadSolid_default = UploadSolid;
mark_module_end(UploadSolid);

// node_modules/flowbite-svelte-icons/dist/UserAddOutline.svelte
mark_module_start();
UserAddOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserAddOutline.svelte";
var root_1544 = add_locations(ns_template(`<title> </title>`), UserAddOutline[FILENAME], [[41, 4]]);
var root_2544 = add_locations(ns_template(`<desc> </desc>`), UserAddOutline[FILENAME], [[44, 4]]);
var root544 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 12h4m-2 2v-4M4 18v-1a3 3 0 0 1 3-3h4a3 3 0 0 1 3 3v1a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1Zm8-10a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserAddOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UserAddOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserAddOutline);
  validate_prop_bindings($$props, [], [], UserAddOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "user add outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root544();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1544();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2544();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserAddOutline = hmr(UserAddOutline, () => UserAddOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserAddOutline[HMR].source;
    set(UserAddOutline[HMR].source, module.default[HMR].original);
  });
}
var UserAddOutline_default = UserAddOutline;
mark_module_end(UserAddOutline);

// node_modules/flowbite-svelte-icons/dist/UserAddSolid.svelte
mark_module_start();
UserAddSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserAddSolid.svelte";
var root_1545 = add_locations(ns_template(`<title> </title>`), UserAddSolid[FILENAME], [[39, 4]]);
var root_2545 = add_locations(ns_template(`<desc> </desc>`), UserAddSolid[FILENAME], [[42, 4]]);
var root545 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M9 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm-2 9a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-1a4 4 0 0 0-4-4H7Zm8-1a1 1 0 0 1 1-1h1v-1a1 1 0 1 1 2 0v1h1a1 1 0 1 1 0 2h-1v1a1 1 0 1 1-2 0v-1h-1a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), UserAddSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UserAddSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserAddSolid);
  validate_prop_bindings($$props, [], [], UserAddSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "user add solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root545();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1545();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2545();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserAddSolid = hmr(UserAddSolid, () => UserAddSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserAddSolid[HMR].source;
    set(UserAddSolid[HMR].source, module.default[HMR].original);
  });
}
var UserAddSolid_default = UserAddSolid;
mark_module_end(UserAddSolid);

// node_modules/flowbite-svelte-icons/dist/UserCircleOutline.svelte
mark_module_start();
UserCircleOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserCircleOutline.svelte";
var root_1546 = add_locations(ns_template(`<title> </title>`), UserCircleOutline[FILENAME], [[41, 4]]);
var root_2546 = add_locations(ns_template(`<desc> </desc>`), UserCircleOutline[FILENAME], [[44, 4]]);
var root546 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M12 21a9 9 0 1 0 0-18 9 9 0 0 0 0 18Zm0 0a8.949 8.949 0 0 0 4.951-1.488A3.987 3.987 0 0 0 13 16h-2a3.987 3.987 0 0 0-3.951 3.512A8.948 8.948 0 0 0 12 21Zm3-11a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserCircleOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UserCircleOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserCircleOutline);
  validate_prop_bindings($$props, [], [], UserCircleOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "user circle outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root546();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1546();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2546();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserCircleOutline = hmr(UserCircleOutline, () => UserCircleOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserCircleOutline[HMR].source;
    set(UserCircleOutline[HMR].source, module.default[HMR].original);
  });
}
var UserCircleOutline_default = UserCircleOutline;
mark_module_end(UserCircleOutline);

// node_modules/flowbite-svelte-icons/dist/UserCircleSolid.svelte
mark_module_start();
UserCircleSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserCircleSolid.svelte";
var root_1547 = add_locations(ns_template(`<title> </title>`), UserCircleSolid[FILENAME], [[39, 4]]);
var root_2547 = add_locations(ns_template(`<desc> </desc>`), UserCircleSolid[FILENAME], [[42, 4]]);
var root547 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 20a7.966 7.966 0 0 1-5.002-1.756l.002.001v-.683c0-1.794 1.492-3.25 3.333-3.25h3.334c1.84 0 3.333 1.456 3.333 3.25v.683A7.966 7.966 0 0 1 12 20ZM2 12C2 6.477 6.477 2 12 2s10 4.477 10 10c0 5.5-4.44 9.963-9.932 10h-.138C6.438 21.962 2 17.5 2 12Zm10-5c-1.84 0-3.333 1.455-3.333 3.25S10.159 13.5 12 13.5c1.84 0 3.333-1.455 3.333-3.25S13.841 7 12 7Z" clip-rule="evenodd"></path></svg>`), UserCircleSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UserCircleSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserCircleSolid);
  validate_prop_bindings($$props, [], [], UserCircleSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "user circle solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root547();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1547();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2547();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserCircleSolid = hmr(UserCircleSolid, () => UserCircleSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserCircleSolid[HMR].source;
    set(UserCircleSolid[HMR].source, module.default[HMR].original);
  });
}
var UserCircleSolid_default = UserCircleSolid;
mark_module_end(UserCircleSolid);

// node_modules/flowbite-svelte-icons/dist/UserEditOutline.svelte
mark_module_start();
UserEditOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserEditOutline.svelte";
var root_1548 = add_locations(ns_template(`<title> </title>`), UserEditOutline[FILENAME], [[41, 4]]);
var root_2548 = add_locations(ns_template(`<desc> </desc>`), UserEditOutline[FILENAME], [[44, 4]]);
var root548 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="square" stroke-linejoin="round" d="M7 19H5a1 1 0 0 1-1-1v-1a3 3 0 0 1 3-3h1m4-6a3 3 0 1 1-6 0 3 3 0 0 1 6 0Zm7.441 1.559a1.907 1.907 0 0 1 0 2.698l-6.069 6.069L10 19l.674-3.372 6.07-6.07a1.907 1.907 0 0 1 2.697 0Z"></path></svg>`), UserEditOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UserEditOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserEditOutline);
  validate_prop_bindings($$props, [], [], UserEditOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "user edit outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root548();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1548();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2548();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserEditOutline = hmr(UserEditOutline, () => UserEditOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserEditOutline[HMR].source;
    set(UserEditOutline[HMR].source, module.default[HMR].original);
  });
}
var UserEditOutline_default = UserEditOutline;
mark_module_end(UserEditOutline);

// node_modules/flowbite-svelte-icons/dist/UserEditSolid.svelte
mark_module_start();
UserEditSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserEditSolid.svelte";
var root_1549 = add_locations(ns_template(`<title> </title>`), UserEditSolid[FILENAME], [[39, 4]]);
var root_2549 = add_locations(ns_template(`<desc> </desc>`), UserEditSolid[FILENAME], [[42, 4]]);
var root549 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 8a4 4 0 1 1 7.796 1.263l-2.533 2.534A4 4 0 0 1 5 8Zm4.06 5H7a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h2.172a2.999 2.999 0 0 1-.114-1.588l.674-3.372a3 3 0 0 1 .82-1.533L9.06 13Zm9.032-5a2.907 2.907 0 0 0-2.056.852L9.967 14.92a1 1 0 0 0-.273.51l-.675 3.373a1 1 0 0 0 1.177 1.177l3.372-.675a1 1 0 0 0 .511-.273l6.07-6.07a2.91 2.91 0 0 0-.944-4.742A2.907 2.907 0 0 0 18.092 8Z" clip-rule="evenodd"></path></svg>`), UserEditSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UserEditSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserEditSolid);
  validate_prop_bindings($$props, [], [], UserEditSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "user edit solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root549();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1549();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2549();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserEditSolid = hmr(UserEditSolid, () => UserEditSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserEditSolid[HMR].source;
    set(UserEditSolid[HMR].source, module.default[HMR].original);
  });
}
var UserEditSolid_default = UserEditSolid;
mark_module_end(UserEditSolid);

// node_modules/flowbite-svelte-icons/dist/UserHeadsetOutline.svelte
mark_module_start();
UserHeadsetOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserHeadsetOutline.svelte";
var root_1550 = add_locations(ns_template(`<title> </title>`), UserHeadsetOutline[FILENAME], [[41, 4]]);
var root_2550 = add_locations(ns_template(`<desc> </desc>`), UserHeadsetOutline[FILENAME], [[44, 4]]);
var root550 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14.079 6.839a3 3 0 0 0-4.255.1M13 20h1.083A3.916 3.916 0 0 0 18 16.083V9A6 6 0 1 0 6 9v7m7 4v-1a1 1 0 0 0-1-1h-1a1 1 0 0 0-1 1v1a1 1 0 0 0 1 1h1a1 1 0 0 0 1-1Zm-7-4v-6H5a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h1Zm12-6h1a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-1v-6Z"></path></svg>`), UserHeadsetOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UserHeadsetOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserHeadsetOutline);
  validate_prop_bindings($$props, [], [], UserHeadsetOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "user headset outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root550();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1550();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2550();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserHeadsetOutline = hmr(UserHeadsetOutline, () => UserHeadsetOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserHeadsetOutline[HMR].source;
    set(UserHeadsetOutline[HMR].source, module.default[HMR].original);
  });
}
var UserHeadsetOutline_default = UserHeadsetOutline;
mark_module_end(UserHeadsetOutline);

// node_modules/flowbite-svelte-icons/dist/UserHeadsetSolid.svelte
mark_module_start();
UserHeadsetSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserHeadsetSolid.svelte";
var root_1551 = add_locations(ns_template(`<title> </title>`), UserHeadsetSolid[FILENAME], [[39, 4]]);
var root_2551 = add_locations(ns_template(`<desc> </desc>`), UserHeadsetSolid[FILENAME], [[42, 4]]);
var root551 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 2a7 7 0 0 0-7 7 3 3 0 0 0-3 3v2a3 3 0 0 0 3 3h1a1 1 0 0 0 1-1V9a5 5 0 1 1 10 0v7.083A2.919 2.919 0 0 1 14.083 19H14a2 2 0 0 0-2-2h-1a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h1a2 2 0 0 0 1.732-1h.351a4.917 4.917 0 0 0 4.83-4H19a3 3 0 0 0 3-3v-2a3 3 0 0 0-3-3 7 7 0 0 0-7-7Zm1.45 3.275a4 4 0 0 0-4.352.976 1 1 0 0 0 1.452 1.376 2.001 2.001 0 0 1 2.836-.067 1 1 0 1 0 1.386-1.442 4 4 0 0 0-1.321-.843Z" clip-rule="evenodd"></path></svg>`), UserHeadsetSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UserHeadsetSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserHeadsetSolid);
  validate_prop_bindings($$props, [], [], UserHeadsetSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "user headset solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root551();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1551();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2551();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserHeadsetSolid = hmr(UserHeadsetSolid, () => UserHeadsetSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserHeadsetSolid[HMR].source;
    set(UserHeadsetSolid[HMR].source, module.default[HMR].original);
  });
}
var UserHeadsetSolid_default = UserHeadsetSolid;
mark_module_end(UserHeadsetSolid);

// node_modules/flowbite-svelte-icons/dist/UserOutline.svelte
mark_module_start();
UserOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserOutline.svelte";
var root_1552 = add_locations(ns_template(`<title> </title>`), UserOutline[FILENAME], [[41, 4]]);
var root_2552 = add_locations(ns_template(`<desc> </desc>`), UserOutline[FILENAME], [[44, 4]]);
var root552 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" d="M7 17v1a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1a3 3 0 0 0-3-3h-4a3 3 0 0 0-3 3Zm8-9a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UserOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserOutline);
  validate_prop_bindings($$props, [], [], UserOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "user outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root552();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1552();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2552();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserOutline = hmr(UserOutline, () => UserOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserOutline[HMR].source;
    set(UserOutline[HMR].source, module.default[HMR].original);
  });
}
var UserOutline_default = UserOutline;
mark_module_end(UserOutline);

// node_modules/flowbite-svelte-icons/dist/UserRemoveOutline.svelte
mark_module_start();
UserRemoveOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserRemoveOutline.svelte";
var root_1553 = add_locations(ns_template(`<title> </title>`), UserRemoveOutline[FILENAME], [[41, 4]]);
var root_2553 = add_locations(ns_template(`<desc> </desc>`), UserRemoveOutline[FILENAME], [[44, 4]]);
var root553 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16 12h4M4 18v-1a3 3 0 0 1 3-3h4a3 3 0 0 1 3 3v1a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1Zm8-10a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserRemoveOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UserRemoveOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserRemoveOutline);
  validate_prop_bindings($$props, [], [], UserRemoveOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "user remove outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root553();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1553();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2553();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserRemoveOutline = hmr(UserRemoveOutline, () => UserRemoveOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserRemoveOutline[HMR].source;
    set(UserRemoveOutline[HMR].source, module.default[HMR].original);
  });
}
var UserRemoveOutline_default = UserRemoveOutline;
mark_module_end(UserRemoveOutline);

// node_modules/flowbite-svelte-icons/dist/UserRemoveSolid.svelte
mark_module_start();
UserRemoveSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserRemoveSolid.svelte";
var root_1554 = add_locations(ns_template(`<title> </title>`), UserRemoveSolid[FILENAME], [[39, 4]]);
var root_2554 = add_locations(ns_template(`<desc> </desc>`), UserRemoveSolid[FILENAME], [[42, 4]]);
var root554 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M5 8a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm-2 9a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1Zm13-6a1 1 0 1 0 0 2h4a1 1 0 1 0 0-2h-4Z" clip-rule="evenodd"></path></svg>`), UserRemoveSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UserRemoveSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserRemoveSolid);
  validate_prop_bindings($$props, [], [], UserRemoveSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "user remove solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root554();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1554();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2554();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserRemoveSolid = hmr(UserRemoveSolid, () => UserRemoveSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserRemoveSolid[HMR].source;
    set(UserRemoveSolid[HMR].source, module.default[HMR].original);
  });
}
var UserRemoveSolid_default = UserRemoveSolid;
mark_module_end(UserRemoveSolid);

// node_modules/flowbite-svelte-icons/dist/UserSettingsOutline.svelte
mark_module_start();
UserSettingsOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserSettingsOutline.svelte";
var root_1555 = add_locations(ns_template(`<title> </title>`), UserSettingsOutline[FILENAME], [[41, 4]]);
var root_2555 = add_locations(ns_template(`<desc> </desc>`), UserSettingsOutline[FILENAME], [[44, 4]]);
var root555 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="square" stroke-linejoin="round" d="M10 19H5a1 1 0 0 1-1-1v-1a3 3 0 0 1 3-3h2m10 1a3 3 0 0 1-3 3m3-3a3 3 0 0 0-3-3m3 3h1m-4 3a3 3 0 0 1-3-3m3 3v1m-3-4a3 3 0 0 1 3-3m-3 3h-1m4-3v-1m-2.121 1.879-.707-.707m5.656 5.656-.707-.707m-4.242 0-.707.707m5.656-5.656-.707.707M12 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UserSettingsOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UserSettingsOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserSettingsOutline);
  validate_prop_bindings($$props, [], [], UserSettingsOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "user settings outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root555();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1555();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2555();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserSettingsOutline = hmr(UserSettingsOutline, () => UserSettingsOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserSettingsOutline[HMR].source;
    set(UserSettingsOutline[HMR].source, module.default[HMR].original);
  });
}
var UserSettingsOutline_default = UserSettingsOutline;
mark_module_end(UserSettingsOutline);

// node_modules/flowbite-svelte-icons/dist/UserSettingsSolid.svelte
mark_module_start();
UserSettingsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserSettingsSolid.svelte";
var root_1556 = add_locations(ns_template(`<title> </title>`), UserSettingsSolid[FILENAME], [[39, 4]]);
var root_2556 = add_locations(ns_template(`<desc> </desc>`), UserSettingsSolid[FILENAME], [[42, 4]]);
var root556 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M17 10v1.126c.367.095.714.24 1.032.428l.796-.797 1.415 1.415-.797.796c.188.318.333.665.428 1.032H21v2h-1.126c-.095.367-.24.714-.428 1.032l.797.796-1.415 1.415-.796-.797a3.979 3.979 0 0 1-1.032.428V20h-2v-1.126a3.977 3.977 0 0 1-1.032-.428l-.796.797-1.415-1.415.797-.796A3.975 3.975 0 0 1 12.126 16H11v-2h1.126c.095-.367.24-.714.428-1.032l-.797-.796 1.415-1.415.796.797A3.977 3.977 0 0 1 15 11.126V10h2Zm.406 3.578.016.016c.354.358.574.85.578 1.392v.028a2 2 0 0 1-3.409 1.406l-.01-.012a2 2 0 0 1 2.826-2.83ZM5 8a4 4 0 1 1 7.938.703 7.029 7.029 0 0 0-3.235 3.235A4 4 0 0 1 5 8Zm4.29 5H7a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h6.101A6.979 6.979 0 0 1 9 15c0-.695.101-1.366.29-2Z" clip-rule="evenodd"></path></svg>`), UserSettingsSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UserSettingsSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserSettingsSolid);
  validate_prop_bindings($$props, [], [], UserSettingsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "user settings solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root556();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1556();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2556();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserSettingsSolid = hmr(UserSettingsSolid, () => UserSettingsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserSettingsSolid[HMR].source;
    set(UserSettingsSolid[HMR].source, module.default[HMR].original);
  });
}
var UserSettingsSolid_default = UserSettingsSolid;
mark_module_end(UserSettingsSolid);

// node_modules/flowbite-svelte-icons/dist/UserSolid.svelte
mark_module_start();
UserSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UserSolid.svelte";
var root_1557 = add_locations(ns_template(`<title> </title>`), UserSolid[FILENAME], [[39, 4]]);
var root_2557 = add_locations(ns_template(`<desc> </desc>`), UserSolid[FILENAME], [[42, 4]]);
var root557 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm-2 9a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-1a4 4 0 0 0-4-4h-4Z" clip-rule="evenodd"></path></svg>`), UserSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UserSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UserSolid);
  validate_prop_bindings($$props, [], [], UserSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "user solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root557();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1557();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2557();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UserSolid = hmr(UserSolid, () => UserSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UserSolid[HMR].source;
    set(UserSolid[HMR].source, module.default[HMR].original);
  });
}
var UserSolid_default = UserSolid;
mark_module_end(UserSolid);

// node_modules/flowbite-svelte-icons/dist/UsersGroupOutline.svelte
mark_module_start();
UsersGroupOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UsersGroupOutline.svelte";
var root_1558 = add_locations(ns_template(`<title> </title>`), UsersGroupOutline[FILENAME], [[41, 4]]);
var root_2558 = add_locations(ns_template(`<desc> </desc>`), UsersGroupOutline[FILENAME], [[44, 4]]);
var root558 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M4.5 17H4a1 1 0 0 1-1-1 3 3 0 0 1 3-3h1m0-3.05A2.5 2.5 0 1 1 9 5.5M19.5 17h.5a1 1 0 0 0 1-1 3 3 0 0 0-3-3h-1m0-3.05a2.5 2.5 0 1 0-2-4.45m.5 13.5h-7a1 1 0 0 1-1-1 3 3 0 0 1 3-3h3a3 3 0 0 1 3 3 1 1 0 0 1-1 1Zm-1-9.5a2.5 2.5 0 1 1-5 0 2.5 2.5 0 0 1 5 0Z"></path></svg>`), UsersGroupOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UsersGroupOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UsersGroupOutline);
  validate_prop_bindings($$props, [], [], UsersGroupOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "users group outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root558();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1558();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2558();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UsersGroupOutline = hmr(UsersGroupOutline, () => UsersGroupOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsersGroupOutline[HMR].source;
    set(UsersGroupOutline[HMR].source, module.default[HMR].original);
  });
}
var UsersGroupOutline_default = UsersGroupOutline;
mark_module_end(UsersGroupOutline);

// node_modules/flowbite-svelte-icons/dist/UsersGroupSolid.svelte
mark_module_start();
UsersGroupSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UsersGroupSolid.svelte";
var root_1559 = add_locations(ns_template(`<title> </title>`), UsersGroupSolid[FILENAME], [[39, 4]]);
var root_2559 = add_locations(ns_template(`<desc> </desc>`), UsersGroupSolid[FILENAME], [[42, 4]]);
var root559 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 6a3.5 3.5 0 1 0 0 7 3.5 3.5 0 0 0 0-7Zm-1.5 8a4 4 0 0 0-4 4 2 2 0 0 0 2 2h7a2 2 0 0 0 2-2 4 4 0 0 0-4-4h-3Zm6.82-3.096a5.51 5.51 0 0 0-2.797-6.293 3.5 3.5 0 1 1 2.796 6.292ZM19.5 18h.5a2 2 0 0 0 2-2 4 4 0 0 0-4-4h-1.1a5.503 5.503 0 0 1-.471.762A5.998 5.998 0 0 1 19.5 18ZM4 7.5a3.5 3.5 0 0 1 5.477-2.889 5.5 5.5 0 0 0-2.796 6.293A3.501 3.501 0 0 1 4 7.5ZM7.1 12H6a4 4 0 0 0-4 4 2 2 0 0 0 2 2h.5a5.998 5.998 0 0 1 3.071-5.238A5.505 5.505 0 0 1 7.1 12Z" clip-rule="evenodd"></path></svg>`), UsersGroupSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UsersGroupSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UsersGroupSolid);
  validate_prop_bindings($$props, [], [], UsersGroupSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "users group solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root559();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1559();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2559();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UsersGroupSolid = hmr(UsersGroupSolid, () => UsersGroupSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsersGroupSolid[HMR].source;
    set(UsersGroupSolid[HMR].source, module.default[HMR].original);
  });
}
var UsersGroupSolid_default = UsersGroupSolid;
mark_module_end(UsersGroupSolid);

// node_modules/flowbite-svelte-icons/dist/UsersOutline.svelte
mark_module_start();
UsersOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UsersOutline.svelte";
var root_1560 = add_locations(ns_template(`<title> </title>`), UsersOutline[FILENAME], [[41, 4]]);
var root_2560 = add_locations(ns_template(`<desc> </desc>`), UsersOutline[FILENAME], [[44, 4]]);
var root560 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="M16 19h4a1 1 0 0 0 1-1v-1a3 3 0 0 0-3-3h-2m-2.236-4a3 3 0 1 0 0-4M3 18v-1a3 3 0 0 1 3-3h4a3 3 0 0 1 3 3v1a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1Zm8-10a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"></path></svg>`), UsersOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function UsersOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UsersOutline);
  validate_prop_bindings($$props, [], [], UsersOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "users outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root560();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1560();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2560();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UsersOutline = hmr(UsersOutline, () => UsersOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsersOutline[HMR].source;
    set(UsersOutline[HMR].source, module.default[HMR].original);
  });
}
var UsersOutline_default = UsersOutline;
mark_module_end(UsersOutline);

// node_modules/flowbite-svelte-icons/dist/UsersSolid.svelte
mark_module_start();
UsersSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/UsersSolid.svelte";
var root_1561 = add_locations(ns_template(`<title> </title>`), UsersSolid[FILENAME], [[39, 4]]);
var root_2561 = add_locations(ns_template(`<desc> </desc>`), UsersSolid[FILENAME], [[42, 4]]);
var root561 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm-2 9a4 4 0 0 0-4 4v1a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-1a4 4 0 0 0-4-4H6Zm7.25-2.095c.478-.86.75-1.85.75-2.905a5.973 5.973 0 0 0-.75-2.906 4 4 0 1 1 0 5.811ZM15.466 20c.34-.588.535-1.271.535-2v-1a5.978 5.978 0 0 0-1.528-4H18a4 4 0 0 1 4 4v1a2 2 0 0 1-2 2h-4.535Z" clip-rule="evenodd"></path></svg>`), UsersSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function UsersSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, UsersSolid);
  validate_prop_bindings($$props, [], [], UsersSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "users solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root561();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1561();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2561();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  UsersSolid = hmr(UsersSolid, () => UsersSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = UsersSolid[HMR].source;
    set(UsersSolid[HMR].source, module.default[HMR].original);
  });
}
var UsersSolid_default = UsersSolid;
mark_module_end(UsersSolid);

// node_modules/flowbite-svelte-icons/dist/VideoCameraOutline.svelte
mark_module_start();
VideoCameraOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VideoCameraOutline.svelte";
var root_1562 = add_locations(ns_template(`<title> </title>`), VideoCameraOutline[FILENAME], [[41, 4]]);
var root_2562 = add_locations(ns_template(`<desc> </desc>`), VideoCameraOutline[FILENAME], [[44, 4]]);
var root562 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M14 6H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1Zm7 11-6-2V9l6-2v10Z"></path></svg>`), VideoCameraOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function VideoCameraOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VideoCameraOutline);
  validate_prop_bindings($$props, [], [], VideoCameraOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "video camera outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root562();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1562();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2562();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VideoCameraOutline = hmr(VideoCameraOutline, () => VideoCameraOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VideoCameraOutline[HMR].source;
    set(VideoCameraOutline[HMR].source, module.default[HMR].original);
  });
}
var VideoCameraOutline_default = VideoCameraOutline;
mark_module_end(VideoCameraOutline);

// node_modules/flowbite-svelte-icons/dist/VideoCameraSolid.svelte
mark_module_start();
VideoCameraSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VideoCameraSolid.svelte";
var root_1563 = add_locations(ns_template(`<title> </title>`), VideoCameraSolid[FILENAME], [[39, 4]]);
var root_2563 = add_locations(ns_template(`<desc> </desc>`), VideoCameraSolid[FILENAME], [[42, 4]]);
var root563 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M14 7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7Zm2 9.387 4.684 1.562A1 1 0 0 0 22 17V7a1 1 0 0 0-1.316-.949L16 7.613v8.774Z" clip-rule="evenodd"></path></svg>`), VideoCameraSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function VideoCameraSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VideoCameraSolid);
  validate_prop_bindings($$props, [], [], VideoCameraSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "video camera solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root563();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1563();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2563();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VideoCameraSolid = hmr(VideoCameraSolid, () => VideoCameraSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VideoCameraSolid[HMR].source;
    set(VideoCameraSolid[HMR].source, module.default[HMR].original);
  });
}
var VideoCameraSolid_default = VideoCameraSolid;
mark_module_end(VideoCameraSolid);

// node_modules/flowbite-svelte-icons/dist/VisaSolid.svelte
mark_module_start();
VisaSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VisaSolid.svelte";
var root_1564 = add_locations(ns_template(`<title> </title>`), VisaSolid[FILENAME], [[39, 4]]);
var root_2564 = add_locations(ns_template(`<desc> </desc>`), VisaSolid[FILENAME], [[42, 4]]);
var root564 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4Z"></path><path fill="#ffffff" d="M15.643 9.382a3.314 3.314 0 0 0-1.158-.2c-1.276 0-2.177.643-2.184 1.566-.008.678.64 1.06 1.131 1.286.504.233.672.38.67.588-.003.317-.402.46-.772.46-.51 0-.789-.07-1.217-.248l-.159-.075-.18 1.063c.31.13.869.24 1.446.25 1.357 0 2.244-.64 2.255-1.621.01-.542-.34-.951-1.079-1.29-.449-.219-.727-.365-.727-.588 0-.197.238-.408.737-.408.332-.008.661.055.967.183l.12.053.181-1.026-.031.007Zm3.312-.114h-.997c-.31 0-.544.085-.68.393l-1.917 4.345h1.356l.272-.713 1.656.002c.039.166.158.71.158.71H20l-1.045-4.737Zm-8.49-.04h1.294l-.809 4.74H9.659l.807-4.742v.002Zm-3.282 2.613.134.658 1.264-3.231h1.37l-2.035 4.731H6.549L5.432 9.993a.27.27 0 0 0-.119-.159 5.543 5.543 0 0 0-1.27-.47l.018-.1h2.081c.283.012.51.1.586.402l.454 2.177.001-.002Zm10.177.483.515-1.326c-.006.014.106-.273.171-.451l.089.409.3 1.367h-1.076Z"></path></svg>`), VisaSolid[FILENAME], [
  [29, 0, [[44, 2], [48, 2]]]
]);
function VisaSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VisaSolid);
  validate_prop_bindings($$props, [], [], VisaSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "visa solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root564();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1564();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2564();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VisaSolid = hmr(VisaSolid, () => VisaSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VisaSolid[HMR].source;
    set(VisaSolid[HMR].source, module.default[HMR].original);
  });
}
var VisaSolid_default = VisaSolid;
mark_module_end(VisaSolid);

// node_modules/flowbite-svelte-icons/dist/VolumeDownOutline.svelte
mark_module_start();
VolumeDownOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeDownOutline.svelte";
var root_1565 = add_locations(ns_template(`<title> </title>`), VolumeDownOutline[FILENAME], [[41, 4]]);
var root_2565 = add_locations(ns_template(`<desc> </desc>`), VolumeDownOutline[FILENAME], [[44, 4]]);
var root565 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17.5 8.43A4.985 4.985 0 0 1 19 12a4.984 4.984 0 0 1-1.43 3.5M14 6.135v11.73a1 1 0 0 1-1.64.768L8 15H6a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l4.36-3.633a1 1 0 0 1 1.64.768Z"></path></svg>`), VolumeDownOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function VolumeDownOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VolumeDownOutline);
  validate_prop_bindings($$props, [], [], VolumeDownOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "volume down outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root565();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1565();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2565();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VolumeDownOutline = hmr(VolumeDownOutline, () => VolumeDownOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeDownOutline[HMR].source;
    set(VolumeDownOutline[HMR].source, module.default[HMR].original);
  });
}
var VolumeDownOutline_default = VolumeDownOutline;
mark_module_end(VolumeDownOutline);

// node_modules/flowbite-svelte-icons/dist/VolumeDownSolid.svelte
mark_module_start();
VolumeDownSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeDownSolid.svelte";
var root_1566 = add_locations(ns_template(`<title> </title>`), VolumeDownSolid[FILENAME], [[39, 4]]);
var root_2566 = add_locations(ns_template(`<desc> </desc>`), VolumeDownSolid[FILENAME], [[42, 4]]);
var root566 = add_locations(ns_template(`<svg><!><!><path d="M15 6.037c0-1.724-1.978-2.665-3.28-1.562L7.638 7.933H6c-1.105 0-2 .91-2 2.034v4.066c0 1.123.895 2.034 2 2.034h1.638l4.082 3.458c1.302 1.104 3.28.162 3.28-1.562V6.037Z"></path><path fill-rule="evenodd" d="M16.786 7.658a.988.988 0 0 1 1.414-.014A6.135 6.135 0 0 1 20 12c0 1.662-.655 3.17-1.715 4.27a.989.989 0 0 1-1.414.014 1.029 1.029 0 0 1-.014-1.437A4.085 4.085 0 0 0 18 12a4.085 4.085 0 0 0-1.2-2.904 1.029 1.029 0 0 1-.014-1.438Z" clip-rule="evenodd"></path></svg>`), VolumeDownSolid[FILENAME], [
  [29, 0, [[44, 2], [47, 2]]]
]);
function VolumeDownSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VolumeDownSolid);
  validate_prop_bindings($$props, [], [], VolumeDownSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "volume down solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root566();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1566();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2566();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VolumeDownSolid = hmr(VolumeDownSolid, () => VolumeDownSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeDownSolid[HMR].source;
    set(VolumeDownSolid[HMR].source, module.default[HMR].original);
  });
}
var VolumeDownSolid_default = VolumeDownSolid;
mark_module_end(VolumeDownSolid);

// node_modules/flowbite-svelte-icons/dist/VolumeMuteOutline.svelte
mark_module_start();
VolumeMuteOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeMuteOutline.svelte";
var root_1567 = add_locations(ns_template(`<title> </title>`), VolumeMuteOutline[FILENAME], [[41, 4]]);
var root_2567 = add_locations(ns_template(`<desc> </desc>`), VolumeMuteOutline[FILENAME], [[44, 4]]);
var root567 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.5 8.43A4.985 4.985 0 0 1 17 12c0 1.126-.5 2.5-1.5 3.5m2.864-9.864A8.972 8.972 0 0 1 21 12c0 2.023-.5 4.5-2.5 6M7.8 7.5l2.56-2.133a1 1 0 0 1 1.64.768V12m0 4.5v1.365a1 1 0 0 1-1.64.768L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1m1-4 14 14"></path></svg>`), VolumeMuteOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function VolumeMuteOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VolumeMuteOutline);
  validate_prop_bindings($$props, [], [], VolumeMuteOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "volume mute outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root567();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1567();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2567();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VolumeMuteOutline = hmr(VolumeMuteOutline, () => VolumeMuteOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeMuteOutline[HMR].source;
    set(VolumeMuteOutline[HMR].source, module.default[HMR].original);
  });
}
var VolumeMuteOutline_default = VolumeMuteOutline;
mark_module_end(VolumeMuteOutline);

// node_modules/flowbite-svelte-icons/dist/VolumeMuteSolid.svelte
mark_module_start();
VolumeMuteSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeMuteSolid.svelte";
var root_1568 = add_locations(ns_template(`<title> </title>`), VolumeMuteSolid[FILENAME], [[39, 4]]);
var root_2568 = add_locations(ns_template(`<desc> </desc>`), VolumeMuteSolid[FILENAME], [[42, 4]]);
var root568 = add_locations(ns_template(`<svg><!><!><path d="M5.707 4.293a1 1 0 0 0-1.414 1.414l14 14a1 1 0 0 0 1.414-1.414l-.004-.005C21.57 16.498 22 13.938 22 12a9.972 9.972 0 0 0-2.929-7.071 1 1 0 1 0-1.414 1.414A7.972 7.972 0 0 1 20 12c0 1.752-.403 3.636-1.712 4.873l-1.433-1.433C17.616 14.37 18 13.107 18 12c0-1.678-.69-3.197-1.8-4.285a1 1 0 1 0-1.4 1.428A3.985 3.985 0 0 1 16 12c0 .606-.195 1.335-.59 1.996L13 11.586V6.135c0-1.696-1.978-2.622-3.28-1.536L7.698 6.284l-1.99-1.991ZM4 8h.586L13 16.414v1.451c0 1.696-1.978 2.622-3.28 1.536L5.638 16H4a2 2 0 0 1-2-2v-4a2 2 0 0 1 2-2Z"></path></svg>`), VolumeMuteSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function VolumeMuteSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VolumeMuteSolid);
  validate_prop_bindings($$props, [], [], VolumeMuteSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "volume mute solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root568();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1568();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2568();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VolumeMuteSolid = hmr(VolumeMuteSolid, () => VolumeMuteSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeMuteSolid[HMR].source;
    set(VolumeMuteSolid[HMR].source, module.default[HMR].original);
  });
}
var VolumeMuteSolid_default = VolumeMuteSolid;
mark_module_end(VolumeMuteSolid);

// node_modules/flowbite-svelte-icons/dist/VolumeUpOutline.svelte
mark_module_start();
VolumeUpOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeUpOutline.svelte";
var root_1569 = add_locations(ns_template(`<title> </title>`), VolumeUpOutline[FILENAME], [[41, 4]]);
var root_2569 = add_locations(ns_template(`<desc> </desc>`), VolumeUpOutline[FILENAME], [[44, 4]]);
var root569 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M15.5 8.43A4.985 4.985 0 0 1 17 12a4.984 4.984 0 0 1-1.43 3.5m2.794 2.864A8.972 8.972 0 0 0 21 12a8.972 8.972 0 0 0-2.636-6.364M12 6.135v11.73a1 1 0 0 1-1.64.768L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l4.36-3.633a1 1 0 0 1 1.64.768Z"></path></svg>`), VolumeUpOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function VolumeUpOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VolumeUpOutline);
  validate_prop_bindings($$props, [], [], VolumeUpOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "volume up outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root569();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1569();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2569();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VolumeUpOutline = hmr(VolumeUpOutline, () => VolumeUpOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeUpOutline[HMR].source;
    set(VolumeUpOutline[HMR].source, module.default[HMR].original);
  });
}
var VolumeUpOutline_default = VolumeUpOutline;
mark_module_end(VolumeUpOutline);

// node_modules/flowbite-svelte-icons/dist/VolumeUpSolid.svelte
mark_module_start();
VolumeUpSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VolumeUpSolid.svelte";
var root_1570 = add_locations(ns_template(`<title> </title>`), VolumeUpSolid[FILENAME], [[39, 4]]);
var root_2570 = add_locations(ns_template(`<desc> </desc>`), VolumeUpSolid[FILENAME], [[42, 4]]);
var root570 = add_locations(ns_template(`<svg><!><!><path d="M13 6.037c0-1.724-1.978-2.665-3.28-1.562L5.638 7.933H4c-1.105 0-2 .91-2 2.034v4.066c0 1.123.895 2.034 2 2.034h1.638l4.082 3.458c1.302 1.104 3.28.162 3.28-1.562V6.037Z"></path><path fill-rule="evenodd" d="M14.786 7.658a.988.988 0 0 1 1.414-.014A6.135 6.135 0 0 1 18 12c0 1.662-.655 3.17-1.715 4.27a.989.989 0 0 1-1.414.014 1.029 1.029 0 0 1-.014-1.437A4.085 4.085 0 0 0 16 12a4.085 4.085 0 0 0-1.2-2.904 1.029 1.029 0 0 1-.014-1.438Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M17.657 4.811a.988.988 0 0 1 1.414 0A10.224 10.224 0 0 1 22 12c0 2.807-1.12 5.35-2.929 7.189a.988.988 0 0 1-1.414 0 1.029 1.029 0 0 1 0-1.438A8.173 8.173 0 0 0 20 12a8.173 8.173 0 0 0-2.343-5.751 1.029 1.029 0 0 1 0-1.438Z" clip-rule="evenodd"></path></svg>`), VolumeUpSolid[FILENAME], [
  [
    29,
    0,
    [[44, 2], [47, 2], [52, 2]]
  ]
]);
function VolumeUpSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VolumeUpSolid);
  validate_prop_bindings($$props, [], [], VolumeUpSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "volume up solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root570();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1570();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2570();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(3);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VolumeUpSolid = hmr(VolumeUpSolid, () => VolumeUpSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VolumeUpSolid[HMR].source;
    set(VolumeUpSolid[HMR].source, module.default[HMR].original);
  });
}
var VolumeUpSolid_default = VolumeUpSolid;
mark_module_end(VolumeUpSolid);

// node_modules/flowbite-svelte-icons/dist/VueSolid.svelte
mark_module_start();
VueSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/VueSolid.svelte";
var root_1571 = add_locations(ns_template(`<title> </title>`), VueSolid[FILENAME], [[39, 4]]);
var root_2571 = add_locations(ns_template(`<desc> </desc>`), VueSolid[FILENAME], [[42, 4]]);
var root571 = add_locations(ns_template(`<svg><!><!><path d="M14.5 3 12 7.156 9.857 3H2l10 18L22 3h-7.5ZM4.486 4.5h2.4L12 13.8l5.107-9.3h2.4L12 18.021 4.486 4.5Z"></path></svg>`), VueSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function VueSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, VueSolid);
  validate_prop_bindings($$props, [], [], VueSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "vue solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root571();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1571();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2571();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  VueSolid = hmr(VueSolid, () => VueSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = VueSolid[HMR].source;
    set(VueSolid[HMR].source, module.default[HMR].original);
  });
}
var VueSolid_default = VueSolid;
mark_module_end(VueSolid);

// node_modules/flowbite-svelte-icons/dist/WalletOutline.svelte
mark_module_start();
WalletOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WalletOutline.svelte";
var root_1572 = add_locations(ns_template(`<title> </title>`), WalletOutline[FILENAME], [[41, 4]]);
var root_2572 = add_locations(ns_template(`<desc> </desc>`), WalletOutline[FILENAME], [[44, 4]]);
var root572 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M17 8H5m12 0a1 1 0 0 1 1 1v2.6M17 8l-4-4M5 8a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.6M5 8l4-4 4 4m6 4h-4a2 2 0 1 0 0 4h4a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1Z"></path></svg>`), WalletOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function WalletOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, WalletOutline);
  validate_prop_bindings($$props, [], [], WalletOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "wallet outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root572();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1572();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2572();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WalletOutline = hmr(WalletOutline, () => WalletOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WalletOutline[HMR].source;
    set(WalletOutline[HMR].source, module.default[HMR].original);
  });
}
var WalletOutline_default = WalletOutline;
mark_module_end(WalletOutline);

// node_modules/flowbite-svelte-icons/dist/WalletSolid.svelte
mark_module_start();
WalletSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WalletSolid.svelte";
var root_1573 = add_locations(ns_template(`<title> </title>`), WalletSolid[FILENAME], [[39, 4]]);
var root_2573 = add_locations(ns_template(`<desc> </desc>`), WalletSolid[FILENAME], [[42, 4]]);
var root573 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M12 14a3 3 0 0 1 3-3h4a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-4a3 3 0 0 1-3-3Zm3-1a1 1 0 1 0 0 2h4v-2h-4Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M12.293 3.293a1 1 0 0 1 1.414 0L16.414 6h-2.828l-1.293-1.293a1 1 0 0 1 0-1.414ZM12.414 6 9.707 3.293a1 1 0 0 0-1.414 0L5.586 6h6.828ZM4.586 7l-.056.055A2 2 0 0 0 3 9v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2h-4a5 5 0 0 1 0-10h4a2 2 0 0 0-1.53-1.945L17.414 7H4.586Z" clip-rule="evenodd"></path></svg>`), WalletSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function WalletSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, WalletSolid);
  validate_prop_bindings($$props, [], [], WalletSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "wallet solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root573();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1573();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2573();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WalletSolid = hmr(WalletSolid, () => WalletSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WalletSolid[HMR].source;
    set(WalletSolid[HMR].source, module.default[HMR].original);
  });
}
var WalletSolid_default = WalletSolid;
mark_module_end(WalletSolid);

// node_modules/flowbite-svelte-icons/dist/WandMagicSparklesOutline.svelte
mark_module_start();
WandMagicSparklesOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WandMagicSparklesOutline.svelte";
var root_1574 = add_locations(ns_template(`<title> </title>`), WandMagicSparklesOutline[FILENAME], [[41, 4]]);
var root_2574 = add_locations(ns_template(`<desc> </desc>`), WandMagicSparklesOutline[FILENAME], [[44, 4]]);
var root574 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M16.872 9.687 20 6.56 17.44 4 4 17.44 6.56 20 16.873 9.687Zm0 0-2.56-2.56M6 7v2m0 0v2m0-2H4m2 0h2m7 7v2m0 0v2m0-2h-2m2 0h2M8 4h.01v.01H8V4Zm2 2h.01v.01H10V6Zm2-2h.01v.01H12V4Zm8 8h.01v.01H20V12Zm-2 2h.01v.01H18V14Zm2 2h.01v.01H20V16Z"></path></svg>`), WandMagicSparklesOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function WandMagicSparklesOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, WandMagicSparklesOutline);
  validate_prop_bindings($$props, [], [], WandMagicSparklesOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "wand magic sparkles outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root574();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1574();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2574();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WandMagicSparklesOutline = hmr(WandMagicSparklesOutline, () => WandMagicSparklesOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WandMagicSparklesOutline[HMR].source;
    set(WandMagicSparklesOutline[HMR].source, module.default[HMR].original);
  });
}
var WandMagicSparklesOutline_default = WandMagicSparklesOutline;
mark_module_end(WandMagicSparklesOutline);

// node_modules/flowbite-svelte-icons/dist/WandMagicSparklesSolid.svelte
mark_module_start();
WandMagicSparklesSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WandMagicSparklesSolid.svelte";
var root_1575 = add_locations(ns_template(`<title> </title>`), WandMagicSparklesSolid[FILENAME], [[39, 4]]);
var root_2575 = add_locations(ns_template(`<desc> </desc>`), WandMagicSparklesSolid[FILENAME], [[42, 4]]);
var root575 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M17.44 3a1 1 0 0 1 .707.293l2.56 2.56a1 1 0 0 1 0 1.414L18.194 9.78 14.22 5.806l2.513-2.513A1 1 0 0 1 17.44 3Zm-4.634 4.22-9.513 9.513a1 1 0 0 0 0 1.414l2.56 2.56a1 1 0 0 0 1.414 0l9.513-9.513-3.974-3.974ZM6 6a1 1 0 0 1 1 1v1h1a1 1 0 0 1 0 2H7v1a1 1 0 1 1-2 0v-1H4a1 1 0 0 1 0-2h1V7a1 1 0 0 1 1-1Zm9 9a1 1 0 0 1 1 1v1h1a1 1 0 1 1 0 2h-1v1a1 1 0 1 1-2 0v-1h-1a1 1 0 1 1 0-2h1v-1a1 1 0 0 1 1-1Z" clip-rule="evenodd"></path><path d="M19 13h-2v2h2v-2ZM13 3h-2v2h2V3Zm-2 2H9v2h2V5ZM9 3H7v2h2V3Zm12 8h-2v2h2v-2Zm0 4h-2v2h2v-2Z"></path></svg>`), WandMagicSparklesSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function WandMagicSparklesSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, WandMagicSparklesSolid);
  validate_prop_bindings($$props, [], [], WandMagicSparklesSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "wand magic sparkles solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root575();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1575();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2575();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WandMagicSparklesSolid = hmr(WandMagicSparklesSolid, () => WandMagicSparklesSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WandMagicSparklesSolid[HMR].source;
    set(WandMagicSparklesSolid[HMR].source, module.default[HMR].original);
  });
}
var WandMagicSparklesSolid_default = WandMagicSparklesSolid;
mark_module_end(WandMagicSparklesSolid);

// node_modules/flowbite-svelte-icons/dist/WhatsappSolid.svelte
mark_module_start();
WhatsappSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WhatsappSolid.svelte";
var root_1576 = add_locations(ns_template(`<title> </title>`), WhatsappSolid[FILENAME], [[39, 4]]);
var root_2576 = add_locations(ns_template(`<desc> </desc>`), WhatsappSolid[FILENAME], [[42, 4]]);
var root576 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" fill-rule="evenodd" d="M12 4a8 8 0 0 0-6.895 12.06l.569.718-.697 2.359 2.32-.648.379.243A8 8 0 1 0 12 4ZM2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10a9.96 9.96 0 0 1-5.016-1.347l-4.948 1.382 1.426-4.829-.006-.007-.033-.055A9.958 9.958 0 0 1 2 12Z" clip-rule="evenodd"></path><path fill="currentColor" d="M16.735 13.492c-.038-.018-1.497-.736-1.756-.83a1.008 1.008 0 0 0-.34-.075c-.196 0-.362.098-.49.291-.146.217-.587.732-.723.886-.018.02-.042.045-.057.045-.013 0-.239-.093-.307-.123-1.564-.68-2.751-2.313-2.914-2.589-.023-.04-.024-.057-.024-.057.005-.021.058-.074.085-.101.08-.079.166-.182.249-.283l.117-.14c.121-.14.175-.25.237-.375l.033-.066a.68.68 0 0 0-.02-.64c-.034-.069-.65-1.555-.715-1.711-.158-.377-.366-.552-.655-.552-.027 0 0 0-.112.005-.137.005-.883.104-1.213.311-.35.22-.94.924-.94 2.16 0 1.112.705 2.162 1.008 2.561l.041.06c1.161 1.695 2.608 2.951 4.074 3.537 1.412.564 2.081.63 2.461.63.16 0 .288-.013.4-.024l.072-.007c.488-.043 1.56-.599 1.804-1.276.192-.534.243-1.117.115-1.329-.088-.144-.239-.216-.43-.308Z"></path></svg>`), WhatsappSolid[FILENAME], [
  [29, 0, [[44, 2], [50, 2]]]
]);
function WhatsappSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, WhatsappSolid);
  validate_prop_bindings($$props, [], [], WhatsappSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "whatsapp solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root576();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1576();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2576();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WhatsappSolid = hmr(WhatsappSolid, () => WhatsappSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WhatsappSolid[HMR].source;
    set(WhatsappSolid[HMR].source, module.default[HMR].original);
  });
}
var WhatsappSolid_default = WhatsappSolid;
mark_module_end(WhatsappSolid);

// node_modules/flowbite-svelte-icons/dist/WindowOutline.svelte
mark_module_start();
WindowOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WindowOutline.svelte";
var root_1577 = add_locations(ns_template(`<title> </title>`), WindowOutline[FILENAME], [[41, 4]]);
var root_2577 = add_locations(ns_template(`<desc> </desc>`), WindowOutline[FILENAME], [[44, 4]]);
var root577 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M6 8h.01M9 8h.01M12 8h.01M4 11h16M4 19h16a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1Z"></path></svg>`), WindowOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function WindowOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, WindowOutline);
  validate_prop_bindings($$props, [], [], WindowOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "window outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root577();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1577();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2577();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WindowOutline = hmr(WindowOutline, () => WindowOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WindowOutline[HMR].source;
    set(WindowOutline[HMR].source, module.default[HMR].original);
  });
}
var WindowOutline_default = WindowOutline;
mark_module_end(WindowOutline);

// node_modules/flowbite-svelte-icons/dist/WindowRestoreSolid.svelte
mark_module_start();
WindowRestoreSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WindowRestoreSolid.svelte";
var root_1578 = add_locations(ns_template(`<title> </title>`), WindowRestoreSolid[FILENAME], [[39, 4]]);
var root_2578 = add_locations(ns_template(`<desc> </desc>`), WindowRestoreSolid[FILENAME], [[42, 4]]);
var root578 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M8 5a1 1 0 0 1 1-1h11a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-1a1 1 0 1 1 0-2h1V6H9a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path><path fill-rule="evenodd" d="M4 7a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2H4Zm0 11v-5.5h11V18H4Z" clip-rule="evenodd"></path></svg>`), WindowRestoreSolid[FILENAME], [
  [29, 0, [[44, 2], [49, 2]]]
]);
function WindowRestoreSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, WindowRestoreSolid);
  validate_prop_bindings($$props, [], [], WindowRestoreSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "window restore solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root578();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1578();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2578();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next(2);
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WindowRestoreSolid = hmr(WindowRestoreSolid, () => WindowRestoreSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WindowRestoreSolid[HMR].source;
    set(WindowRestoreSolid[HMR].source, module.default[HMR].original);
  });
}
var WindowRestoreSolid_default = WindowRestoreSolid;
mark_module_end(WindowRestoreSolid);

// node_modules/flowbite-svelte-icons/dist/WindowSolid.svelte
mark_module_start();
WindowSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WindowSolid.svelte";
var root_1579 = add_locations(ns_template(`<title> </title>`), WindowSolid[FILENAME], [[39, 4]]);
var root_2579 = add_locations(ns_template(`<desc> </desc>`), WindowSolid[FILENAME], [[42, 4]]);
var root579 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M4 4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4Zm16 7H4v7h16v-7ZM5 8a1 1 0 0 1 1-1h.01a1 1 0 0 1 0 2H6a1 1 0 0 1-1-1Zm4-1a1 1 0 0 0 0 2h.01a1 1 0 0 0 0-2H9Zm2 1a1 1 0 0 1 1-1h.01a1 1 0 1 1 0 2H12a1 1 0 0 1-1-1Z" clip-rule="evenodd"></path></svg>`), WindowSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function WindowSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, WindowSolid);
  validate_prop_bindings($$props, [], [], WindowSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "window solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root579();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1579();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2579();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WindowSolid = hmr(WindowSolid, () => WindowSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WindowSolid[HMR].source;
    set(WindowSolid[HMR].source, module.default[HMR].original);
  });
}
var WindowSolid_default = WindowSolid;
mark_module_end(WindowSolid);

// node_modules/flowbite-svelte-icons/dist/WindowsSolid.svelte
mark_module_start();
WindowsSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/WindowsSolid.svelte";
var root_1580 = add_locations(ns_template(`<title> </title>`), WindowsSolid[FILENAME], [[39, 4]]);
var root_2580 = add_locations(ns_template(`<desc> </desc>`), WindowsSolid[FILENAME], [[42, 4]]);
var root580 = add_locations(ns_template(`<svg><!><!><path fill="currentColor" fill-rule="evenodd" d="M3.005 12 3 6.408l6.8-.923v6.517H3.005ZM11 5.32 19.997 4v8H11V5.32ZM20.067 13l-.069 8-9.065-1.275L11 13h9.067ZM9.8 19.58l-6.795-.931V13H9.8v6.58Z" clip-rule="evenodd"></path></svg>`), WindowsSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function WindowsSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, WindowsSolid);
  validate_prop_bindings($$props, [], [], WindowsSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "windows solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root580();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1580();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2580();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  WindowsSolid = hmr(WindowsSolid, () => WindowsSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = WindowsSolid[HMR].source;
    set(WindowsSolid[HMR].source, module.default[HMR].original);
  });
}
var WindowsSolid_default = WindowsSolid;
mark_module_end(WindowsSolid);

// node_modules/flowbite-svelte-icons/dist/XSolid.svelte
mark_module_start();
XSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/XSolid.svelte";
var root_1581 = add_locations(ns_template(`<title> </title>`), XSolid[FILENAME], [[39, 4]]);
var root_2581 = add_locations(ns_template(`<desc> </desc>`), XSolid[FILENAME], [[42, 4]]);
var root581 = add_locations(ns_template(`<svg><!><!><path d="M13.795 10.533 20.68 2h-3.073l-5.255 6.517L7.69 2H1l7.806 10.91L1.47 22h3.074l5.705-7.07L15.31 22H22l-8.205-11.467Zm-2.38 2.95L9.97 11.464 4.36 3.627h2.31l4.528 6.317 1.443 2.02 6.018 8.409h-2.31l-4.934-6.89Z"></path></svg>`), XSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function XSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, XSolid);
  validate_prop_bindings($$props, [], [], XSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "X solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root581();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1581();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2581();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  XSolid = hmr(XSolid, () => XSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = XSolid[HMR].source;
    set(XSolid[HMR].source, module.default[HMR].original);
  });
}
var XSolid_default = XSolid;
mark_module_end(XSolid);

// node_modules/flowbite-svelte-icons/dist/YoutubeSolid.svelte
mark_module_start();
YoutubeSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/YoutubeSolid.svelte";
var root_1582 = add_locations(ns_template(`<title> </title>`), YoutubeSolid[FILENAME], [[39, 4]]);
var root_2582 = add_locations(ns_template(`<desc> </desc>`), YoutubeSolid[FILENAME], [[42, 4]]);
var root582 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M21.7 8.037a4.26 4.26 0 0 0-.789-1.964 2.84 2.84 0 0 0-1.984-.839c-2.767-.2-6.926-.2-6.926-.2s-4.157 0-6.928.2a2.836 2.836 0 0 0-1.983.839 4.225 4.225 0 0 0-.79 1.965 30.146 30.146 0 0 0-.2 3.206v1.5a30.12 30.12 0 0 0 .2 3.206c.094.712.364 1.39.784 1.972.604.536 1.38.837 2.187.848 1.583.151 6.731.2 6.731.2s4.161 0 6.928-.2a2.844 2.844 0 0 0 1.985-.84 4.27 4.27 0 0 0 .787-1.965 30.12 30.12 0 0 0 .2-3.206v-1.516a30.672 30.672 0 0 0-.202-3.206Zm-11.692 6.554v-5.62l5.4 2.819-5.4 2.801Z" clip-rule="evenodd"></path></svg>`), YoutubeSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function YoutubeSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, YoutubeSolid);
  validate_prop_bindings($$props, [], [], YoutubeSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "youtube solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root582();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1582();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2582();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  YoutubeSolid = hmr(YoutubeSolid, () => YoutubeSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = YoutubeSolid[HMR].source;
    set(YoutubeSolid[HMR].source, module.default[HMR].original);
  });
}
var YoutubeSolid_default = YoutubeSolid;
mark_module_end(YoutubeSolid);

// node_modules/flowbite-svelte-icons/dist/ZoomInOutline.svelte
mark_module_start();
ZoomInOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ZoomInOutline.svelte";
var root_1583 = add_locations(ns_template(`<title> </title>`), ZoomInOutline[FILENAME], [[41, 4]]);
var root_2583 = add_locations(ns_template(`<desc> </desc>`), ZoomInOutline[FILENAME], [[44, 4]]);
var root583 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m21 21-3.5-3.5M10 7v6m-3-3h6m4 0a7 7 0 1 1-14 0 7 7 0 0 1 14 0Z"></path></svg>`), ZoomInOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ZoomInOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ZoomInOutline);
  validate_prop_bindings($$props, [], [], ZoomInOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "zoom in outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root583();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1583();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2583();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ZoomInOutline = hmr(ZoomInOutline, () => ZoomInOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ZoomInOutline[HMR].source;
    set(ZoomInOutline[HMR].source, module.default[HMR].original);
  });
}
var ZoomInOutline_default = ZoomInOutline;
mark_module_end(ZoomInOutline);

// node_modules/flowbite-svelte-icons/dist/ZoomInSolid.svelte
mark_module_start();
ZoomInSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ZoomInSolid.svelte";
var root_1584 = add_locations(ns_template(`<title> </title>`), ZoomInSolid[FILENAME], [[39, 4]]);
var root_2584 = add_locations(ns_template(`<desc> </desc>`), ZoomInSolid[FILENAME], [[42, 4]]);
var root584 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M21.707 21.707a1 1 0 0 1-1.414 0l-3.5-3.5a1 1 0 0 1 1.414-1.414l3.5 3.5a1 1 0 0 1 0 1.414ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm9-3a1 1 0 1 0-2 0v2H7a1 1 0 0 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2V7Z" clip-rule="evenodd"></path></svg>`), ZoomInSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ZoomInSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ZoomInSolid);
  validate_prop_bindings($$props, [], [], ZoomInSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "zoom in solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root584();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1584();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2584();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ZoomInSolid = hmr(ZoomInSolid, () => ZoomInSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ZoomInSolid[HMR].source;
    set(ZoomInSolid[HMR].source, module.default[HMR].original);
  });
}
var ZoomInSolid_default = ZoomInSolid;
mark_module_end(ZoomInSolid);

// node_modules/flowbite-svelte-icons/dist/ZoomOutOutline.svelte
mark_module_start();
ZoomOutOutline[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ZoomOutOutline.svelte";
var root_1585 = add_locations(ns_template(`<title> </title>`), ZoomOutOutline[FILENAME], [[41, 4]]);
var root_2585 = add_locations(ns_template(`<desc> </desc>`), ZoomOutOutline[FILENAME], [[44, 4]]);
var root585 = add_locations(ns_template(`<svg><!><!><path stroke="currentColor" stroke-linecap="round" d="m21 21-3.5-3.5M7 10h6m4 0a7 7 0 1 1-14 0 7 7 0 0 1 14 0Z"></path></svg>`), ZoomOutOutline[FILENAME], [[30, 0, [[46, 2]]]]);
function ZoomOutOutline($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ZoomOutOutline);
  validate_prop_bindings($$props, [], [], ZoomOutOutline);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), strokeWidth = prop($$props, "strokeWidth", 19, () => ctx.strokeWidth || "2"), ariaLabel = prop($$props, "ariaLabel", 3, "zoom out outline"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "strokeWidth",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root585();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1585();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2585();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  var path = sibling(node_1);
  reset(svg);
  template_effect(() => {
    attributes = set_attributes(
      svg,
      attributes,
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        color: color(),
        ...restProps,
        class: twMerge("shrink-0", sizes[size()], $$props.class),
        "aria-label": ariaLabel(),
        "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
        viewBox: "0 0 24 24"
      },
      void 0,
      true
    );
    set_attribute(path, "stroke-width", strokeWidth());
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ZoomOutOutline = hmr(ZoomOutOutline, () => ZoomOutOutline[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ZoomOutOutline[HMR].source;
    set(ZoomOutOutline[HMR].source, module.default[HMR].original);
  });
}
var ZoomOutOutline_default = ZoomOutOutline;
mark_module_end(ZoomOutOutline);

// node_modules/flowbite-svelte-icons/dist/ZoomOutSolid.svelte
mark_module_start();
ZoomOutSolid[FILENAME] = "node_modules/flowbite-svelte-icons/dist/ZoomOutSolid.svelte";
var root_1586 = add_locations(ns_template(`<title> </title>`), ZoomOutSolid[FILENAME], [[39, 4]]);
var root_2586 = add_locations(ns_template(`<desc> </desc>`), ZoomOutSolid[FILENAME], [[42, 4]]);
var root586 = add_locations(ns_template(`<svg><!><!><path fill-rule="evenodd" d="M21.707 21.707a1 1 0 0 1-1.414 0l-3.5-3.5a1 1 0 0 1 1.414-1.414l3.5 3.5a1 1 0 0 1 0 1.414ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm4 0a1 1 0 0 0 1 1h6a1 1 0 1 0 0-2H7a1 1 0 0 0-1 1Z" clip-rule="evenodd"></path></svg>`), ZoomOutSolid[FILENAME], [[29, 0, [[44, 2]]]]);
function ZoomOutSolid($$anchor, $$props) {
  var _a, _b;
  check_target(new.target);
  push($$props, true, ZoomOutSolid);
  validate_prop_bindings($$props, [], [], ZoomOutSolid);
  const ctx = getContext("iconCtx") ?? {};
  const sizes = {
    xs: "w-3 h-3",
    sm: "w-4 h-4",
    md: "w-5 h-5",
    lg: "w-6 h-6",
    xl: "w-8 h-8"
  };
  let size = prop($$props, "size", 19, () => ctx.size || "md"), color = prop($$props, "color", 19, () => ctx.color || "currentColor"), ariaLabel = prop($$props, "ariaLabel", 3, "zoom out solid"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "size",
      "color",
      "title",
      "desc",
      "class",
      "ariaLabel"
    ],
    "restProps"
  );
  let ariaDescribedby = `${((_a = $$props.title) == null ? void 0 : _a.id) || ""} ${((_b = $$props.desc) == null ? void 0 : _b.id) || ""}`;
  const hasDescription = derived(() => {
    var _a2, _b2;
    return !!(((_a2 = $$props.title) == null ? void 0 : _a2.id) || ((_b2 = $$props.desc) == null ? void 0 : _b2.id));
  });
  var svg = root586();
  let attributes;
  var node = child(svg);
  if_block(node, () => {
    var _a2;
    return ((_a2 = $$props.title) == null ? void 0 : _a2.id) && $$props.title.title;
  }, ($$anchor2) => {
    var title_1 = root_1586();
    var text = child(title_1, true);
    reset(title_1);
    template_effect(() => {
      set_attribute(title_1, "id", $$props.title.id);
      set_text(text, $$props.title.title);
    });
    append($$anchor2, title_1);
  });
  var node_1 = sibling(node);
  if_block(node_1, () => {
    var _a2;
    return ((_a2 = $$props.desc) == null ? void 0 : _a2.id) && $$props.desc.desc;
  }, ($$anchor2) => {
    var desc_1 = root_2586();
    var text_1 = child(desc_1, true);
    reset(desc_1);
    template_effect(() => {
      set_attribute(desc_1, "id", $$props.desc.id);
      set_text(text_1, $$props.desc.desc);
    });
    append($$anchor2, desc_1);
  });
  next();
  reset(svg);
  template_effect(() => attributes = set_attributes(
    svg,
    attributes,
    {
      xmlns: "http://www.w3.org/2000/svg",
      fill: color(),
      ...restProps,
      class: twMerge("shrink-0", sizes[size()], $$props.class),
      "aria-label": ariaLabel(),
      "aria-describedby": get(hasDescription) ? ariaDescribedby : void 0,
      viewBox: "0 0 24 24"
    },
    void 0,
    true
  ));
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ZoomOutSolid = hmr(ZoomOutSolid, () => ZoomOutSolid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ZoomOutSolid[HMR].source;
    set(ZoomOutSolid[HMR].source, module.default[HMR].original);
  });
}
var ZoomOutSolid_default = ZoomOutSolid;
mark_module_end(ZoomOutSolid);
export {
  AddColumnAfterOutline_default as AddColumnAfterOutline,
  AddColumnBeforeOutline_default as AddColumnBeforeOutline,
  AddressBookOutline_default as AddressBookOutline,
  AddressBookSolid_default as AddressBookSolid,
  AdjustmentsHorizontalOutline_default as AdjustmentsHorizontalOutline,
  AdjustmentsHorizontalSolid_default as AdjustmentsHorizontalSolid,
  AdjustmentsVerticalOutline_default as AdjustmentsVerticalOutline,
  AdjustmentsVerticalSolid_default as AdjustmentsVerticalSolid,
  AlignCenterOutline_default as AlignCenterOutline,
  AlignJustifyOutline_default as AlignJustifyOutline,
  AlignLeftOutline_default as AlignLeftOutline,
  AlignRightOutline_default as AlignRightOutline,
  AngleDownOutline_default as AngleDownOutline,
  AngleLeftOutline_default as AngleLeftOutline,
  AngleRightOutline_default as AngleRightOutline,
  AngleUpOutline_default as AngleUpOutline,
  AnnotationOutline_default as AnnotationOutline,
  AnnotationSolid_default as AnnotationSolid,
  ApiKeyOutline_default as ApiKeyOutline,
  AppleSolid_default as AppleSolid,
  ArchiveArrowDownOutline_default as ArchiveArrowDownOutline,
  ArchiveArrowDownSolid_default as ArchiveArrowDownSolid,
  ArchiveOutline_default as ArchiveOutline,
  ArchiveSolid_default as ArchiveSolid,
  ArrowDownOutline_default as ArrowDownOutline,
  ArrowDownToBracketOutline_default as ArrowDownToBracketOutline,
  ArrowLeftOutline_default as ArrowLeftOutline,
  ArrowLeftToBracketOutline_default as ArrowLeftToBracketOutline,
  ArrowRightAltOutline_default as ArrowRightAltOutline,
  ArrowRightAltSolid_default as ArrowRightAltSolid,
  ArrowRightOutline_default as ArrowRightOutline,
  ArrowRightToBracketOutline_default as ArrowRightToBracketOutline,
  ArrowSortLettersOutline_default as ArrowSortLettersOutline,
  ArrowUpDownOutline_default as ArrowUpDownOutline,
  ArrowUpFromBracketOutline_default as ArrowUpFromBracketOutline,
  ArrowUpOutline_default as ArrowUpOutline,
  ArrowUpRightDownLeftOutline_default as ArrowUpRightDownLeftOutline,
  ArrowUpRightFromSquareOutline_default as ArrowUpRightFromSquareOutline,
  ArrowUpRightFromSquareSolid_default as ArrowUpRightFromSquareSolid,
  ArrowsRepeatCountOutline_default as ArrowsRepeatCountOutline,
  ArrowsRepeatOutline_default as ArrowsRepeatOutline,
  AtomOutline_default as AtomOutline,
  AwardOutline_default as AwardOutline,
  AwardSolid_default as AwardSolid,
  AwsSolid_default as AwsSolid,
  BackwardStepOutline_default as BackwardStepOutline,
  BackwardStepSolid_default as BackwardStepSolid,
  BadgeCheckOutline_default as BadgeCheckOutline,
  BadgeCheckSolid_default as BadgeCheckSolid,
  BanOutline_default as BanOutline,
  BarcodeOutline_default as BarcodeOutline,
  BarsFromLeftOutline_default as BarsFromLeftOutline,
  BarsOutline_default as BarsOutline,
  BatteryOutline_default as BatteryOutline,
  BatterySolid_default as BatterySolid,
  BedOutline_default as BedOutline,
  BedSolid_default as BedSolid,
  BellActiveAltOutline_default as BellActiveAltOutline,
  BellActiveAltSolid_default as BellActiveAltSolid,
  BellActiveOutline_default as BellActiveOutline,
  BellActiveSolid_default as BellActiveSolid,
  BellOutline_default as BellOutline,
  BellRingOutline_default as BellRingOutline,
  BellRingSolid_default as BellRingSolid,
  BellSolid_default as BellSolid,
  BitcoinSolid_default as BitcoinSolid,
  BlenderPhoneOutline_default as BlenderPhoneOutline,
  BlenderPhoneSolid_default as BlenderPhoneSolid,
  BookOpenOutline_default as BookOpenOutline,
  BookOpenSolid_default as BookOpenSolid,
  BookOutline_default as BookOutline,
  BookSolid_default as BookSolid,
  BookmarkOutline_default as BookmarkOutline,
  BookmarkSolid_default as BookmarkSolid,
  BoothCurtainOutline_default as BoothCurtainOutline,
  BoothCurtainSolid_default as BoothCurtainSolid,
  BrainOutline_default as BrainOutline,
  BrainSolid_default as BrainSolid,
  BriefcaseOutline_default as BriefcaseOutline,
  BriefcaseSolid_default as BriefcaseSolid,
  BugOutline_default as BugOutline,
  BugSolid_default as BugSolid,
  BuildingOutline_default as BuildingOutline,
  BuildingSolid_default as BuildingSolid,
  BullhornOutline_default as BullhornOutline,
  BullhornSolid_default as BullhornSolid,
  CalendarEditOutline_default as CalendarEditOutline,
  CalendarEditSolid_default as CalendarEditSolid,
  CalendarMonthOutline_default as CalendarMonthOutline,
  CalendarMonthSolid_default as CalendarMonthSolid,
  CalendarPlusOutline_default as CalendarPlusOutline,
  CalendarPlusSolid_default as CalendarPlusSolid,
  CalendarWeekOutline_default as CalendarWeekOutline,
  CalendarWeekSolid_default as CalendarWeekSolid,
  CameraPhotoOutline_default as CameraPhotoOutline,
  CameraPhotoSolid_default as CameraPhotoSolid,
  CaptionOutline_default as CaptionOutline,
  CaptionSolid_default as CaptionSolid,
  CaretDownOutline_default as CaretDownOutline,
  CaretDownSolid_default as CaretDownSolid,
  CaretLeftOutline_default as CaretLeftOutline,
  CaretLeftSolid_default as CaretLeftSolid,
  CaretRightOutline_default as CaretRightOutline,
  CaretRightSolid_default as CaretRightSolid,
  CaretSortOutline_default as CaretSortOutline,
  CaretSortSolid_default as CaretSortSolid,
  CaretUpOutline_default as CaretUpOutline,
  CaretUpSolid_default as CaretUpSolid,
  CartOutline_default as CartOutline,
  CartPlusAltOutline_default as CartPlusAltOutline,
  CartPlusAltSolid_default as CartPlusAltSolid,
  CartPlusOutline_default as CartPlusOutline,
  CartPlusSolid_default as CartPlusSolid,
  CartSolid_default as CartSolid,
  CashOutline_default as CashOutline,
  CashRegisterOutline_default as CashRegisterOutline,
  CashRegisterSolid_default as CashRegisterSolid,
  CashSolid_default as CashSolid,
  CellAttributesOutline_default as CellAttributesOutline,
  ChartLineDownOutline_default as ChartLineDownOutline,
  ChartLineUpOutline_default as ChartLineUpOutline,
  ChartMixedDollarOutline_default as ChartMixedDollarOutline,
  ChartMixedDollarSolid_default as ChartMixedDollarSolid,
  ChartMixedOutline_default as ChartMixedOutline,
  ChartOutline_default as ChartOutline,
  ChartPieOutline_default as ChartPieOutline,
  ChartPieSolid_default as ChartPieSolid,
  CheckCircleOutline_default as CheckCircleOutline,
  CheckCircleSolid_default as CheckCircleSolid,
  CheckOutline_default as CheckOutline,
  CheckPlusCircleOutline_default as CheckPlusCircleOutline,
  CheckPlusCircleSolid_default as CheckPlusCircleSolid,
  ChevronDoubleDownOutline_default as ChevronDoubleDownOutline,
  ChevronDoubleLeftOutline_default as ChevronDoubleLeftOutline,
  ChevronDoubleRightOutline_default as ChevronDoubleRightOutline,
  ChevronDoubleUpOutline_default as ChevronDoubleUpOutline,
  ChevronDownOutline_default as ChevronDownOutline,
  ChevronLeftOutline_default as ChevronLeftOutline,
  ChevronRightOutline_default as ChevronRightOutline,
  ChevronSortOutline_default as ChevronSortOutline,
  ChevronUpOutline_default as ChevronUpOutline,
  CircleMinusOutline_default as CircleMinusOutline,
  CircleMinusSolid_default as CircleMinusSolid,
  CirclePauseOutline_default as CirclePauseOutline,
  CirclePauseSolid_default as CirclePauseSolid,
  CirclePlusOutline_default as CirclePlusOutline,
  CirclePlusSolid_default as CirclePlusSolid,
  ClapperboardPlayOutline_default as ClapperboardPlayOutline,
  ClapperboardPlaySolid_default as ClapperboardPlaySolid,
  ClipboardCheckOutline_default as ClipboardCheckOutline,
  ClipboardCheckSolid_default as ClipboardCheckSolid,
  ClipboardCleanOutline_default as ClipboardCleanOutline,
  ClipboardCleanSolid_default as ClipboardCleanSolid,
  ClipboardListOutline_default as ClipboardListOutline,
  ClipboardListSolid_default as ClipboardListSolid,
  ClipboardOutline_default as ClipboardOutline,
  ClipboardSolid_default as ClipboardSolid,
  ClockOutline_default as ClockOutline,
  ClockSolid_default as ClockSolid,
  CloseCircleOutline_default as CloseCircleOutline,
  CloseCircleSolid_default as CloseCircleSolid,
  CloseOutline_default as CloseOutline,
  CloudArrowUpOutline_default as CloudArrowUpOutline,
  CloudArrowUpSolid_default as CloudArrowUpSolid,
  CodeBranchOutline_default as CodeBranchOutline,
  CodeBranchSolid_default as CodeBranchSolid,
  CodeForkOutline_default as CodeForkOutline,
  CodeForkSolid_default as CodeForkSolid,
  CodeMergeOutline_default as CodeMergeOutline,
  CodeMergeSolid_default as CodeMergeSolid,
  CodeOutline_default as CodeOutline,
  CodePullRequestOutline_default as CodePullRequestOutline,
  CodePullRequestSolid_default as CodePullRequestSolid,
  CogOutline_default as CogOutline,
  CogSolid_default as CogSolid,
  ColumnOutline_default as ColumnOutline,
  ColumnSolid_default as ColumnSolid,
  CommandOutline_default as CommandOutline,
  CompressOutline_default as CompressOutline,
  ComputerSpeakerOutline_default as ComputerSpeakerOutline,
  ComputerSpeakerSolid_default as ComputerSpeakerSolid,
  CreditCardOutline_default as CreditCardOutline,
  CreditCardPlusAltOutline_default as CreditCardPlusAltOutline,
  CreditCardPlusAltSolid_default as CreditCardPlusAltSolid,
  CreditCardPlusOutline_default as CreditCardPlusOutline,
  CreditCardPlusSolid_default as CreditCardPlusSolid,
  CreditCardSolid_default as CreditCardSolid,
  CssSolid_default as CssSolid,
  DatabaseOutline_default as DatabaseOutline,
  DatabaseSolid_default as DatabaseSolid,
  DeleteColumnOutline_default as DeleteColumnOutline,
  DeleteRowOutline_default as DeleteRowOutline,
  DeleteTableOutline_default as DeleteTableOutline,
  DesktopPcOutline_default as DesktopPcOutline,
  DesktopPcSolid_default as DesktopPcSolid,
  DiscordSolid_default as DiscordSolid,
  DnaOutline_default as DnaOutline,
  DollarOutline_default as DollarOutline,
  DotsHorizontalOutline_default as DotsHorizontalOutline,
  DotsVerticalOutline_default as DotsVerticalOutline,
  DownloadOutline_default as DownloadOutline,
  DownloadSolid_default as DownloadSolid,
  DrawSquareOutline_default as DrawSquareOutline,
  DrawSquareSolid_default as DrawSquareSolid,
  DribbbleSolid_default as DribbbleSolid,
  DropboxSolid_default as DropboxSolid,
  EditOutline_default as EditOutline,
  EditSolid_default as EditSolid,
  EnvelopeOpenOutline_default as EnvelopeOpenOutline,
  EnvelopeOpenSolid_default as EnvelopeOpenSolid,
  EnvelopeOutline_default as EnvelopeOutline,
  EnvelopeSolid_default as EnvelopeSolid,
  EuroOutline_default as EuroOutline,
  ExclamationCircleOutline_default as ExclamationCircleOutline,
  ExclamationCircleSolid_default as ExclamationCircleSolid,
  ExpandOutline_default as ExpandOutline,
  EyeOutline_default as EyeOutline,
  EyeSlashOutline_default as EyeSlashOutline,
  EyeSlashSolid_default as EyeSlashSolid,
  EyeSolid_default as EyeSolid,
  FaceExplodeOutline_default as FaceExplodeOutline,
  FaceExplodeSolid_default as FaceExplodeSolid,
  FaceGrinOutline_default as FaceGrinOutline,
  FaceGrinSolid_default as FaceGrinSolid,
  FaceGrinStarsOutline_default as FaceGrinStarsOutline,
  FaceGrinStarsSolid_default as FaceGrinStarsSolid,
  FaceLaughOutline_default as FaceLaughOutline,
  FaceLaughSolid_default as FaceLaughSolid,
  FacebookSolid_default as FacebookSolid,
  FileChartBarOutline_default as FileChartBarOutline,
  FileChartBarSolid_default as FileChartBarSolid,
  FileCheckOutline_default as FileCheckOutline,
  FileCheckSolid_default as FileCheckSolid,
  FileCirclePlusOutline_default as FileCirclePlusOutline,
  FileCirclePlusSolid_default as FileCirclePlusSolid,
  FileCloneOutline_default as FileCloneOutline,
  FileCloneSolid_default as FileCloneSolid,
  FileCodeOutline_default as FileCodeOutline,
  FileCodeSolid_default as FileCodeSolid,
  FileCopyAltOutline_default as FileCopyAltOutline,
  FileCopyAltSolid_default as FileCopyAltSolid,
  FileCopyOutline_default as FileCopyOutline,
  FileCopySolid_default as FileCopySolid,
  FileCsvOutline_default as FileCsvOutline,
  FileCsvSolid_default as FileCsvSolid,
  FileDocOutline_default as FileDocOutline,
  FileDocSolid_default as FileDocSolid,
  FileExportOutline_default as FileExportOutline,
  FileExportSolid_default as FileExportSolid,
  FileImageOutline_default as FileImageOutline,
  FileImageSolid_default as FileImageSolid,
  FileImportOutline_default as FileImportOutline,
  FileImportSolid_default as FileImportSolid,
  FileInvoiceOutline_default as FileInvoiceOutline,
  FileInvoiceSolid_default as FileInvoiceSolid,
  FileLinesOutline_default as FileLinesOutline,
  FileLinesSolid_default as FileLinesSolid,
  FileMusicOutline_default as FileMusicOutline,
  FileMusicSolid_default as FileMusicSolid,
  FileOutline_default as FileOutline,
  FilePasteOutline_default as FilePasteOutline,
  FilePasteSolid_default as FilePasteSolid,
  FilePdfOutline_default as FilePdfOutline,
  FilePdfSolid_default as FilePdfSolid,
  FilePenOutline_default as FilePenOutline,
  FilePenSolid_default as FilePenSolid,
  FilePptOutline_default as FilePptOutline,
  FilePptSolid_default as FilePptSolid,
  FileSearchOutline_default as FileSearchOutline,
  FileSearchSolid_default as FileSearchSolid,
  FileShieldOutline_default as FileShieldOutline,
  FileShieldSolid_default as FileShieldSolid,
  FileSolid_default as FileSolid,
  FileVideoOutline_default as FileVideoOutline,
  FileVideoSolid_default as FileVideoSolid,
  FileWordOutline_default as FileWordOutline,
  FileWordSolid_default as FileWordSolid,
  FileZipOutline_default as FileZipOutline,
  FileZipSolid_default as FileZipSolid,
  FilterDollarOutline_default as FilterDollarOutline,
  FilterDollarSolid_default as FilterDollarSolid,
  FilterOutline_default as FilterOutline,
  FilterSolid_default as FilterSolid,
  FingerprintOutline_default as FingerprintOutline,
  FireOutline_default as FireOutline,
  FireSolid_default as FireSolid,
  FixTablesOutline_default as FixTablesOutline,
  FlagOutline_default as FlagOutline,
  FlagSolid_default as FlagSolid,
  FloppyDiskAltOutline_default as FloppyDiskAltOutline,
  FloppyDiskAltSolid_default as FloppyDiskAltSolid,
  FloppyDiskOutline_default as FloppyDiskOutline,
  FloppyDiskSolid_default as FloppyDiskSolid,
  FlowbiteSolid_default as FlowbiteSolid,
  FolderArrowRightOutline_default as FolderArrowRightOutline,
  FolderArrowRightSolid_default as FolderArrowRightSolid,
  FolderDuplicateOutline_default as FolderDuplicateOutline,
  FolderDuplicateSolid_default as FolderDuplicateSolid,
  FolderOpenOutline_default as FolderOpenOutline,
  FolderOpenSolid_default as FolderOpenSolid,
  FolderOutline_default as FolderOutline,
  FolderPlusOutline_default as FolderPlusOutline,
  FolderPlusSolid_default as FolderPlusSolid,
  FolderSolid_default as FolderSolid,
  FontColorAltSolid_default as FontColorAltSolid,
  FontColorOutline_default as FontColorOutline,
  FontFamilyOutline_default as FontFamilyOutline,
  FontHighlightOutline_default as FontHighlightOutline,
  ForwardOutline_default as ForwardOutline,
  ForwardSolid_default as ForwardSolid,
  ForwardStepOutline_default as ForwardStepOutline,
  ForwardStepSolid_default as ForwardStepSolid,
  GiftBoxOutline_default as GiftBoxOutline,
  GiftBoxSolid_default as GiftBoxSolid,
  GithubSolid_default as GithubSolid,
  GitlabSolid_default as GitlabSolid,
  GlobeOutline_default as GlobeOutline,
  GlobeSolid_default as GlobeSolid,
  GoToNextCellOutline_default as GoToNextCellOutline,
  GoToPrevCellOutline_default as GoToPrevCellOutline,
  GoogleSolid_default as GoogleSolid,
  GridOutline_default as GridOutline,
  GridPlusOutline_default as GridPlusOutline,
  GridPlusSolid_default as GridPlusSolid,
  GridSolid_default as GridSolid,
  HammerOutline_default as HammerOutline,
  HammerSolid_default as HammerSolid,
  HeadphonesOutline_default as HeadphonesOutline,
  HeadphonesSolid_default as HeadphonesSolid,
  HeartOutline_default as HeartOutline,
  HeartSolid_default as HeartSolid,
  HomeOutline_default as HomeOutline,
  HomeSolid_default as HomeSolid,
  HorizontalLinesOutline_default as HorizontalLinesOutline,
  HourglassOutline_default as HourglassOutline,
  HourglassSolid_default as HourglassSolid,
  HtmlSolid_default as HtmlSolid,
  IconOutline_default as IconOutline,
  IconSolid_default as IconSolid,
  ImageOutline_default as ImageOutline,
  ImageSolid_default as ImageSolid,
  InboxFullOutline_default as InboxFullOutline,
  InboxFullSolid_default as InboxFullSolid,
  InboxOutline_default as InboxOutline,
  InboxSolid_default as InboxSolid,
  IndentOutline_default as IndentOutline,
  IndentSolid_default as IndentSolid,
  InfoCircleOutline_default as InfoCircleOutline,
  InfoCircleSolid_default as InfoCircleSolid,
  InsertRowAfterOutline_default as InsertRowAfterOutline,
  InsertRowBeforeOutline_default as InsertRowBeforeOutline,
  InsertTableAltOutline_default as InsertTableAltOutline,
  InsertTableOutline_default as InsertTableOutline,
  InstagramSolid_default as InstagramSolid,
  KeyboardOutline_default as KeyboardOutline,
  KeyboardSolid_default as KeyboardSolid,
  LabelOutline_default as LabelOutline,
  LabelSolid_default as LabelSolid,
  LandmarkOutline_default as LandmarkOutline,
  LandmarkSolid_default as LandmarkSolid,
  LanguageOutline_default as LanguageOutline,
  LaravelSolid_default as LaravelSolid,
  LayersOutline_default as LayersOutline,
  LayersSolid_default as LayersSolid,
  LetterBoldOutline_default as LetterBoldOutline,
  LetterItalicOutline_default as LetterItalicOutline,
  LetterUnderlineOutline_default as LetterUnderlineOutline,
  LifeSaverOutline_default as LifeSaverOutline,
  LifeSaverSolid_default as LifeSaverSolid,
  LightbulbOutline_default as LightbulbOutline,
  LightbulbSolid_default as LightbulbSolid,
  LinkBreakOutline_default as LinkBreakOutline,
  LinkOutline_default as LinkOutline,
  LinkedinSolid_default as LinkedinSolid,
  ListMusicOutline_default as ListMusicOutline,
  ListMusicSolid_default as ListMusicSolid,
  ListOutline_default as ListOutline,
  LockOpenOutline_default as LockOpenOutline,
  LockOpenSolid_default as LockOpenSolid,
  LockOutline_default as LockOutline,
  LockSolid_default as LockSolid,
  LockTimeOutline_default as LockTimeOutline,
  LockTimeSolid_default as LockTimeSolid,
  MailBoxOutline_default as MailBoxOutline,
  MailBoxSolid_default as MailBoxSolid,
  MapPinAltOutline_default as MapPinAltOutline,
  MapPinAltSolid_default as MapPinAltSolid,
  MapPinOutline_default as MapPinOutline,
  MapPinSolid_default as MapPinSolid,
  MastercardSolid_default as MastercardSolid,
  MergeCellsOutline_default as MergeCellsOutline,
  MergeOrSplitOutline_default as MergeOrSplitOutline,
  MessageCaptionOutline_default as MessageCaptionOutline,
  MessageCaptionSolid_default as MessageCaptionSolid,
  MessageDotsOutline_default as MessageDotsOutline,
  MessageDotsSolid_default as MessageDotsSolid,
  MessagesOutline_default as MessagesOutline,
  MessagesSolid_default as MessagesSolid,
  MicrophoneOutline_default as MicrophoneOutline,
  MicrophoneSlashOutline_default as MicrophoneSlashOutline,
  MicrophoneSlashSolid_default as MicrophoneSlashSolid,
  MicrophoneSolid_default as MicrophoneSolid,
  MinimizeOutline_default as MinimizeOutline,
  MinusOutline_default as MinusOutline,
  MobilePhoneOutline_default as MobilePhoneOutline,
  MobilePhoneSolid_default as MobilePhoneSolid,
  MongoDbSolid_default as MongoDbSolid,
  MoonOutline_default as MoonOutline,
  MoonSolid_default as MoonSolid,
  NewspaperOutline_default as NewspaperOutline,
  NewspaperSolid_default as NewspaperSolid,
  NpmSolid_default as NpmSolid,
  ObjectsColumnOutline_default as ObjectsColumnOutline,
  ObjectsColumnSolid_default as ObjectsColumnSolid,
  OpenDoorOutline_default as OpenDoorOutline,
  OpenDoorSolid_default as OpenDoorSolid,
  OrderedListOutline_default as OrderedListOutline,
  OutdentOutline_default as OutdentOutline,
  OutdentSolid_default as OutdentSolid,
  PaletteOutline_default as PaletteOutline,
  PaletteSolid_default as PaletteSolid,
  PaperClipOutline_default as PaperClipOutline,
  PaperPlaneOutline_default as PaperPlaneOutline,
  PaperPlaneSolid_default as PaperPlaneSolid,
  ParagraphOutline_default as ParagraphOutline,
  ParagraphSolid_default as ParagraphSolid,
  PauseOutline_default as PauseOutline,
  PauseSolid_default as PauseSolid,
  PenNibOutline_default as PenNibOutline,
  PenNibSolid_default as PenNibSolid,
  PenOutline_default as PenOutline,
  PenSolid_default as PenSolid,
  PhoneHangupOutline_default as PhoneHangupOutline,
  PhoneHangupSolid_default as PhoneHangupSolid,
  PhoneOutline_default as PhoneOutline,
  PhoneSolid_default as PhoneSolid,
  PlayOutline_default as PlayOutline,
  PlaySolid_default as PlaySolid,
  PlusOutline_default as PlusOutline,
  PrinterOutline_default as PrinterOutline,
  PrinterSolid_default as PrinterSolid,
  ProfileCardOutline_default as ProfileCardOutline,
  ProfileCardSolid_default as ProfileCardSolid,
  QrCodeOutline_default as QrCodeOutline,
  QuestionCircleOutline_default as QuestionCircleOutline,
  QuestionCircleSolid_default as QuestionCircleSolid,
  QuoteOutline_default as QuoteOutline,
  QuoteSolid_default as QuoteSolid,
  ReactSolid_default as ReactSolid,
  ReceiptOutline_default as ReceiptOutline,
  ReceiptSolid_default as ReceiptSolid,
  RectangleListOutline_default as RectangleListOutline,
  RectangleListSolid_default as RectangleListSolid,
  RedditSolid_default as RedditSolid,
  RedoOutline_default as RedoOutline,
  RefreshOutline_default as RefreshOutline,
  ReplyAllOutline_default as ReplyAllOutline,
  ReplyAllSolid_default as ReplyAllSolid,
  ReplyOutline_default as ReplyOutline,
  ReplySolid_default as ReplySolid,
  RestoreWindowOutline_default as RestoreWindowOutline,
  RocketOutline_default as RocketOutline,
  RocketSolid_default as RocketSolid,
  RulerCombinedOutline_default as RulerCombinedOutline,
  SalePercentOutline_default as SalePercentOutline,
  SalePercentSolid_default as SalePercentSolid,
  ScaleBalancedOutline_default as ScaleBalancedOutline,
  ScaleBalancedSolid_default as ScaleBalancedSolid,
  SearchOutline_default as SearchOutline,
  SearchSolid_default as SearchSolid,
  ServerOutline_default as ServerOutline,
  ServerSolid_default as ServerSolid,
  ShareAllOutline_default as ShareAllOutline,
  ShareAllSolid_default as ShareAllSolid,
  ShareNodesOutline_default as ShareNodesOutline,
  ShareNodesSolid_default as ShareNodesSolid,
  ShieldCheckOutline_default as ShieldCheckOutline,
  ShieldCheckSolid_default as ShieldCheckSolid,
  ShieldOutline_default as ShieldOutline,
  ShieldSolid_default as ShieldSolid,
  ShoppingBagOutline_default as ShoppingBagOutline,
  ShoppingBagSolid_default as ShoppingBagSolid,
  ShuffleOutline_default as ShuffleOutline,
  SortHorizontalOutline_default as SortHorizontalOutline,
  SortOutline_default as SortOutline,
  SplitCellsOutline_default as SplitCellsOutline,
  StackoverflowSolid_default as StackoverflowSolid,
  StarHalfOutline_default as StarHalfOutline,
  StarHalfSolid_default as StarHalfSolid,
  StarHalfStrokeOutline_default as StarHalfStrokeOutline,
  StarHalfStrokeSolid_default as StarHalfStrokeSolid,
  StarOutline_default as StarOutline,
  StarSolid_default as StarSolid,
  StopOutline_default as StopOutline,
  StopSolid_default as StopSolid,
  StoreOutline_default as StoreOutline,
  StoreSolid_default as StoreSolid,
  SubscriptOutline_default as SubscriptOutline,
  SunOutline_default as SunOutline,
  SunSolid_default as SunSolid,
  SuperscriptOutline_default as SuperscriptOutline,
  SwatchbookOutline_default as SwatchbookOutline,
  SwatchbookSolid_default as SwatchbookSolid,
  TShirtOutline_default as TShirtOutline,
  TShirtSolid_default as TShirtSolid,
  TableColumnOutline_default as TableColumnOutline,
  TableColumnSolid_default as TableColumnSolid,
  TableRowOutline_default as TableRowOutline,
  TableRowSolid_default as TableRowSolid,
  TabletOutline_default as TabletOutline,
  TabletSolid_default as TabletSolid,
  TagOutline_default as TagOutline,
  TagSolid_default as TagSolid,
  TailwindSolid_default as TailwindSolid,
  TeddyBearOutline_default as TeddyBearOutline,
  TeddyBearSolid_default as TeddyBearSolid,
  TerminalOutline_default as TerminalOutline,
  TerminalSolid_default as TerminalSolid,
  TextSizeOutline_default as TextSizeOutline,
  TextSlashOutline_default as TextSlashOutline,
  TextUnderlineOutline_default as TextUnderlineOutline,
  ThumbsDownOutline_default as ThumbsDownOutline,
  ThumbsDownSolid_default as ThumbsDownSolid,
  ThumbsUpOutline_default as ThumbsUpOutline,
  ThumbsUpSolid_default as ThumbsUpSolid,
  ThumbtackOutline_default as ThumbtackOutline,
  ThumbtackSolid_default as ThumbtackSolid,
  TicketOutline_default as TicketOutline,
  TicketSolid_default as TicketSolid,
  ToggleHeaderCellOutline_default as ToggleHeaderCellOutline,
  ToggleHeaderColumnOutline_default as ToggleHeaderColumnOutline,
  ToggleHeaderRowOutline_default as ToggleHeaderRowOutline,
  ToolsOutline_default as ToolsOutline,
  TrackingOutline_default as TrackingOutline,
  TrackingSolid_default as TrackingSolid,
  TrashBinOutline_default as TrashBinOutline,
  TrashBinSolid_default as TrashBinSolid,
  TruckClockOutline_default as TruckClockOutline,
  TruckClockSolid_default as TruckClockSolid,
  TruckOutline_default as TruckOutline,
  TruckSolid_default as TruckSolid,
  TwitterSolid_default as TwitterSolid,
  UndoOutline_default as UndoOutline,
  UploadOutline_default as UploadOutline,
  UploadSolid_default as UploadSolid,
  UserAddOutline_default as UserAddOutline,
  UserAddSolid_default as UserAddSolid,
  UserCircleOutline_default as UserCircleOutline,
  UserCircleSolid_default as UserCircleSolid,
  UserEditOutline_default as UserEditOutline,
  UserEditSolid_default as UserEditSolid,
  UserHeadsetOutline_default as UserHeadsetOutline,
  UserHeadsetSolid_default as UserHeadsetSolid,
  UserOutline_default as UserOutline,
  UserRemoveOutline_default as UserRemoveOutline,
  UserRemoveSolid_default as UserRemoveSolid,
  UserSettingsOutline_default as UserSettingsOutline,
  UserSettingsSolid_default as UserSettingsSolid,
  UserSolid_default as UserSolid,
  UsersGroupOutline_default as UsersGroupOutline,
  UsersGroupSolid_default as UsersGroupSolid,
  UsersOutline_default as UsersOutline,
  UsersSolid_default as UsersSolid,
  VideoCameraOutline_default as VideoCameraOutline,
  VideoCameraSolid_default as VideoCameraSolid,
  VisaSolid_default as VisaSolid,
  VolumeDownOutline_default as VolumeDownOutline,
  VolumeDownSolid_default as VolumeDownSolid,
  VolumeMuteOutline_default as VolumeMuteOutline,
  VolumeMuteSolid_default as VolumeMuteSolid,
  VolumeUpOutline_default as VolumeUpOutline,
  VolumeUpSolid_default as VolumeUpSolid,
  VueSolid_default as VueSolid,
  WalletOutline_default as WalletOutline,
  WalletSolid_default as WalletSolid,
  WandMagicSparklesOutline_default as WandMagicSparklesOutline,
  WandMagicSparklesSolid_default as WandMagicSparklesSolid,
  WhatsappSolid_default as WhatsappSolid,
  WindowOutline_default as WindowOutline,
  WindowRestoreSolid_default as WindowRestoreSolid,
  WindowSolid_default as WindowSolid,
  WindowsSolid_default as WindowsSolid,
  XSolid_default as XSolid,
  YoutubeSolid_default as YoutubeSolid,
  ZoomInOutline_default as ZoomInOutline,
  ZoomInSolid_default as ZoomInSolid,
  ZoomOutOutline_default as ZoomOutOutline,
  ZoomOutSolid_default as ZoomOutSolid
};
//# sourceMappingURL=flowbite-svelte-icons.js.map
